<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>SDWebImage 源码学习笔记 ☞ SDWebImageManager | riversea2015</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="article">
<meta property="og:title" content="SDWebImage 源码学习笔记 ☞ SDWebImageManager">
<meta property="og:url" content="https://devhe.com/2019/01/20/SDWebImage-Source-Learning-03/index.html">
<meta property="og:site_name" content="riversea2015">
<meta property="og:locale">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2208988-29157f1c1fb6719f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2019-01-20T10:19:06.000Z">
<meta property="article:modified_time" content="2022-08-27T15:43:11.513Z">
<meta property="article:author" content="He Hai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2208988-29157f1c1fb6719f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="riversea2015" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">riversea2015</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Stay Hungry, Stay Young.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Rechercher"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://devhe.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-SDWebImage-Source-Learning-03" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/20/SDWebImage-Source-Learning-03/" class="article-date">
  <time class="dt-published" datetime="2019-01-20T10:19:06.000Z" itemprop="datePublished">2019-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      SDWebImage 源码学习笔记 ☞ SDWebImageManager
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-29157f1c1fb6719f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage-源码学习笔记.png"></p>
<span id="more"></span>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是本系列的第 3 篇，在前一篇中，我们了解了 SDWebImage 执行的基本流程，本篇就来介绍第一个核心类 <code>SDWebImageMananger</code>。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>SDWebImageMananger.h 文件基本可以分为 3 各部分：</p>
<p>①定义了一个枚举 <code>SDWebImageOptions </code>，列举了可能会用到的一些场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</span><br><span class="line">    // 重试已经失败的 url</span><br><span class="line">    SDWebImageRetryFailed = 1 &lt;&lt; 0,</span><br><span class="line">    // 低优先级，比如，在有 UI 交互的情况下，会延迟下载操作</span><br><span class="line">    SDWebImageLowPriority = 1 &lt;&lt; 1,</span><br><span class="line">    // 下载完成后，仅做内存缓存，不做磁盘缓存</span><br><span class="line">    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</span><br><span class="line">    // 下载过程中逐步加载图片，而不是完全下载完之后才展示</span><br><span class="line">    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</span><br><span class="line">    // 刷新缓存</span><br><span class="line">    SDWebImageRefreshCached = 1 &lt;&lt; 4,</span><br><span class="line">    // 当 App 进入后台时，继续下载任务，如果后台任务超时，操作将被自动取消</span><br><span class="line">    SDWebImageContinueInBackground = 1 &lt;&lt; 5,</span><br><span class="line">    // 允许处理 Cookie</span><br><span class="line">    SDWebImageHandleCookies = 1 &lt;&lt; 6,</span><br><span class="line">    // 允许不受信任的 SSL 证书，生产环境慎用</span><br><span class="line">    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</span><br><span class="line">    // 高优先级，即会把相应的图片放到最前边加载，而不是按照加入队列时的顺序执行</span><br><span class="line">    SDWebImageHighPriority = 1 &lt;&lt; 8,</span><br><span class="line">    // 延迟 placeholder 的加载，即在下载完成时才加载</span><br><span class="line">    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</span><br><span class="line">    // 对动图也执行 transform 操作</span><br><span class="line">    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</span><br><span class="line">    // 图片下载完成后，不直接自动给 imageView 赋值，给用户调整图片的机会</span><br><span class="line">    SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</span><br><span class="line">    // 依据设备内存缩放图片，如果设置了 `SDWebImageProgressiveDownload` ，此设置无效</span><br><span class="line">    SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12,</span><br><span class="line">    // 在有内存缓存的情况下，依然需要查询磁盘缓存，建议与 SDWebImageQueryDiskSync 配合使用</span><br><span class="line">    SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13,</span><br><span class="line">    // 同步查询磁盘缓存</span><br><span class="line">    SDWebImageQueryDiskSync = 1 &lt;&lt; 14,</span><br><span class="line">    // 仅加载缓存图片</span><br><span class="line">    SDWebImageFromCacheOnly = 1 &lt;&lt; 15,</span><br><span class="line">    // 对内存和磁盘中的 image 也执行 transition 的操作</span><br><span class="line">    SDWebImageForceTransition = 1 &lt;&lt; 16</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>②定义了一个协议 <code>SDWebImageManagerDelegate</code>，这里提供了以下 3 个协议方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 缓存中没有指定图片时，是否需要下载</span><br><span class="line">- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldDownloadImageForURL:(nullable NSURL *)imageURL;</span><br><span class="line"></span><br><span class="line">// 是否需要将制定 URL 标记为失败的 URL</span><br><span class="line">- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldBlockFailedURL:(nonnull NSURL *)imageURL withError:(nonnull NSError *)error;</span><br><span class="line"></span><br><span class="line">// 允许在刚刚下载到 image 并且未做缓存之前，对图片执行 transform，返回处理后的 image</span><br><span class="line">- (nullable UIImage *)imageManager:(nonnull SDWebImageManager *)imageManager transformDownloadedImage:(nullable UIImage *)image withURL:(nullable NSURL *)imageURL;</span><br></pre></td></tr></table></figure>

<p>③SDWebImageManager 的头文件，有几个重要属性，他们的作用见下边的注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 代理对象</span><br><span class="line">@property (weak, nonatomic, nullable) id &lt;SDWebImageManagerDelegate&gt; delegate;</span><br><span class="line">// 处理缓存的对象</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) SDImageCache *imageCache;</span><br><span class="line">// 处理下载工作的对象</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) SDWebImageDownloader *imageDownloader;</span><br><span class="line">// 一个用户定义的 block，用于生成 cacheKey</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</span><br><span class="line">// 一个用户定义的 block，用于序列化下载到的数据</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageCacheSerializerBlock cacheSerializer;</span><br></pre></td></tr></table></figure>

<p>下面是 2 个常用的创建方法：<code>+ (nonnull instancetype)sharedManager;</code> 和 <code>- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader;</code>，其实最终都是调用了后者 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 单例</span><br><span class="line">+ (nonnull instancetype)sharedManager &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化，创建处理缓存和下载任务的对象 cache 和 downloader</span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    SDImageCache *cache = [SDImageCache sharedImageCache];</span><br><span class="line">    SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</span><br><span class="line">    return [self initWithCache:cache downloader:downloader];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 核心的初始化方法，为各属性赋初值</span><br><span class="line">- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        // 处理缓存和下载任务的对象</span><br><span class="line">        _imageCache = cache;</span><br><span class="line">        _imageDownloader = downloader;</span><br><span class="line">        // 用于存储请求失败的 URL 的集合及操作时用的锁 (信号量)</span><br><span class="line">        _failedURLs = [NSMutableSet new];</span><br><span class="line">        _failedURLsLock = dispatch_semaphore_create(1);</span><br><span class="line">        // 存储运行中 operation 的集合，通过判断他的 count 是否为 0，判断操作是否在进行中：BOOL isRunning = (self.runningOperations.count &gt; 0);</span><br><span class="line">        _runningOperations = [NSMutableSet new];</span><br><span class="line">        // 操作时用的锁 (信号量)</span><br><span class="line">        _runningOperationsLock = dispatch_semaphore_create(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外几个方法，就不单独介绍了，用到的时候再继续讨论。此处，我们只看一个核心方法 <code>- (nullable id &lt;SDWebImageOperation&gt;)loadImageWithURL:url options:options progress:progressBlock completed:completedBlock;</code>，下面我们来一步步讨论这个方法的具体实现。</p>
<h5 id="1-校验参数"><a href="#1-校验参数" class="headerlink" title="1.校验参数"></a>1.校验参数</h5><p>依次做如下处理：如果传入的 completedBlock 为空，就直接报错；如果传入的参数是 NSString * 类型的，需要将其转换成 NSURL；最后，如果 url 还不是 NSURL 类型，那就只能将其置为 nil，以免造成后边 Crash。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line"></span><br><span class="line">if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">    url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">    url = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-生成总的-operation"><a href="#2-生成总的-operation" class="headerlink" title="2.生成总的 operation"></a>2.生成总的 operation</h5><p>他是 <code>SDWebImageCombinedOperation</code> 实例对象，也是当前方法要返回的结果，并将当前类赋值给 operation 的一个 weak 属性(避免循环引用)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">operation.manager = self; // 肯定是 weak 属性</span><br></pre></td></tr></table></figure>

<p><code>SDWebImageCombinedOperation</code> 的声明与实现文件均在当前类 <code>SDWebImageManager</code> 的实现文件里边，简单看一下他的 .h&#x2F;.m 文件吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCombinedOperation.h</span><br><span class="line">@interface SDWebImageCombinedOperation : NSObject &lt;SDWebImageOperation&gt;</span><br><span class="line">// 标识是否已取消</span><br><span class="line">@property (assign, nonatomic, getter = isCanceled) BOOL cancelled;</span><br><span class="line">// downloadToken 这是一个继承自 NSObject 的类，他有一个继承自 NSOperation 的属性，也就是真正执行下载操作时的 operation，cancel 时会用到</span><br><span class="line">@property (strong, nonatomic, nullable) SDWebImageDownloadToken *downloadToken;</span><br><span class="line">// 查询缓存时的 operation，用于标识当前 operation 是否已经被取消。其实查询缓存时，首先查看 operation.isCanceled，如果没被取消了，就会再去查询了。cancel 时会将其 isCanceled 属性置为 YES。</span><br><span class="line">@property (strong, nonatomic, nullable) NSOperation *cacheOperation;</span><br><span class="line">// manager</span><br><span class="line">@property (weak, nonatomic, nullable) SDWebImageManager *manager;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// SDWebImageCombinedOperation.m</span><br><span class="line">#pragma mark - 代理方法实现</span><br><span class="line"></span><br><span class="line">@implementation SDWebImageCombinedOperation</span><br><span class="line"></span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        self.cancelled = YES;</span><br><span class="line">        // 取消查询缓存的 Operation，此时 isCanceled 会被置为 YES。</span><br><span class="line">        if (self.cacheOperation) &#123;</span><br><span class="line">            [self.cacheOperation cancel];</span><br><span class="line">            self.cacheOperation = nil;</span><br><span class="line">        &#125;</span><br><span class="line">        // 取消下载操作</span><br><span class="line">        if (self.downloadToken) &#123;</span><br><span class="line">            [self.manager.imageDownloader cancel:self.downloadToken];</span><br><span class="line">        &#125;</span><br><span class="line">        // 将当前 operation 从 manager 中运行着的 operation 数组中移除。</span><br><span class="line">        [self.manager safelyRemoveOperationFromRunning:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  SDWebImageOperation 协议的定义</span><br><span class="line">@protocol SDWebImageOperation &lt;NSObject&gt;</span><br><span class="line">- (void)cancel;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>SDWebImageCombinedOperation</code> 这个类的主要作用就是 cancel 操作，包括 cancel 查询缓存 和 cancel 下载数据。</p>
<h5 id="3-再次检测一下-url"><a href="#3-再次检测一下-url" class="headerlink" title="3.再次检测一下 url"></a>3.再次检测一下 url</h5><p>如果是曾经失败的 url，而且不允许重试，或者 url 为空时，执行 completionBlock，并返回当前 operation。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// self.failedURLs 是一个保存曾经失败过的 URL 的数组，用于检测当前 URL 是不是曾经请求失败过的URL.另外，搜索一个个元素的时候，NSSet 比 NSArray 查询更快。</span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        LOCK(self.failedURLsLock);</span><br><span class="line">        isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">        UNLOCK(self.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 若出现以下两种情况就不再往下走了，直接执行 CompletionBlock：① URL 是空的；② 此 URL 是曾经请求失败的 URL，并且规定不允许重新请求曾经失败的 URL。</span><br><span class="line">    if (url.absoluteString.length == 0</span><br><span class="line">        || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl))</span><br><span class="line">    &#123;</span><br><span class="line">        [self callCompletionBlockForOperation:operation</span><br><span class="line">                                   completion:completedBlock</span><br><span class="line">                                        error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil]</span><br><span class="line">                                          url:url];</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-保存-operation-至-self-runningOperations"><a href="#4-保存-operation-至-self-runningOperations" class="headerlink" title="4.保存 operation 至 self.runningOperations"></a>4.保存 <code>operation</code> 至 <code>self.runningOperations</code></h5><p>后者是一个数组，这里使用了信号量来确保线程安装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCK(self.runningOperationsLock);</span><br><span class="line">[self.runningOperations addObject:operation];</span><br><span class="line">UNLOCK(self.runningOperationsLock);</span><br></pre></td></tr></table></figure>

<h5 id="5-查询缓存。"><a href="#5-查询缓存。" class="headerlink" title="5.查询缓存。"></a>5.查询缓存。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSString *key = [self cacheKeyForURL:url];</span><br><span class="line"></span><br><span class="line">SDImageCacheOptions cacheOptions = 0;</span><br><span class="line">if (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;</span><br><span class="line">if (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;</span><br><span class="line">if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;</span><br><span class="line"></span><br><span class="line">__weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line"></span><br><span class="line">operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key</span><br><span class="line">                                                              options:cacheOptions</span><br><span class="line">                                                                 done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType)</span><br><span class="line">&#123;</span><br><span class="line">    // 查询完成后的操作在这里，可能查到了，也可能没查到...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先准备了 2 个参数，查询的依据 key 和一些条件 cacheOptions。key 的获取是通过一个私有方法 (如下)，如果自定义了 <code>key</code> 的生成规则 self.cacheKeyFilter，就用自定义的，如果没有，就直接取 url.absoluteString。<code>cacheOptions</code> 是一个用 NS_OPTIONS 定义的枚举类型 (前边已介绍过)，可组合多种情况，在这里综合了 2 个查询的要求和 1 个缩放图片的要求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)cacheKeyForURL:(nullable NSURL *)url &#123;</span><br><span class="line">    if (!url) &#123;</span><br><span class="line">        return @&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.cacheKeyFilter) &#123;</span><br><span class="line">        return self.cacheKeyFilter(url);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return url.absoluteString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-查询的具体过程"><a href="#6-查询的具体过程" class="headerlink" title="6.查询的具体过程"></a>6.查询的具体过程</h5><p>详情将会在 <a href="">SDImageCache</a> 中介绍，下面讨论一下查询缓存结束后的操作。</p>
<h5 id="7-移除当前-operation"><a href="#7-移除当前-operation" class="headerlink" title="7.移除当前 operation"></a>7.移除当前 operation</h5><p>从 self.runningOperations 这个数组中移除当前 operation。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">    [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="8-判断是否需要下载"><a href="#8-判断是否需要下载" class="headerlink" title="8.判断是否需要下载"></a>8.判断是否需要下载</h5><p>当同时满足 3 个要求时，就需要下载新数据了：<br>①没要求只能从缓存获取数据，即当缓存找不到时，可以去下载；<br>②找不到缓存 或 要求必须更新缓存；<br>③当 self.delegate 没有遵守协议， 或者 协议方法返回 YES。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly)) </span><br><span class="line">        &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached) </span><br><span class="line">        &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]);</span><br></pre></td></tr></table></figure>

<h5 id="9-若需要下载"><a href="#9-若需要下载" class="headerlink" title="9.若需要下载"></a>9.若需要下载</h5><ul>
<li>首先依然要做一个判断，即 如果有缓存数据并且要求刷新缓存数据时，需要先调用一次 CompletionBlock，将缓存数据返回去，然后再开始下载新数据，代码如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">    [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，准备下载数据时所需的一些基本选项，可以参考篇头介绍的枚举 <code>SDWebImageOptions</code>。</p>
<ul>
<li>开始下载，调用了 SDWebImageDownloader 的下载方法，留待 <a href="">SDWebImageDownloader</a> 介绍，这里只讨论下载完成之后的操作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(strongOperation) weakSubOperation = strongOperation;</span><br><span class="line">            strongOperation.downloadToken = [self.imageDownloader downloadImageWithURL:url</span><br><span class="line">                                                                               options:downloaderOptions</span><br><span class="line">                                                                              progress:progressBlock</span><br><span class="line">                                                                             completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished)</span><br><span class="line">&#123;</span><br><span class="line">        // 下载完成后的操作...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下载完成后，可以分这么几种情况：<br>a.当前 operation 已经被取消，这种情况下不作任何操作，包括回调。</p>
<p>b.下载出错，先将失败的 error 信息返回，然后决定是否需要将当前 URL 存入失败的 URL 数组。</p>
<p>c.下载成功，此时要做的工作还有许多：</p>
<p> ①如果设置了失败重发，则将当前 URL 从失败的 URL 数组中移除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">    LOCK(self.failedURLsLock);</span><br><span class="line">    [self.failedURLs removeObject:url];</span><br><span class="line">    UNLOCK(self.failedURLsLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②对于自定义的 manager，需要执行另外一套缩放标准。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (self != [SDWebImageManager sharedManager]</span><br><span class="line">                        &amp;&amp; self.cacheKeyFilter</span><br><span class="line">                        &amp;&amp; downloadedImage)</span><br><span class="line">&#123;</span><br><span class="line">    downloadedImage = [self scaledImageForKey:key image:downloadedImage];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③若需要更新缓存，但是未下载到图片，且缓存中本来有值的情况下，什么也不做，因为下载之前早已经缓存数据返回了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">// 需要更新缓存，但是未下载到图片，且缓存中本来有值的情况下，什么也不做，因为下载之前早已经缓存数据返回了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④如果下载到了图片，并且要求 transform 图片的情况下，异步执行 transform 和缓存图片的工作，然后回到主线程执行 completionBlock。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        </span><br><span class="line">        UIImage *transformedImage = [self.delegate imageManager:self</span><br><span class="line">                                       transformDownloadedImage:downloadedImage</span><br><span class="line">                                                        withURL:url];</span><br><span class="line">        </span><br><span class="line">        if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">            </span><br><span class="line">            BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">            NSData *cacheData;</span><br><span class="line">            // pass nil if the image was transformed, so we can recalculate the data from the image</span><br><span class="line">            if (self.cacheSerializer) &#123;</span><br><span class="line">                cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cacheData = (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // *** 存盘：注意是存的 imageData</span><br><span class="line">            [self.imageCache storeImage:transformedImage</span><br><span class="line">                              imageData:cacheData</span><br><span class="line">                                 forKey:key</span><br><span class="line">                                 toDisk:cacheOnDisk</span><br><span class="line">                             completion:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [self callCompletionBlockForOperation:strongSubOperation</span><br><span class="line">                                   completion:completedBlock</span><br><span class="line">                                        image:transformedImage</span><br><span class="line">                                         data:downloadedData</span><br><span class="line">                                        error:nil</span><br><span class="line">                                    cacheType:SDImageCacheTypeNone</span><br><span class="line">                                     finished:finished</span><br><span class="line">                                          url:url];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>⑤如果下载到了图片，并且下载完成的话，则存盘并执行 completionBlock。存盘调用了 <code>SDImageCache</code> 的方法，随后介绍。</p>
<p>最后将当前 operation 移除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        </span><br><span class="line">        UIImage *transformedImage = [self.delegate imageManager:self</span><br><span class="line">                                       transformDownloadedImage:downloadedImage</span><br><span class="line">                                                        withURL:url];</span><br><span class="line">        </span><br><span class="line">        if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">            </span><br><span class="line">            BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">            NSData *cacheData;</span><br><span class="line">            // pass nil if the image was transformed, so we can recalculate the data from the image</span><br><span class="line">            if (self.cacheSerializer) &#123;</span><br><span class="line">                cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cacheData = (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // *** 存盘：注意是存的 imageData</span><br><span class="line">            [self.imageCache storeImage:transformedImage</span><br><span class="line">                              imageData:cacheData</span><br><span class="line">                                 forKey:key</span><br><span class="line">                                 toDisk:cacheOnDisk</span><br><span class="line">                             completion:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [self callCompletionBlockForOperation:strongSubOperation</span><br><span class="line">                                   completion:completedBlock</span><br><span class="line">                                        image:transformedImage</span><br><span class="line">                                         data:downloadedData</span><br><span class="line">                                        error:nil</span><br><span class="line">                                    cacheType:SDImageCacheTypeNone</span><br><span class="line">                                     finished:finished</span><br><span class="line">                                          url:url];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">if (finished) &#123;</span><br><span class="line">    [self safelyRemoveOperationFromRunning:strongSubOperation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-若不需要下载，并且有缓存"><a href="#10-若不需要下载，并且有缓存" class="headerlink" title="10.若不需要下载，并且有缓存"></a>10.若不需要下载，并且有缓存</h5><p>此时，执行 completionBlock 将缓存数据返回，然后移除当前 operation。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[self callCompletionBlockForOperation:strongOperation</span><br><span class="line">                           completion:completedBlock</span><br><span class="line">                                image:cachedImage</span><br><span class="line">                                 data:cachedData</span><br><span class="line">                                error:nil</span><br><span class="line">                            cacheType:cacheType</span><br><span class="line">                             finished:YES</span><br><span class="line">                                  url:url];</span><br><span class="line">            </span><br><span class="line">[self safelyRemoveOperationFromRunning:strongOperation];</span><br></pre></td></tr></table></figure>

<h5 id="11-其它，即没有缓存，且不需要下载"><a href="#11-其它，即没有缓存，且不需要下载" class="headerlink" title="11.其它，即没有缓存，且不需要下载"></a>11.其它，即没有缓存，且不需要下载</h5><p>和上边的操作类似，只不过传回的 image 和 data 均为 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[self callCompletionBlockForOperation:strongOperation</span><br><span class="line">                           completion:completedBlock</span><br><span class="line">                                image:nil</span><br><span class="line">                                 data:nil</span><br><span class="line">                                error:nil</span><br><span class="line">                            cacheType:SDImageCacheTypeNone</span><br><span class="line">                             finished:YES</span><br><span class="line">                                  url:url];</span><br><span class="line"></span><br><span class="line">[self safelyRemoveOperationFromRunning:strongOperation];</span><br></pre></td></tr></table></figure>

<p>最后将 operation 返回。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上就是 SDWebImageManager 这个类的主要功能，其中关于缓存和下载的内容，详见后边几篇的讨论。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/01/20/SDWebImage-Source-Learning-03/" data-id="cl7c27fgz0003jlfy0sq5corh" data-title="SDWebImage 源码学习笔记 ☞ SDWebImageManager" class="article-share-link">Partager</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/01/26/SDWebImage-Source-Learning-04/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          SDWebImage 源码学习笔记 ☞ SDWebImageDownloader
        
      </div>
    </a>
  
  
    <a href="/2019/01/12/SDWebImage-Source-Learning-02/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">SDWebImage 源码学习笔记 ☞ 结构及基本流程</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/24/ijkplayer-Compilation-and-Packaging/">ijkplayer 编译-打包-Pod支持</a>
          </li>
        
          <li>
            <a href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/">iOS UITextView 实现类似微博的话题、提及功能</a>
          </li>
        
          <li>
            <a href="/2019/03/24/MLeaksFinder-Source-Learning/">MLeaksFinder 源码学习笔记</a>
          </li>
        
          <li>
            <a href="/2019/03/17/AFNetWorking-Source-Learning-05/">AFNetWorking 源码学习笔记 ☞ Reachability</a>
          </li>
        
          <li>
            <a href="/2019/03/10/AFNetWorking-Source-Learning-04/">AFNetWorking 源码学习笔记 ☞ Serialization</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 He Hai<br>
      Propulsé par <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>