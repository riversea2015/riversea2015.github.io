<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>MLeaksFinder 源码学习笔记 | riversea2015</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="article">
<meta property="og:title" content="MLeaksFinder 源码学习笔记">
<meta property="og:url" content="https://devhe.com/2019/04/10/MLeaksFinder-Source-Learning/index.html">
<meta property="og:site_name" content="riversea2015">
<meta property="og:locale">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f8bb4a760fe4d21a7421f0ad81b4dd7~tplv-k3u1fbpfcp-watermark.image">
<meta property="article:published_time" content="2019-04-10T13:10:18.000Z">
<meta property="article:modified_time" content="2022-08-28T05:34:15.303Z">
<meta property="article:author" content="He Hai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f8bb4a760fe4d21a7421f0ad81b4dd7~tplv-k3u1fbpfcp-watermark.image">
  
    <link rel="alternate" href="/atom.xml" title="riversea2015" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">riversea2015</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Stay Hungry, Stay Young.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://devhe.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-MLeaksFinder-Source-Learning" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/04/10/MLeaksFinder-Source-Learning/" class="article-date">
  <time class="dt-published" datetime="2019-04-10T13:10:18.000Z" itemprop="datePublished">2019-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      MLeaksFinder 源码学习笔记
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f8bb4a760fe4d21a7421f0ad81b4dd7~tplv-k3u1fbpfcp-watermark.image" alt="MLeaksFinder_cover.png"></p>
<span id="more"></span>

<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><p>项目中集成了 <code>MLeaksFinder</code> 用于平时检测内存泄漏之用，它的基本工作原理也多少了解一些，最近恰好有点空闲时间，决定还是仔细看一下源码实现，毕竟自己查的才比较放心O(∩_∩)O哈哈~，于是就有了本文。</p>
<h2 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h2><p><code>MLeaksFinder</code> 的使用非常人性化，直接通过 cocoaPods 导入工程中就行，当检测到泄露的时候会自动在控制台打印出相关堆栈信息。</p>
<h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><h3 id="2-1-基本原理"><a href="#2-1-基本原理" class="headerlink" title="2.1 基本原理"></a>2.1 基本原理</h3><p>一般情况下，当一个 ViewController 或 NavigationController 被 dismiss 或 pop 的时候，它自己、view、view的 subView 等都应该会很快释放掉。于是，只需要在 dismiss 或 pop 之后检测这些对象是否还存在，就可以判断是否存在内泄。</p>
<!--more-->

<h3 id="2-2-MLeaksFinder-的基本实现"><a href="#2-2-MLeaksFinder-的基本实现" class="headerlink" title="2.2 MLeaksFinder 的基本实现"></a>2.2 MLeaksFinder 的基本实现</h3><p>为基类 NSObject 添加一个方法 <code>-willDealloc</code> ，它先用一个弱指针指向 self，并在一小段时间 (2秒) 后，通过这个弱指针调用 <code>-assertNotDealloc</code>，而 <code>-assertNotDealloc</code> 主要作用是打印堆栈信息 (早期版本是直接中断言，不过那样会打断正常的开发工作)。</p>
<p>当我们认为某个对象应该要被释放了，在释放前调用 <code>-assertNotDealloc</code> ，如果 2 秒后它被释放成功，weakSelf 就指向 nil，<code>-assertNotDealloc</code> 方法就不会执行（向 nil 发送消息，实际什么也不会做），如果它没被释放，<code>-assertNotDealloc</code> 就会执行，从而打印出堆栈信息。</p>
<p>于是，当一个NavigationController 或 UIViewController 被 pop 或 dismiss 时，我们遍历它的所有 view，依次调 <code>-willDealloc</code>（对 <code>-willDealloc</code> 的调用是通过 method-swizzle 追加到 pop&#x2F;dismiss 方法中的），若 2 秒后没被释放，就会打印相关堆栈信息。</p>
<h2 id="3-源码"><a href="#3-源码" class="headerlink" title="3.源码"></a>3.源码</h2><h3 id="NSObject-MemoryLeak"><a href="#NSObject-MemoryLeak" class="headerlink" title="NSObject+MemoryLeak"></a>NSObject+MemoryLeak</h3><p>先来看看基类 NSObject 的分类 <code>NSObject+MemoryLeak</code> ，这里提供了以下公开方法，详见注释，其中第二个方法只有这个宏 <code>#define MLCheck(TARGET) [self willReleaseObject:(TARGET) relationship:@#TARGET];</code> 会用到，而这个宏是留给我们扩展功能使用的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 入口方法</span></span><br><span class="line">- (<span class="type">BOOL</span>)willDealloc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用于扩展，即 MLCheck(TARGET) 中会用到</span></span><br><span class="line">- (<span class="type">void</span>)willReleaseObject:(<span class="type">id</span>)object relationship:(<span class="built_in">NSString</span> *)relationship;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于构造堆栈信息</span></span><br><span class="line">- (<span class="type">void</span>)willReleaseChild:(<span class="type">id</span>)child;</span><br><span class="line">- (<span class="type">void</span>)willReleaseChildren:(<span class="built_in">NSArray</span> *)children;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 堆栈信息数组，元素是类名</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)viewStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 添加新类名到白名单</span></span><br><span class="line">+ (<span class="type">void</span>)addClassNamesToWhitelist:(<span class="built_in">NSArray</span> *)classNames;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 交换方法</span></span><br><span class="line">+ (<span class="type">void</span>)swizzleSEL:(SEL)originalSEL withSEL:(SEL)swizzledSEL;</span><br></pre></td></tr></table></figure>

<p>接着查看他的实现文件，首先是 <code>-willDealloc</code> 方法，实现如下，做了三件事：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.检测白名单</span></span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="keyword">if</span> ([[<span class="built_in">NSObject</span> classNamesWhitelist] containsObject:className])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.fix bug</span></span><br><span class="line">    <span class="built_in">NSNumber</span> *senderPtr = objc_getAssociatedObject([<span class="built_in">UIApplication</span> sharedApplication], kLatestSenderKey);</span><br><span class="line">    <span class="keyword">if</span> ([senderPtr isEqualToNumber:@((uintptr_t)<span class="keyword">self</span>)])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.核心：延迟 2 秒执行 -assertNotDealloc 方法</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="type">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="type">id</span> strongSelf = weakSelf;</span><br><span class="line">        [strongSelf assertNotDealloc];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>检测白名单</p>
<p>检测当前对象是否在白名单中，如果在，就不调用 <code>-assertNotDealloc</code> 方法，既不检测内泄。构建基础白名单时，使用了单例，确保只有一个，这个方法是私有的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSMutableSet</span> *)classNamesWhitelist &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSMutableSet</span> *whitelist = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        whitelist = [<span class="built_in">NSMutableSet</span> setWithObjects:</span><br><span class="line">                     <span class="string">@&quot;UIFieldEditor&quot;</span>, <span class="comment">// UIAlertControllerTextField</span></span><br><span class="line">                     <span class="string">@&quot;UINavigationBar&quot;</span>,</span><br><span class="line">                     <span class="string">@&quot;_UIAlertControllerActionView&quot;</span>,</span><br><span class="line">                     <span class="string">@&quot;_UIVisualEffectBackdropView&quot;</span>,</span><br><span class="line">                     <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System&#x27;s bug since iOS 10 and not fixed yet up to this ci.</span></span><br><span class="line">        <span class="built_in">NSString</span> *systemVersion = [<span class="built_in">UIDevice</span> currentDevice].systemVersion;</span><br><span class="line">        <span class="keyword">if</span> ([systemVersion compare:<span class="string">@&quot;10.0&quot;</span> options:<span class="built_in">NSNumericSearch</span>] != <span class="built_in">NSOrderedAscending</span>) &#123;</span><br><span class="line">            [whitelist addObject:<span class="string">@&quot;UISwitch&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> whitelist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，用户也可以自行添加额外的类名，方法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)addClassNamesToWhitelist:(<span class="built_in">NSArray</span> *)classNames &#123;</span><br><span class="line">    [[<span class="keyword">self</span> classNamesWhitelist] addObjectsFromArray:classNames];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修复一个 bug</p>
<p>此处处理一个了bug，即 <code>在button 的点击事件或者UITableview 的点击Cell的事件中调用self.navigationController popViewControllerAnimated:YES 时就报没有释放</code> ，详见文末的参考。</p>
</li>
<li><p>核心：延迟 2 秒执行 <code>-assertNotDealloc</code> 方法</p>
<p>用弱引用 weakSelf 指向 self，延迟 2 秒执行 weakSelf 的 <code>-assertNotDealloc</code> 方法，这个方法如果能够执行，则说明当前对象泄露了。</p>
</li>
</ul>
<p>从下面的代码可以看出来，<code>-assertNotDealloc</code> 做了2 件事：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)assertNotDealloc &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.检测父控件体系中是否有没被释放的</span></span><br><span class="line">    <span class="keyword">if</span> ([MLeakedObjectProxy isAnyObjectLeakedAtPtrs:[<span class="keyword">self</span> parentPtrs]]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [MLeakedObjectProxy addLeakedObject:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.打印堆栈信息</span></span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Possibly Memory Leak.\nIn case that %@ should not be dealloced, override -willDealloc in %@ by returning NO.\nView-ViewController stack: %@&quot;</span>, className, className, 	[<span class="keyword">self</span> viewStack]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>判断当前对象父控件的层级体系中是否有没被释放的对象，如果有就不往下执行了，否则把自己加进去，并打印堆栈信息。</p>
<p>因为父对象的 <code>-willDealloc</code> 会先执行，所以如果父对象一定会销毁的话，那么也应该是先销毁，即先从  <code>MLeakedObjectProxy</code> 中移除，加了这个判断之后，就不会出现一个堆栈中出现多个未释放对象的情况。</p>
<p>这里用到了 2 个 <code>MLeakedObjectProxy</code> 中的方法 <code>+isAnyObjectLeakedAtPtrs:</code> 和 <code>+addLeakedObject:</code>，后边会讲到。</p>
</li>
<li><p>打印 <code>viewStack</code> 这个数组，数组里存放的是从父对象到子对象，一直到当前对象的类名。</p>
</li>
</ul>
<p>我们看看 <code>viewStack</code> 的 setter 和 getter，这里用到了运行时机制，即利用关联对象给一个类添加属性信息。<code>viewStack</code> 是一个数组，存放的是类名，从 getter 可以看出来，初次使用时，直接将当前类名作为第一个元素添加进去了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)viewStack &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *viewStack = objc_getAssociatedObject(<span class="keyword">self</span>, kViewStackKey);</span><br><span class="line">    <span class="keyword">if</span> (viewStack) &#123;</span><br><span class="line">        <span class="keyword">return</span> viewStack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="keyword">return</span> @[ className ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setViewStack:(<span class="built_in">NSArray</span> *)viewStack &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, kViewStackKey, viewStack, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便看一下前边用到的 <code>parentPtrs</code> 的 setter 和 getter，从下边的源码可看出来，二者的方法实现类似，只不过后者是一个集合 set，前者是 数组 array。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSSet</span> *)parentPtrs &#123;</span><br><span class="line">    <span class="built_in">NSSet</span> *parentPtrs = objc_getAssociatedObject(<span class="keyword">self</span>, kParentPtrsKey);</span><br><span class="line">    <span class="keyword">if</span> (!parentPtrs) &#123;</span><br><span class="line">        parentPtrs = [[<span class="built_in">NSSet</span> alloc] initWithObjects:@((uintptr_t)<span class="keyword">self</span>), <span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parentPtrs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setParentPtrs:(<span class="built_in">NSSet</span> *)parentPtrs &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, kParentPtrsKey, parentPtrs, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，后续这个 <code>viewStack</code>  和 <code>parentPtrs</code> 又是什么时候构建的呢？这里提供了 2 个供外界调用的构建方法，最终是依赖后一个方法 <code>- willReleaseChildren</code> 实现的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)willReleaseChild:(<span class="type">id</span>)child &#123;</span><br><span class="line">    <span class="keyword">if</span> (!child) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> willReleaseChildren:@[ child ]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)willReleaseChildren:(<span class="built_in">NSArray</span> *)children &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *viewStack = [<span class="keyword">self</span> viewStack];</span><br><span class="line">    <span class="built_in">NSSet</span> *parentPtrs = [<span class="keyword">self</span> parentPtrs];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">id</span> child <span class="keyword">in</span> children) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>([child <span class="keyword">class</span>]);</span><br><span class="line">        [child setViewStack:[viewStack arrayByAddingObject:className]]; <span class="comment">// 存的是类名</span></span><br><span class="line">        [child setParentPtrs:[parentPtrs setByAddingObject:@((uintptr_t)child)]]; <span class="comment">// 存的是对象地址</span></span><br><span class="line"></span><br><span class="line">        [child willDealloc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细观察上边的 <code>willReleaseChildren:</code> 方法发现，就做了两件事：</p>
<ul>
<li><p>拿到当前对象的 viewStack 和 parentPtrs，然后遍历 children，为每一个 child 设置 <code>viewStack</code> 和 <code>parentPtrs</code> ，而且是将自己 (child) 加进去了的。</p>
</li>
<li><p>执行 <code>[child willDealloc];</code> ，结合前边提到的 <code>willDealloc</code> 知道，这就去检测子类了。</p>
</li>
</ul>
<p>在这个类的最后，提供了一个交换方法的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)swizzleSEL:(SEL)originalSEL withSEL:(SEL)swizzledSEL &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _INTERNAL_MLF_ENABLED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _INTERNAL_MLF_RC_ENABLED</span></span><br><span class="line">    <span class="comment">// Just find a place to set up FBRetainCycleDetector.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [FBAssociationManager hook];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line"></span><br><span class="line">    Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSEL);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// YES if the method was added successfully, otherwise NO (for example, the class already contains a method implementation with that name).</span></span><br><span class="line">    <span class="type">BOOL</span> didAddMethod =</span><br><span class="line">    class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                    originalSEL,</span><br><span class="line">                    method_getImplementation(swizzledMethod),</span><br><span class="line">                    method_getTypeEncoding(swizzledMethod));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(<span class="keyword">class</span>,</span><br><span class="line">                            swizzledSEL,</span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交换方法代码就做介绍了，下边主要讲一下用到的两个宏：<code>_INTERNAL_MLF_ENABLED</code> 和<code>_INTERNAL_MLF_RC_ENABLED</code></p>
<h3 id="MLeaksFinder-h"><a href="#MLeaksFinder-h" class="headerlink" title="MLeaksFinder.h"></a>MLeaksFinder.h</h3><p>为了弄清楚上边提到的两个宏，我们来看看 <code>MLeaksFinder.h</code> 这个文件，分了两部分：</p>
<h4 id="INTERNAL-MLF-ENABLED"><a href="#INTERNAL-MLF-ENABLED" class="headerlink" title="_INTERNAL_MLF_ENABLED"></a>_INTERNAL_MLF_ENABLED</h4><p>下边的条件编译语句用于确定 <code>_INTERNAL_MLF_ENABLED</code> 的值，即决定是否需要开启内存泄漏的检测，默认是在 DEBUG 模式下检测，当然，也可以自己修改这个值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define MEMORY_LEAKS_FINDER_ENABLED 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MEMORY_LEAKS_FINDER_ENABLED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTERNAL_MLF_ENABLED MEMORY_LEAKS_FINDER_ENABLED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTERNAL_MLF_ENABLED DEBUG <span class="comment">// DEBUG 环境的话，_INTERNAL_MLF_ENABLED == 1</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="INTERNAL-MLF-RC-ENABLED"><a href="#INTERNAL-MLF-RC-ENABLED" class="headerlink" title="_INTERNAL_MLF_RC_ENABLED"></a>_INTERNAL_MLF_RC_ENABLED</h4><p>下边的条件编译语句用于确定 <code>_INTERNAL_MLF_RC_ENABLED</code> 的值，即决定是否需要开启循环引用的检测，默认是 如果项目中使用了 CocoaPods，则会通过 <code>FBRetainCycleDetector</code> 进行检测。实际使用 CocoaPods 导入 <code>MLeaksFinder</code> 的时候，会将 <code>FBRetainCycleDetector</code> 一并导入，对于后者的工作原理，会单独分一篇介绍的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define MEMORY_LEAKS_FINDER_RETAIN_CYCLE_ENABLED 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MEMORY_LEAKS_FINDER_RETAIN_CYCLE_ENABLED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTERNAL_MLF_RC_ENABLED MEMORY_LEAKS_FINDER_RETAIN_CYCLE_ENABLED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> COCOAPODS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INTERNAL_MLF_RC_ENABLED COCOAPODS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="MLeakedObjectProxy"><a href="#MLeakedObjectProxy" class="headerlink" title="MLeakedObjectProxy"></a>MLeakedObjectProxy</h3><p>现在解决一个遗留问题，就是前边 <code>-willDealloc</code> 方法中用到的 <code>MLeakedObjectProxy</code> 这个类，查看其 .h 文件发现，对外只提供了两个类方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>)isAnyObjectLeakedAtPtrs:(<span class="built_in">NSSet</span> *)ptrs;</span><br><span class="line">+ (<span class="type">void</span>)addLeakedObject:(<span class="type">id</span>)object;</span><br></pre></td></tr></table></figure>

<p>先看第一个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">BOOL</span>)isAnyObjectLeakedAtPtrs:(<span class="built_in">NSSet</span> *)ptrs &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="built_in">NSThread</span> isMainThread], <span class="string">@&quot;Must be in main thread.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.初始化 leakedObjectPtrs</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        leakedObjectPtrs = [[<span class="built_in">NSMutableSet</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptrs.count) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.检测 `leakedObjectPtrs` 与 `ptrs` 之间是否有交集</span></span><br><span class="line">    <span class="comment">// 当 leakedObjectPtrs 中 至少有一个对象也出现在 ptrs 中时，返回 YES。</span></span><br><span class="line">    <span class="keyword">if</span> ([leakedObjectPtrs intersectsSet:ptrs]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，首先初始化了 leakedObjectPtrs（为了保证唯一性，使用了单例），他是用来存储发生内泄的对象地址 (已经转成了数值，即 uintptr_t)。然后通过 <code>-intersectsSet:</code> 检测 <code>leakedObjectPtrs</code> 与 <code>ptrs</code> 之间是否有交集，即传入的 ptrs 中是否是泄露的对象。</p>
<p>下面看看第二个重要方法 <code>+ addLeakedObject:</code> ，它只要做了这么几件事：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)addLeakedObject:(<span class="type">id</span>)object &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="built_in">NSThread</span> isMainThread], <span class="string">@&quot;Must be in main thread.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    MLeakedObjectProxy *proxy = [[MLeakedObjectProxy alloc] init];</span><br><span class="line">    proxy.object = object;</span><br><span class="line">    proxy.objectPtr = @((uintptr_t)object);</span><br><span class="line">    proxy.viewStack = [object viewStack];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.给每一个 object 关联一个代理即proxy</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="type">void</span> *<span class="keyword">const</span> kLeakedObjectProxyKey = &amp;kLeakedObjectProxyKey;</span><br><span class="line">    objc_setAssociatedObject(object, kLeakedObjectProxyKey, proxy, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.存储 proxy.objectPtr 到集合 leakedObjectPtrs 里边</span></span><br><span class="line">    [leakedObjectPtrs addObject:proxy.objectPtr];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.弹框</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _INTERNAL_MLF_RC_ENABLED</span></span><br><span class="line">    [MLeaksMessenger alertWithTitle:<span class="string">@&quot;Memory Leak&quot;</span></span><br><span class="line">                            message:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, proxy.viewStack]</span><br><span class="line">                           delegate:proxy</span><br><span class="line">              additionalButtonTitle:<span class="string">@&quot;Retain Cycle&quot;</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    [MLeaksMessenger alertWithTitle:<span class="string">@&quot;Memory Leak&quot;</span></span><br><span class="line">                            message:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, proxy.viewStack]];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>给传入的泄漏对象 object 关联一个代理即 proxy</li>
<li>存储 proxy.objectPtr（实际是对象地址）到集合 leakedObjectPtrs 里边</li>
<li>弹框 AlertView：若 _INTERNAL_MLF_RC_ENABLED &#x3D;&#x3D; 1，则弹框会增加检测循环引用的选项；若 _INTERNAL_MLF_RC_ENABLED &#x3D;&#x3D; 0，则仅展示堆栈信息。</li>
</ul>
<p>当点击弹框中的检测循环引用按钮时，相关的操作都在下面 AlertView 的代理方法里边，即异步地通过 <code>FBRetainCycleDetector</code> 检测循环引用，然后回到主线程，利用弹框提示用户检测结果。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)alertView:(<span class="built_in">UIAlertView</span> *)alertView clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex &#123;</span><br><span class="line">    <span class="keyword">if</span> (!buttonIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">id</span> object = <span class="keyword">self</span>.object;</span><br><span class="line">    <span class="keyword">if</span> (!object) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _INTERNAL_MLF_RC_ENABLED</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        FBRetainCycleDetector *detector = [FBRetainCycleDetector new];</span><br><span class="line">        [detector addCandidate:<span class="keyword">self</span>.object];</span><br><span class="line">        <span class="built_in">NSSet</span> *retainCycles = [detector findRetainCyclesWithMaxCycleLength:<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">BOOL</span> hasFound = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSArray</span> *retainCycle <span class="keyword">in</span> retainCycles) &#123;</span><br><span class="line">            <span class="built_in">NSInteger</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (FBObjectiveCGraphElement *element <span class="keyword">in</span> retainCycle) &#123;</span><br><span class="line">                <span class="keyword">if</span> (element.object == object) &#123;</span><br><span class="line">                    <span class="built_in">NSArray</span> *shiftedRetainCycle = [<span class="keyword">self</span> shiftArray:retainCycle toIndex:index];</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        [MLeaksMessenger alertWithTitle:<span class="string">@&quot;Retain Cycle&quot;</span></span><br><span class="line">                                                message:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@&quot;</span>, shiftedRetainCycle]];</span><br><span class="line">                    &#125;);</span><br><span class="line">                    hasFound = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hasFound) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasFound) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [MLeaksMessenger alertWithTitle:<span class="string">@&quot;Retain Cycle&quot;</span></span><br><span class="line">                                        message:<span class="string">@&quot;Fail to find a retain cycle&quot;</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UIViewController-MemoryLeak"><a href="#UIViewController-MemoryLeak" class="headerlink" title="UIViewController+MemoryLeak"></a>UIViewController+MemoryLeak</h3><p>说了这么多，最后，以 UIViewController 为例，查看一下检测内泄的入口，即如何实现调用 <code>-willdeallloc</code> 方法，即如何开始构建内泄的堆栈信息的。</p>
<p>下面是 <code>+load</code> 方法，就是将几个系统方法和自定义方法交换，以便给系统方法增加新的操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> swizzleSEL:<span class="keyword">@selector</span>(viewDidDisappear:) withSEL:<span class="keyword">@selector</span>(swizzled_viewDidDisappear:)];</span><br><span class="line">        [<span class="keyword">self</span> swizzleSEL:<span class="keyword">@selector</span>(viewWillAppear:) withSEL:<span class="keyword">@selector</span>(swizzled_viewWillAppear:)];</span><br><span class="line">        [<span class="keyword">self</span> swizzleSEL:<span class="keyword">@selector</span>(dismissViewControllerAnimated:completion:) withSEL:<span class="keyword">@selector</span>(swizzled_dismissViewControllerAnimated:completion:)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们看看这三个自定义方法都做了些什么：</p>
<h4 id="void-swizzled-viewDidDisappear"><a href="#void-swizzled-viewDidDisappear" class="headerlink" title="- (void)swizzled_viewDidDisappear:"></a>- (void)swizzled_viewDidDisappear:</h4><p>先取出了 <code>kHasBeenPoppedKey</code> 对应的值，这个值是在右滑返回上个页面并触发 pop 时，设置为 YES 的，说明当前 ViewController 要销毁了，所以在这个时候调用了 <code>-willDealloc</code> 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)swizzled_viewDidDisappear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzled_viewDidDisappear:animated];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([objc_getAssociatedObject(<span class="keyword">self</span>, kHasBeenPoppedKey) boolValue]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willDealloc];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="void-swizzled-viewWillAppear"><a href="#void-swizzled-viewWillAppear" class="headerlink" title="- (void)swizzled_viewWillAppear:"></a>- (void)swizzled_viewWillAppear:</h4><p>与上边对应，这里是在当前 ViewController 的视图展示出来的时候，将 kHasBeenPoppedKey 关联的值设为 NO，即当前 ViewController 没有通过右滑返回。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)swizzled_viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzled_viewWillAppear:animated];</span><br><span class="line"></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, kHasBeenPoppedKey, @(<span class="literal">NO</span>), OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="swizzled-dismissViewControllerAnimated"><a href="#swizzled-dismissViewControllerAnimated" class="headerlink" title="- swizzled_dismissViewControllerAnimated:"></a>- swizzled_dismissViewControllerAnimated:</h4><p>前边两个方法是针对滑动返回做的处理，这里是针对通过 present 的对象 dismiss 时的操作，即如果当前 ViewController 没有 presentedViewController，就直接调用当前 ViewController 的 <code>-willDealloc</code> 方法检测内泄。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)swizzled_dismissViewControllerAnimated:(<span class="type">BOOL</span>)flag completion:(<span class="type">void</span> (^)(<span class="type">void</span>))completion &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzled_dismissViewControllerAnimated:flag completion:completion];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIViewController</span> *dismissedViewController = <span class="keyword">self</span>.presentedViewController;</span><br><span class="line">    <span class="keyword">if</span> (!dismissedViewController &amp;&amp; <span class="keyword">self</span>.presentingViewController) &#123;</span><br><span class="line">        dismissedViewController = <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dismissedViewController) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    [dismissedViewController willDealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后重写了 <code>-willDealloc</code> 方法，调用了 <code>-willReleaseChildren:</code> 方法，由于构建堆栈信息。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)willDealloc &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="variable language_">super</span> willDealloc]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// viewController</span></span><br><span class="line">    [<span class="keyword">self</span> willReleaseChildren:<span class="keyword">self</span>.childViewControllers];</span><br><span class="line">    [<span class="keyword">self</span> willReleaseChild:<span class="keyword">self</span>.presentedViewController];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// view</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isViewLoaded) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willReleaseChild:<span class="keyword">self</span>.view];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它 UI 相关类的内泄检测与 ViewController 类似，这里就不啰嗦了。</p>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h2><ul>
<li><a target="_blank" rel="noopener" href="http://wereadteam.github.io/2016/02/22/MLeaksFinder/">MLeaksFinder：精准 iOS 内存泄露检测工具</a></li>
<li><a target="_blank" rel="noopener" href="http://wereadteam.github.io/2016/07/20/MLeaksFinder2/">MLeaksFinder 新特性</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Tencent/MLeaksFinder/issues/16">MLeaksFinder-issue-16</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Tencent/MLeaksFinder/commit/3456267b982da42a5722242f4e740721e316d6c8">Fix wrong assertion when poping a VC by a button</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/04/10/MLeaksFinder-Source-Learning/" data-id="cl7c3a4v60000sjfy8rit0flz" data-title="MLeaksFinder 源码学习笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          iOS UITextView 实现类似微博的话题、提及功能
        
      </div>
    </a>
  
  
    <a href="/2019/03/17/AFNetWorking-Source-Learning-05/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">AFNetWorking 源码学习笔记 ☞ Reachability</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/24/ijkplayer-Compilation-and-Packaging/">ijkplayer 编译-打包-Pod支持</a>
          </li>
        
          <li>
            <a href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/">iOS UITextView 实现类似微博的话题、提及功能</a>
          </li>
        
          <li>
            <a href="/2019/04/10/MLeaksFinder-Source-Learning/">MLeaksFinder 源码学习笔记</a>
          </li>
        
          <li>
            <a href="/2019/03/17/AFNetWorking-Source-Learning-05/">AFNetWorking 源码学习笔记 ☞ Reachability</a>
          </li>
        
          <li>
            <a href="/2019/03/10/AFNetWorking-Source-Learning-04/">AFNetWorking 源码学习笔记 ☞ Serialization</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 He Hai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>