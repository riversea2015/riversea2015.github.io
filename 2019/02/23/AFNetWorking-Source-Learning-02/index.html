<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>AFNetWorking 源码学习笔记 ☞ NSURLSession | riversea2015</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、前言本文是 AFNetWorking 源码学习笔记的第二篇，从本篇开始每次介绍四个部分中的一个，按顺序先介绍第一部分 – NSURLSession 目录下的两个关键类 AFHTTPSessionManager 和 AFURLSessionManager。 注：标题容易让人误解，其实指的是 AFNetWorking 源码中的 NSURLSession 目录，而不是真的 NSURLSession">
<meta property="og:type" content="article">
<meta property="og:title" content="AFNetWorking 源码学习笔记 ☞ NSURLSession">
<meta property="og:url" content="https://devhe.com/2019/02/23/AFNetWorking-Source-Learning-02/index.html">
<meta property="og:site_name" content="riversea2015">
<meta property="og:description" content="一、前言本文是 AFNetWorking 源码学习笔记的第二篇，从本篇开始每次介绍四个部分中的一个，按顺序先介绍第一部分 – NSURLSession 目录下的两个关键类 AFHTTPSessionManager 和 AFURLSessionManager。 注：标题容易让人误解，其实指的是 AFNetWorking 源码中的 NSURLSession 目录，而不是真的 NSURLSession">
<meta property="og:locale">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2208988-6bf242f27828bbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2208988-8eac5a9ae89af994.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2208988-0501a7562633de99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2019-02-23T15:00:10.000Z">
<meta property="article:modified_time" content="2022-08-27T15:38:09.059Z">
<meta property="article:author" content="He Hai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2208988-6bf242f27828bbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternate" href="/atom.xml" title="riversea2015" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">riversea2015</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Stay Hungry, Stay Young.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://devhe.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-AFNetWorking-Source-Learning-02" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/02/23/AFNetWorking-Source-Learning-02/" class="article-date">
  <time class="dt-published" datetime="2019-02-23T15:00:10.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      AFNetWorking 源码学习笔记 ☞ NSURLSession
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-6bf242f27828bbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking 源码学习笔记.png"></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>本文是 AFNetWorking 源码学习笔记的第二篇，从本篇开始每次介绍四个部分中的一个，按顺序先介绍第一部分 – NSURLSession 目录下的两个关键类 AFHTTPSessionManager 和 AFURLSessionManager。</p>
<p>注：标题容易让人误解，其实指的是 AFNetWorking 源码中的 NSURLSession 目录，而不是真的 NSURLSession 这个类。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-8eac5a9ae89af994.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking-NSURLSession.png"></p>
<h3 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h3><p>我们从整个框架对外的最直接接口 AFHTTPSessionManager.h 文件开始查看，此文件主要分三部分：</p>
<h5 id="第一部分：4个基本属性："><a href="#第一部分：4个基本属性：" class="headerlink" title="第一部分：4个基本属性："></a>第一部分：4个基本属性：</h5><p>①baseURL：顾名思义，基础的 URL ，对于同一个 App，通常情况下，请求 url 的前半部分都是相同的，将这一部分赋值给 baseURL，发送请求时就可以使用相对路径了。<br>②requestSerializer：请求的序列化类，负责拼接参数，及对参数的编码。<br>③responseSerializer：负责对请求结果的处理，<br>④securityPolicy：安全策略类，负责对服务器证书的内部验证，即在 AFNetWorking 内部先进行一次验证。</p>
<h5 id="第二部分：创建及初始化方法"><a href="#第二部分：创建及初始化方法" class="headerlink" title="第二部分：创建及初始化方法"></a>第二部分：创建及初始化方法</h5><p>虽然提供了3种看似不同的创建及初始化方法(见下方代码)，实际上前两者只是对后者不同程度的封装，最终都是调用了最后一个参数最多的初始化方法。</p>
<p>AFHTTPSessionManager.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 并非单例，从方法名就可以看出来</span><br><span class="line">+ (instancetype)manager;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url</span><br><span class="line">           sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>AFHTTPSessionManager.m</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// *** 初始化 最终都调用的是这个方法</span><br><span class="line">- (instancetype)initWithBaseURL:(NSURL *)url</span><br><span class="line">           sessionConfiguration:(NSURLSessionConfiguration *)configuration</span><br><span class="line">&#123;</span><br><span class="line">    // 0.调用父类初始化方法</span><br><span class="line">    self = [super initWithSessionConfiguration:configuration];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1.调整 url, 确保 NSURL 的 +URLWithString:relativeToURL:  方法能够正常调用</span><br><span class="line">    if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:@&quot;&quot;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.初始化本类的属性</span><br><span class="line">    self.baseURL = url;</span><br><span class="line">    self.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步就是调用父类（AFURLSessionManager）的 initWithSessionConfiguration: 方法初始化，然后才是初始化自己的属性，点开父类方法看看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// *** init 子类初始化时会通过 super 调用😎</span><br><span class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化 configuration，如果为空，则使用默认，即 defaultSessionConfiguration，默认配置使用的是持久化的硬盘缓存，存储证书到用户 keychain，存储 cookie 到 shareCookie。</span><br><span class="line">    if (!configuration) &#123;</span><br><span class="line">        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    self.sessionConfiguration = configuration;</span><br><span class="line"></span><br><span class="line">    // 创建 delegate 所在的操作队列，因为 maxConcurrentOperationCount = 1，所以此处是串行队列，如果 &gt; 1，则为并发队列。</span><br><span class="line">    self.operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    self.operationQueue.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  初始化 session</span><br><span class="line">     *  用于后边创建各种 task，这里设置了 delegate、operationQueue 和 sessionConfiguration</span><br><span class="line">     *  注意1: 这个 delegate 是 readonly，只能通过初始化方法设置；</span><br><span class="line">     *  注意2: self.operationQueue 默认是串行队列；</span><br><span class="line">     *  注意3: self.sessionConfiguration 默认取 defaultSessionConfiguration。</span><br><span class="line">     */</span><br><span class="line">    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br><span class="line"></span><br><span class="line">    // 用于对接口返回结果的处理 - 下一篇详细说明</span><br><span class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    // 设置默认的安全策略类</span><br><span class="line">    self.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">    // 如果是 Apple Watch，则不需要初始化 reachabilityManager</span><br><span class="line">#if !TARGET_OS_WATCH</span><br><span class="line">    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // 存放 task.idenfier 与其 delegate 组成的键值对，用于将系统提供的代理方法转发给其 delegate</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];</span><br><span class="line"></span><br><span class="line">    // 初始化锁 🔐</span><br><span class="line">    self.lock = [[NSLock alloc] init];</span><br><span class="line">    self.lock.name = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  理论上，在初始化的时候，应该是还没有创建 task 的。</span><br><span class="line">     *</span><br><span class="line">     *  一个代码贡献者给出的解释是 I believe this for restoring a session from the background. 即 为从后台恢复一个 session 的情况准备的，将其代理的所有回调全都置为 nil。</span><br><span class="line">     *  详见：https://github.com/AFNetworking/AFNetworking/issues/3499</span><br><span class="line">     */</span><br><span class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</span><br><span class="line">        for (NSURLSessionDataTask *task in dataTasks) &#123;</span><br><span class="line">            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123;</span><br><span class="line">            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123;</span><br><span class="line">            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第三部分：核心-发送请求的方法"><a href="#第三部分：核心-发送请求的方法" class="headerlink" title="第三部分：核心 - 发送请求的方法"></a>第三部分：核心 - 发送请求的方法</h5><p>细数 AFHTTPSessionManager 中提供的一系列发送请求的方法，可以发现，其实主要可以分为两大类：一类是普通的 GET&#x2F;POST&#x2F;HEAD&#x2F;PUT&#x2F;PATCH&#x2F;DELETE 方法，另一类是包含复合结构 request 的 POST 请求方法。</p>
<h6 id="第一类方法"><a href="#第一类方法" class="headerlink" title="第一类方法"></a>第一类方法</h6><p>下面我们首先从第一类方法开始讨论，主要有以下几个方法，此处做了简化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSURLSessionDataTask *)GET: parameters: success: failure: DEPRECATED_ATTRIBUTE</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)GET: parameters: progress: success: failure:</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)HEAD: parameters: success: failure:</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)POST: parameters: success: failure: DEPRECATED_ATTRIBUTE</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)POST: parameters: progress: success: failure:</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)PUT: parameters: success: failure:</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)PATCH: parameters: success: failure:</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)DELETE: parameters: success: failure:</span><br></pre></td></tr></table></figure>

<p>这些方法的实现类似，都是调用了同一个方法创建 task，只不过传入的 method 不同而已，然后 resume 这个 task。如下边的这个 GET 方法所示，其他方法，只是将 GET 换成了对应 POST、HEAD 等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)GET:(NSString *)URLString</span><br><span class="line">                   parameters:(id)parameters</span><br><span class="line">                     progress:(void (^)(NSProgress * _Nonnull))downloadProgress</span><br><span class="line">                      success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success</span><br><span class="line">                      failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure</span><br><span class="line">&#123;</span><br><span class="line">    // 1.创建任务</span><br><span class="line">    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot;</span><br><span class="line">                                                        URLString:URLString</span><br><span class="line">                                                       parameters:parameters</span><br><span class="line">                                                   uploadProgress:nil</span><br><span class="line">                                                 downloadProgress:downloadProgress</span><br><span class="line">                                                          success:success</span><br><span class="line">                                                          failure:failure];</span><br><span class="line">    // 2.启动任务</span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个创建方法 dataTaskWithHTTPMethod: … 最终做了 2 件事：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// *** 构建 NSURLSessionDataTask</span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</span><br><span class="line">                                       URLString:(NSString *)URLString</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</span><br><span class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</span><br><span class="line">&#123;</span><br><span class="line">    // 1. 构建 NSMutableURLRequest，实际调用 requestSerializer 中创建 request 的方法</span><br><span class="line">    // 因为 NSURLRequest 的属性都是 readonly，所以此处构建了 NSMutableURLRequest。</span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method</span><br><span class="line">                                                                   URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString]</span><br><span class="line">                                                                  parameters:parameters</span><br><span class="line">                                                                       error:&amp;serializationError];</span><br><span class="line">    // 构建失败的处理</span><br><span class="line">    if (serializationError) &#123;</span><br><span class="line">        if (failure) &#123;</span><br><span class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(nil, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2. 构建 NSURLSessionDataTask：实际调用父类 AFURLSessionManager 的方法</span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    dataTask = [self dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</span><br><span class="line">                           if (error) &#123;</span><br><span class="line">                               if (failure) &#123;</span><br><span class="line">                                   failure(dataTask, error);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125; else &#123;</span><br><span class="line">                               if (success) &#123;</span><br><span class="line">                                   success(dataTask, responseObject);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;];</span><br><span class="line">    </span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.调用 AFHTTPRequestSerializer 的 requestWithMethod: URLString: parameters: error: 方法创建 mutableURLRequest；</p>
<p>2.利用 父类即 AFURLSessionManager 的 dataTaskWithRequest: uploadProgress: downloadProgress: completionHandler: 创建 task（需要上一步得到的 mutableURLRequest 做参数）。</p>
<p>AFHTTPRequestSerializer 中的方法主要做了一些拼接参数及编码的工作，留待<a href="">下一篇</a>介绍。这里来看看 AFURLSessionManager 中的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建Task(同时修复iOS8以下系统出现的Bug)</span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [self.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 2.为 task 添加代理</span><br><span class="line">[self addDelegateForDataTask:dataTask</span><br><span class="line">              uploadProgress:uploadProgressBlock</span><br><span class="line">            downloadProgress:downloadProgressBlock</span><br><span class="line">           completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也做了 2 件事，见上边注释，不过，创建 dataTask 的时候使用了一个 block，点开定义发现，当 iOS 系统版本  ＜ 8.0 时，创建了一个串行队列来执行 block 中的任务。</p>
<p>这是为了防止 iOS8 以前的版本在并发队列上创建任务时，可能会调用错误的 completionHandlers。当任务返回一个重复的 taskIdentifier 时，先前的 completionHandler 被清除并替换为新的。 如果第一个请求的数据在第二个请求的数据之前返回，那么将针对第二个 completionHandler 调用第一个响应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123;</span><br><span class="line">        // Fix of bug</span><br><span class="line">        // Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span><br><span class="line">        // Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span><br><span class="line">        dispatch_sync(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static dispatch_queue_t url_session_manager_processing_queue() &#123;</span><br><span class="line">    static dispatch_queue_t af_url_session_manager_processing_queue;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_processing_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.processing&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return af_url_session_manager_processing_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="第二类方法"><a href="#第二类方法" class="headerlink" title="第二类方法"></a>第二类方法</h6><p>第二类方法最终调用的只有一个方法，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)POST:(NSString *)URLString</span><br><span class="line">                    parameters:(id)parameters</span><br><span class="line">     constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                      progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress</span><br><span class="line">                       success:(void (^)(NSURLSessionDataTask *task, id responseObject))success</span><br><span class="line">                       failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    // 1.创建 request</span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@&quot;POST&quot; URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError];</span><br><span class="line">    if (serializationError) &#123;</span><br><span class="line">        if (failure) &#123;</span><br><span class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(nil, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.创建 task</span><br><span class="line">    __block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            if (failure) &#123;</span><br><span class="line">                failure(task, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                success(task, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3.启动任务</span><br><span class="line">    [task resume];</span><br><span class="line"></span><br><span class="line">    return task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本步骤与第一类方法类似，只不过创建 request 和 task 的方法不一样，对于 request 的创建方法留待<a href="">下一篇</a>介绍，这里我们看看创建 dataTask 的方法有什么不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request</span><br><span class="line">                                                 progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                                        completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block NSURLSessionUploadTask *uploadTask = nil;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        uploadTask = [self.session uploadTaskWithStreamedRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return uploadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来是其中创建 task 的方法 uploadTaskWithStreamedRequest: 不同，生成的是 NSURLSessionUploadTask 类型，之后设置代理的方法与第一类方法类似。</p>
<p>注意：其实理论上应该还有第 3 类请求方法，即下载的请求，不过 AFHTTPSessionManager 里边并未封装，而只是在它的父类里边提供了创建 downloadTask 的方法，比如下边的。也是创建 task 使用的系统方法不同，其他类似。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                                             progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                                          destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</span><br><span class="line">                                    completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block NSURLSessionDownloadTask *downloadTask = nil;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        downloadTask = [self.session downloadTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return downloadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在分别介绍完了 2 类发送请求的方法，下边我们看看为 task 添加代理的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class="line">    delegate.manager = self;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</span><br><span class="line">    // 保存 task 和 delegate 的映射关系，并添加对任务开始和暂停的监听</span><br><span class="line">    [self setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了一个代理对象（AFURLSessionManagerTaskDelegate），在这个 task 中对请求过程进行处理；设置完代理的属性之后，才调用 setDelegate: forTask: 方法来为 task 及代理添加关联。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(NSURLSessionTask *)task</span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line">    NSParameterAssert(delegate);</span><br><span class="line"></span><br><span class="line">    [self.lock lock];</span><br><span class="line">    // 以 taskIdentifier 为 key，将 delegate 存储在一个字典(self.mutableTaskDelegatesKeyedByTaskIdentifier)里</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    // 添加对任务开始和暂停的监听</span><br><span class="line">    [self addNotificationObserverForTask:task];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是保存 task 和 代理之间的映射关系，保存在之前已经创建好的字典 mutableTaskDelegatesKeyedByTaskIdentifier 里边，并为 task 添加通知，监听了 task resume 和 suspend 两个状态。然后我们发现当状态发生改变的时候，实际上只是在主队列又发送了 2 中通知，只是改了个名字而已。全局搜索新的通知名后发现，只有在 UIKit 那个目录下的类里边才会用到。</p>
<p>然后看看代理类 AFURLSessionManagerTaskDelegate，从他的初始化方法开始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 1.存放下载的数据</span><br><span class="line">    _mutableData = [NSMutableData data];</span><br><span class="line">    </span><br><span class="line">    //  2.创建并初始化上传及下载进度 _uploadProgress 和 _downloadProgress</span><br><span class="line">   _uploadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil];</span><br><span class="line">    _downloadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil];</span><br><span class="line">    </span><br><span class="line">    __weak __typeof__(task) weakTask = task;</span><br><span class="line">    for (NSProgress *progress in @[ _uploadProgress, _downloadProgress ])</span><br><span class="line">    &#123;</span><br><span class="line">        progress.totalUnitCount = NSURLSessionTransferSizeUnknown;</span><br><span class="line">        </span><br><span class="line">        progress.cancellable = YES; // 可以取消</span><br><span class="line">        progress.cancellationHandler = ^&#123;</span><br><span class="line">            [weakTask cancel];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        progress.pausable = YES; // 可以暂停</span><br><span class="line">        progress.pausingHandler = ^&#123;</span><br><span class="line">            [weakTask suspend];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        // 恢复</span><br><span class="line">#if AF_CAN_USE_AT_AVAILABLE</span><br><span class="line">        if (@available(iOS 9, macOS 10.11, *))</span><br><span class="line">#else</span><br><span class="line">        if ([progress respondsToSelector:@selector(setResumingHandler:)])</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            progress.resumingHandler = ^&#123;</span><br><span class="line">                [weakTask resume];</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 给 progress 添加监听</span><br><span class="line">        [progress addObserver:self</span><br><span class="line">                   forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</span><br><span class="line">                      options:NSKeyValueObservingOptionNew</span><br><span class="line">                      context:NULL];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上边的代码可以看到，就做了 2 件事：</p>
<ul>
<li>创建存放下载的数据的可变数组 _mutableData；</li>
<li>创建用于存储上传及下载进度的对象 _uploadProgress 和 _downloadProgress，并为其添加 KVO 监听。<br>查看了 KVO 对应的 <code>observeValueForKeyPath:</code> 方法实现后，发现只是将最新的下载或上传进度回传给了对应的 block。当然，会在 dealloc 方法中移除监听，否则会 Crash。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    </span><br><span class="line">   if ([object isEqual:self.downloadProgress]) &#123; // 下载进度</span><br><span class="line">        if (self.downloadProgressBlock) &#123;</span><br><span class="line">            self.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ([object isEqual:self.uploadProgress]) &#123; // 上传进度</span><br><span class="line">        if (self.uploadProgressBlock) &#123;</span><br><span class="line">            self.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是一些代理方法了，他们都是从 AFURLSessionManager 里边的代理方法转发过来的，后边再作介绍吧。</p>
<p>回到 AFURLSessionManager.m 中，前边都是在请求发送之前做的准备工作，现在我们来看看发起请求之后的情况，当然是看代理方法了。</p>
<h5 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h5><p>这里的 15 个代理方法分属 4 个不同的协议：<br><code>NSURLSessionDelegate</code><br><code>NSURLSessionTaskDelegate</code><br><code>NSURLSessionDataDelegate</code><br><code>NSURLSessionDownloadDelegate</code></p>
<p>我们依次看看其中实现的协议方法：</p>
<h5 id="NSURLSessionDelegate"><a href="#NSURLSessionDelegate" class="headerlink" title="NSURLSessionDelegate"></a>NSURLSessionDelegate</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 当 session 失效时调用</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didBecomeInvalidWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    if (self.sessionDidBecomeInvalid) &#123;</span><br><span class="line">        self.sessionDidBecomeInvalid(session, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何接受授权挑战，如果此方法未实现，会调用后边 NSURLSessionTaskDelegate 中的第一个代理方法 URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    //  1.判断有没有自定义 block: sessionDidReceiveAuthenticationChallenge</span><br><span class="line">    if (self.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        //  2.如果没有自定义 block，判断 如果服务端要求的认证方法是不是 NSURLAuthenticationMethodServerTrust</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            </span><br><span class="line">            //  3.基于客户端的安全策略来决定是否信任该服务器</span><br><span class="line">            // *** 点开此方法</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                </span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                </span><br><span class="line">                if (credential) &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengeUseCredential; // 使用证书的 Challenge</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling; // 默认 Challenge</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; // 取消 Challenge</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling; // 默认 Challenge</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // *** 去执行 iOS 系统的认证方案</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于第一个方法 <code>URLSession: didBecomeInvalidWithError: </code>，当 session 失效时调用此方法。官方文档给出的具体说明是，如果我们调用了  <code>finishTasksAndInvalidate</code> 方法，则会等到 session 里边最后一个 task 执行完，才会调用此代理方法；如果调用了 <code>invalidateAndCancel</code> 这个方法，则会立即执行该代理方法。</p>
<p>第 2 个代理方法是当客户端收到 “授权挑战”（姑且这么翻译吧，虽然很别扭） 时实行的方法，流程如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-0501a7562633de99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking认证挑战.png"></p>
<ul>
<li><p>首先，判断用户(使用者)有没有自定义 block: sessionDidReceiveAuthenticationChallenge，如果有，则执行自定义的 block 处理挑战，返回一个枚举值给 <code>disposition</code>，并给 <code>credential</code> 赋值 (因为参数是 &amp;credential) 处理，他们都将作为最后一步执行 completionhandler() 时的参数。如果没有自定义处理挑战的 block，则接着进行下一步的判断； </p>
</li>
<li><p>然后，判断服务端要求的认证方法是不是 NSURLAuthenticationMethodServerTrust。如果是，则只需要验证服务端证书是否安全（即 https 的单向认证，这是 AFNetworking 默认处理的认证方式，其他的认证方式，只能通过定义 block 来实现）。这种情况下，还需要做下一步处理；</p>
</li>
<li><p>接下来，有一个 if 判断，条件是 <code>securityPolicy</code> 调用 <code>evaluateServerTrust: forDomain:</code> 方法的执行结果，该方法实际是 AFNetWorking 自己对先做的一次 HTTPS 认证，返回结果表明该服务器是否可以信任，具体方法实现见<a href="">下一篇</a>。</p>
<ul>
<li>如果 if 条件成立，即 AFNetworking 认为服务器可信任，执行 <code>NSURLCredential</code> 的系统方法 <code>credentialForTrust:</code> 生成一个凭证或称证书 <code>credential</code>，如果成功生成，就给 <code>disposition</code> 赋相应的值。</li>
<li>如果 if 条件不成立，则取消认证。</li>
</ul>
</li>
<li><p>最后，执行 <code>completionHandler(disposition, credential)</code>，其中，<code>credential</code> 是根据服务端返回的证书及相关信息生成的用于客户端验证的对象；<code>disposition</code> 就是一个枚举值（常量），用于说明应该以何种方式处理凭证 <code>credential</code>。</p>
</li>
</ul>
<h5 id="NSURLSessionTaskDelegate"><a href="#NSURLSessionTaskDelegate" class="headerlink" title="NSURLSessionTaskDelegate"></a>NSURLSessionTaskDelegate</h5><p>这里以典型的请求结束的代理方法为例做一个简单介绍，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    // 取出 task 对应的 delegate</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    // 如果是在后台完成的任务，则此处 delegate 为 nil。</span><br><span class="line">    if (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line">        [self removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 执行 block</span><br><span class="line">    if (self.taskDidComplete) &#123;</span><br><span class="line">        self.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是在请求结束时执行的代理方法（可能成功或者失败，如果失败，error有值），调用自己的 <code>delegateForTask:</code> 方法，取出 task 对应的 delegate，如果取到了，则执行 delegate 的 <code>URLSession: task: didCompleteWithError:</code> 方法。</p>
<p>注意，实际我们最开始传到 GET、POST 等方法中的 block 都是赋值给了对应 task 的 delegate，所以真正执行那些 block 也是在转发到的 delegate(AFURLSessionManagerTaskDelegate) 的对应代理方法中，而不是上边代码最后的 block。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    __strong AFURLSessionManager *manager = self.manager;</span><br><span class="line"></span><br><span class="line">    __block id responseObject = nil;</span><br><span class="line"></span><br><span class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">    //Performance Improvement from #2672</span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    if (self.mutableData) &#123;</span><br><span class="line">        data = [self.mutableData copy];</span><br><span class="line">        //We no longer need the reference, so nil it out to gain back some memory.</span><br><span class="line">        self.mutableData = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</span><br><span class="line">    &#125; else if (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (error) &#123;    // 出错的时候</span><br><span class="line">        </span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">        // 出错时，执行完成的回调 及 发送任务结束的通知</span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">            if (self.completionHandler) &#123;</span><br><span class="line">                self.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;    // 正常结束的时候</span><br><span class="line">        </span><br><span class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            NSError *serializationError = nil;</span><br><span class="line">            </span><br><span class="line">            // *** 使用 responseSerializer 处理返回结果</span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            if (self.downloadFileURL) &#123;</span><br><span class="line">                responseObject = self.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 正常结束的时候，执行完成的回调 及 发送任务结束的通知</span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                </span><br><span class="line">                if (self.completionHandler) &#123;</span><br><span class="line">                    self.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细看了一下，这个方法里边就主要就为了做了  2 件事，第一件是执行 self.completionHandler()，包括请求结果的序列化将会在<a href="">下一篇</a>介绍；第二件是发送任务完成的通知，包括构建 userInfo 这个可变字典，详见代码。</p>
<p>至于其他协议及代理方法，大部分都是遵循将代理方法转发给 AFURLSessionManagerTaskDelegate 里的对应方法的逻辑，限于篇幅暂时就不做讨论了。</p>
<h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>忽然想起来，其实 AFNetWorking 的 readme.md 里边给的 4 个示例都是直接使用 AFURLSessionManager 而不是使用它的子类 AFHTTPSessionManager，难道我又说多了，哈哈。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://www.saitjr.com/ios/ios-ns_unavailable-ns_designated_initializer.html">NS_UNAVAILABLE 与 NS_DESIGNATED_INITIALIZER</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/239084afda5c">进度: NSProgress</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/02/23/AFNetWorking-Source-Learning-02/" data-id="cl7c2jebz0002lzfybyyu2y8y" data-title="AFNetWorking 源码学习笔记 ☞ NSURLSession" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/02/AFNetWorking-Source-Learning-03/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          AFNetWorking 源码学习笔记 ☞ Security
        
      </div>
    </a>
  
  
    <a href="/2019/02/17/AFNetWorking-Source-Learning-01/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">AFNetWorking 源码学习笔记 ☞ 主体流程</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/24/ijkplayer-Compilation-and-Packaging/">ijkplayer 编译-打包-Pod支持</a>
          </li>
        
          <li>
            <a href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/">iOS UITextView 实现类似微博的话题、提及功能</a>
          </li>
        
          <li>
            <a href="/2019/03/17/AFNetWorking-Source-Learning-05/">AFNetWorking 源码学习笔记 ☞ Reachability</a>
          </li>
        
          <li>
            <a href="/2019/03/10/AFNetWorking-Source-Learning-04/">AFNetWorking 源码学习笔记 ☞ Serialization</a>
          </li>
        
          <li>
            <a href="/2019/03/02/AFNetWorking-Source-Learning-03/">AFNetWorking 源码学习笔记 ☞ Security</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 He Hai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>