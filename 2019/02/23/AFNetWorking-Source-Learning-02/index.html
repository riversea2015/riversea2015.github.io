<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>AFNetWorking 源码学习笔记 ☞ NSURLSession | riversea2015</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="article">
<meta property="og:title" content="AFNetWorking 源码学习笔记 ☞ NSURLSession">
<meta property="og:url" content="https://devhe.com/2019/02/23/AFNetWorking-Source-Learning-02/index.html">
<meta property="og:site_name" content="riversea2015">
<meta property="og:locale">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a08da576d4e4d5ba2f93c517160fc85~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7c40e7ea5d84a0ba013e4f8b4f08e13~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e80abea104eb4724a835b824f5f40aed~tplv-k3u1fbpfcp-watermark.image">
<meta property="article:published_time" content="2019-02-23T15:00:10.000Z">
<meta property="article:modified_time" content="2022-08-28T06:46:00.491Z">
<meta property="article:author" content="He Hai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a08da576d4e4d5ba2f93c517160fc85~tplv-k3u1fbpfcp-watermark.image">
  
    <link rel="alternate" href="/atom.xml" title="riversea2015" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">riversea2015</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Stay Hungry, Stay Young.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://devhe.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-AFNetWorking-Source-Learning-02" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/02/23/AFNetWorking-Source-Learning-02/" class="article-date">
  <time class="dt-published" datetime="2019-02-23T15:00:10.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      AFNetWorking 源码学习笔记 ☞ NSURLSession
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a08da576d4e4d5ba2f93c517160fc85~tplv-k3u1fbpfcp-watermark.image" alt="AFNetWorking_cover.png"></p>
<span id="more"></span>

<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>本文是 AFNetWorking 源码学习笔记的第二篇，从本篇开始每次介绍四个部分中的一个，按顺序先介绍第一部分 – NSURLSession 目录下的两个关键类 AFHTTPSessionManager 和 AFURLSessionManager。</p>
<p>注：标题容易让人误解，其实指的是 AFNetWorking 源码中的 NSURLSession 目录，而不是真的 NSURLSession 这个类。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7c40e7ea5d84a0ba013e4f8b4f08e13~tplv-k3u1fbpfcp-watermark.image" alt="AFNetWorking-NSURLSession.png"></p>
<h3 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h3><p>我们从整个框架对外的最直接接口 AFHTTPSessionManager.h 文件开始查看，此文件主要分三部分：</p>
<h5 id="第一部分：4个基本属性："><a href="#第一部分：4个基本属性：" class="headerlink" title="第一部分：4个基本属性："></a>第一部分：4个基本属性：</h5><p>①baseURL：顾名思义，基础的 URL ，对于同一个 App，通常情况下，请求 url 的前半部分都是相同的，将这一部分赋值给 baseURL，发送请求时就可以使用相对路径了。<br>②requestSerializer：请求的序列化类，负责拼接参数，及对参数的编码。<br>③responseSerializer：负责对请求结果的处理，<br>④securityPolicy：安全策略类，负责对服务器证书的内部验证，即在 AFNetWorking 内部先进行一次验证。</p>
<h5 id="第二部分：创建及初始化方法"><a href="#第二部分：创建及初始化方法" class="headerlink" title="第二部分：创建及初始化方法"></a>第二部分：创建及初始化方法</h5><p>虽然提供了3种看似不同的创建及初始化方法(见下方代码)，实际上前两者只是对后者不同程度的封装，最终都是调用了最后一个参数最多的初始化方法。</p>
<p>AFHTTPSessionManager.h</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并非单例，从方法名就可以看出来</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)manager;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">           sessionConfiguration:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionConfiguration</span> *)configuration <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure>

<p>AFHTTPSessionManager.m</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *** 初始化 最终都调用的是这个方法</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">           sessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 0.调用父类初始化方法</span></span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> initWithSessionConfiguration:configuration];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.调整 url, 确保 NSURL 的 +URLWithString:relativeToURL:  方法能够正常调用</span></span><br><span class="line">    <span class="keyword">if</span> ([[url path] length] &gt; <span class="number">0</span> &amp;&amp; ![[url absoluteString] hasSuffix:<span class="string">@&quot;/&quot;</span>]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.初始化本类的属性</span></span><br><span class="line">    <span class="keyword">self</span>.baseURL = url;</span><br><span class="line">    <span class="keyword">self</span>.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步就是调用父类（AFURLSessionManager）的 initWithSessionConfiguration: 方法初始化，然后才是初始化自己的属性，点开父类方法看看。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *** init 子类初始化时会通过 super 调用😎</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 configuration，如果为空，则使用默认，即 defaultSessionConfiguration，默认配置使用的是持久化的硬盘缓存，存储证书到用户 keychain，存储 cookie 到 shareCookie。</span></span><br><span class="line">    <span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">        configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.sessionConfiguration = configuration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 delegate 所在的操作队列，因为 maxConcurrentOperationCount = 1，所以此处是串行队列，如果 &gt; 1，则为并发队列。</span></span><br><span class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  初始化 session</span></span><br><span class="line"><span class="comment">     *  用于后边创建各种 task，这里设置了 delegate、operationQueue 和 sessionConfiguration</span></span><br><span class="line"><span class="comment">     *  注意1: 这个 delegate 是 readonly，只能通过初始化方法设置；</span></span><br><span class="line"><span class="comment">     *  注意2: self.operationQueue 默认是串行队列；</span></span><br><span class="line"><span class="comment">     *  注意3: self.sessionConfiguration 默认取 defaultSessionConfiguration。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于对接口返回结果的处理 - 下一篇详细说明</span></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认的安全策略类</span></span><br><span class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是 Apple Watch，则不需要初始化 reachabilityManager</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !TARGET_OS_WATCH</span></span><br><span class="line">    <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放 task.idenfier 与其 delegate 组成的键值对，用于将系统提供的代理方法转发给其 delegate</span></span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化锁 🔐</span></span><br><span class="line">    <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.lock.name = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  理论上，在初始化的时候，应该是还没有创建 task 的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  一个代码贡献者给出的解释是 I believe this for restoring a session from the background. 即 为从后台恢复一个 session 的情况准备的，将其代理的所有回调全都置为 nil。</span></span><br><span class="line"><span class="comment">     *  详见：https://github.com/AFNetworking/AFNetworking/issues/3499</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDataTask</span> *task <span class="keyword">in</span> dataTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForDataTask:task uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionUploadTask</span> *uploadTask <span class="keyword">in</span> uploadTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDownloadTask</span> *downloadTask <span class="keyword">in</span> downloadTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:<span class="literal">nil</span> destination:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第三部分：核心-发送请求的方法"><a href="#第三部分：核心-发送请求的方法" class="headerlink" title="第三部分：核心 - 发送请求的方法"></a>第三部分：核心 - 发送请求的方法</h5><p>细数 AFHTTPSessionManager 中提供的一系列发送请求的方法，可以发现，其实主要可以分为两大类：一类是普通的 GET&#x2F;POST&#x2F;HEAD&#x2F;PUT&#x2F;PATCH&#x2F;DELETE 方法，另一类是包含复合结构 request 的 POST 请求方法。</p>
<h6 id="第一类方法"><a href="#第一类方法" class="headerlink" title="第一类方法"></a>第一类方法</h6><p>下面我们首先从第一类方法开始讨论，主要有以下几个方法，此处做了简化：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)GET: parameters: success: failure: DEPRECATED_ATTRIBUTE</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)GET: parameters: progress: success: failure:</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)HEAD: parameters: success: failure:</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)POST: parameters: success: failure: DEPRECATED_ATTRIBUTE</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)POST: parameters: progress: success: failure:</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)PUT: parameters: success: failure:</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)PATCH: parameters: success: failure:</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLSessionDataTask</span> *)DELETE: parameters: success: failure:</span><br></pre></td></tr></table></figure>

<p>这些方法的实现类似，都是调用了同一个方法创建 task，只不过传入的 method 不同而已，然后 resume 这个 task。如下边的这个 GET 方法所示，其他方法，只是将 GET 换成了对应 POST、HEAD 等等。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                   parameters:(<span class="type">id</span>)parameters</span><br><span class="line">                     progress:(<span class="type">void</span> (^)(<span class="built_in">NSProgress</span> * _Nonnull))downloadProgress</span><br><span class="line">                      success:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull, <span class="type">id</span> _Nullable))success</span><br><span class="line">                      failure:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable, <span class="built_in">NSError</span> * _Nonnull))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建任务</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@&quot;GET&quot;</span></span><br><span class="line">                                                        URLString:URLString</span><br><span class="line">                                                       parameters:parameters</span><br><span class="line">                                                   uploadProgress:<span class="literal">nil</span></span><br><span class="line">                                                 downloadProgress:downloadProgress</span><br><span class="line">                                                          success:success</span><br><span class="line">                                                          failure:failure];</span><br><span class="line">    <span class="comment">// 2.启动任务</span></span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个创建方法 dataTaskWithHTTPMethod: … 最终做了 2 件事：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *** 构建 NSURLSessionDataTask</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                      parameters:(<span class="type">id</span>)parameters</span><br><span class="line">                                  uploadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="type">id</span>))success</span><br><span class="line">                                         failure:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="built_in">NSError</span> *))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 构建 NSMutableURLRequest，实际调用 requestSerializer 中创建 request 的方法</span></span><br><span class="line">    <span class="comment">// 因为 NSURLRequest 的属性都是 readonly，所以此处构建了 NSMutableURLRequest。</span></span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="keyword">self</span>.requestSerializer requestWithMethod:method</span><br><span class="line">                                                                   URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString]</span><br><span class="line">                                                                  parameters:parameters</span><br><span class="line">                                                                       error:&amp;serializationError];</span><br><span class="line">    <span class="comment">// 构建失败的处理</span></span><br><span class="line">    <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(<span class="literal">nil</span>, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 构建 NSURLSessionDataTask：实际调用父类 AFURLSessionManager 的方法</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="type">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                                   failure(dataTask, error);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                                   success(dataTask, responseObject);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.调用 AFHTTPRequestSerializer 的 requestWithMethod: URLString: parameters: error: 方法创建 mutableURLRequest；</p>
<p>2.利用 父类即 AFURLSessionManager 的 dataTaskWithRequest: uploadProgress: downloadProgress: completionHandler: 创建 task（需要上一步得到的 mutableURLRequest 做参数）。</p>
<p>AFHTTPRequestSerializer 中的方法主要做了一些拼接参数及编码的工作，留待<a href="">下一篇</a>介绍。这里来看看 AFURLSessionManager 中的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="type">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建Task(同时修复iOS8以下系统出现的Bug)</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.为 task 添加代理</span></span><br><span class="line">[<span class="keyword">self</span> addDelegateForDataTask:dataTask</span><br><span class="line">              uploadProgress:uploadProgressBlock</span><br><span class="line">            downloadProgress:downloadProgressBlock</span><br><span class="line">           completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也做了 2 件事，见上边注释，不过，创建 dataTask 的时候使用了一个 block，点开定义发现，当 iOS 系统版本  ＜ 8.0 时，创建了一个串行队列来执行 block 中的任务。</p>
<p>这是为了防止 iOS8 以前的版本在并发队列上创建任务时，可能会调用错误的 completionHandlers。当任务返回一个重复的 taskIdentifier 时，先前的 completionHandler 被清除并替换为新的。 如果第一个请求的数据在第二个请求的数据之前返回，那么将针对第二个 completionHandler 调用第一个响应。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSFoundationVersionNumber</span> &lt; <span class="built_in">NSFoundationVersionNumber_With_Fixed_5871104061079552_bug</span>) &#123;</span><br><span class="line">        <span class="comment">// Fix of bug</span></span><br><span class="line">        <span class="comment">// Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span></span><br><span class="line">        <span class="comment">// Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_processing_queue() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_processing_queue;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_processing_queue = dispatch_queue_create(<span class="string">&quot;com.alamofire.networking.session.manager.processing&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> af_url_session_manager_processing_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="第二类方法"><a href="#第二类方法" class="headerlink" title="第二类方法"></a>第二类方法</h6><p>第二类方法最终调用的只有一个方法，如下所示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)POST:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                    parameters:(<span class="type">id</span>)parameters</span><br><span class="line">     constructingBodyWithBlock:(<span class="type">void</span> (^)(<span class="type">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                      progress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> * _Nonnull))uploadProgress</span><br><span class="line">                       success:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="type">id</span> responseObject))success</span><br><span class="line">                       failure:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.创建 request</span></span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="keyword">self</span>.requestSerializer multipartFormRequestWithMethod:<span class="string">@&quot;POST&quot;</span> URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError];</span><br><span class="line">    <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(<span class="literal">nil</span>, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建 task</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *task = [<span class="keyword">self</span> uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="type">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                failure(task, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                success(task, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.启动任务</span></span><br><span class="line">    [task resume];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本步骤与第一类方法类似，只不过创建 request 和 task 的方法不一样，对于 request 的创建方法留待<a href="">下一篇</a>介绍，这里我们看看创建 dataTask 的方法有什么不同。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithStreamedRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                                 progress:(<span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                                        completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="type">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionUploadTask</span> *uploadTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        uploadTask = [<span class="keyword">self</span>.session uploadTaskWithStreamedRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> uploadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来是其中创建 task 的方法 uploadTaskWithStreamedRequest: 不同，生成的是 NSURLSessionUploadTask 类型，之后设置代理的方法与第一类方法类似。</p>
<p>注意：其实理论上应该还有第 3 类请求方法，即下载的请求，不过 AFHTTPSessionManager 里边并未封装，而只是在它的父类里边提供了创建 downloadTask 的方法，比如下边的。也是创建 task 使用的系统方法不同，其他类似。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                             progress:(<span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                                          destination:(<span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">                                    completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        downloadTask = [<span class="keyword">self</span>.session downloadTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> downloadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在分别介绍完了 2 类发送请求的方法，下边我们看看为 task 添加代理的方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="type">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line">    <span class="comment">// 保存 task 和 delegate 的映射关系，并添加对任务开始和暂停的监听</span></span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了一个代理对象（AFURLSessionManagerTaskDelegate），在这个 task 中对请求过程进行处理；设置完代理的属性之后，才调用 setDelegate: forTask: 方法来为 task 及代理添加关联。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(delegate);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="comment">// 以 taskIdentifier 为 key，将 delegate 存储在一个字典(self.mutableTaskDelegatesKeyedByTaskIdentifier)里</span></span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    <span class="comment">// 添加对任务开始和暂停的监听</span></span><br><span class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是保存 task 和 代理之间的映射关系，保存在之前已经创建好的字典 mutableTaskDelegatesKeyedByTaskIdentifier 里边，并为 task 添加通知，监听了 task resume 和 suspend 两个状态。然后我们发现当状态发生改变的时候，实际上只是在主队列又发送了 2 中通知，只是改了个名字而已。全局搜索新的通知名后发现，只有在 UIKit 那个目录下的类里边才会用到。</p>
<p>然后看看代理类 AFURLSessionManagerTaskDelegate，从他的初始化方法开始。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.存放下载的数据</span></span><br><span class="line">    _mutableData = [<span class="built_in">NSMutableData</span> data];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  2.创建并初始化上传及下载进度 _uploadProgress 和 _downloadProgress</span></span><br><span class="line">   _uploadProgress = [[<span class="built_in">NSProgress</span> alloc] initWithParent:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    _downloadProgress = [[<span class="built_in">NSProgress</span> alloc] initWithParent:<span class="literal">nil</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> __typeof__(task) weakTask = task;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSProgress</span> *progress <span class="keyword">in</span> @[ _uploadProgress, _downloadProgress ])</span><br><span class="line">    &#123;</span><br><span class="line">        progress.totalUnitCount = <span class="built_in">NSURLSessionTransferSizeUnknown</span>;</span><br><span class="line">        </span><br><span class="line">        progress.cancellable = <span class="literal">YES</span>; <span class="comment">// 可以取消</span></span><br><span class="line">        progress.cancellationHandler = ^&#123;</span><br><span class="line">            [weakTask cancel];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        progress.pausable = <span class="literal">YES</span>; <span class="comment">// 可以暂停</span></span><br><span class="line">        progress.pausingHandler = ^&#123;</span><br><span class="line">            [weakTask suspend];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 恢复</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> AF_CAN_USE_AT_AVAILABLE</span></span><br><span class="line">        <span class="keyword">if</span> (@available(iOS <span class="number">9</span>, macOS <span class="number">10.11</span>, *))</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> ([progress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)])</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            progress.resumingHandler = ^&#123;</span><br><span class="line">                [weakTask resume];</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给 progress 添加监听</span></span><br><span class="line">        [progress addObserver:<span class="keyword">self</span></span><br><span class="line">                   forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                      options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                      context:<span class="literal">NULL</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上边的代码可以看到，就做了 2 件事：</p>
<ul>
<li>创建存放下载的数据的可变数组 _mutableData；</li>
<li>创建用于存储上传及下载进度的对象 _uploadProgress 和 _downloadProgress，并为其添加 KVO 监听。<br>查看了 KVO 对应的 <code>observeValueForKeyPath:</code> 方法实现后，发现只是将最新的下载或上传进度回传给了对应的 block。当然，会在 dealloc 方法中移除监听，否则会 Crash。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="type">id</span>&gt; *)change context:(<span class="type">void</span> *)context &#123;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.downloadProgress]) &#123; <span class="comment">// 下载进度</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.uploadProgress]) &#123; <span class="comment">// 上传进度</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.uploadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是一些代理方法了，他们都是从 AFURLSessionManager 里边的代理方法转发过来的，后边再作介绍吧。</p>
<p>回到 AFURLSessionManager.m 中，前边都是在请求发送之前做的准备工作，现在我们来看看发起请求之后的情况，当然是看代理方法了。</p>
<h5 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h5><p>这里的 15 个代理方法分属 4 个不同的协议：<br><code>NSURLSessionDelegate</code><br><code>NSURLSessionTaskDelegate</code><br><code>NSURLSessionDataDelegate</code><br><code>NSURLSessionDownloadDelegate</code></p>
<p>我们依次看看其中实现的协议方法：</p>
<h5 id="NSURLSessionDelegate"><a href="#NSURLSessionDelegate" class="headerlink" title="NSURLSessionDelegate"></a>NSURLSessionDelegate</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 session 失效时调用</span></span><br><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didBecomeInvalidWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidBecomeInvalid) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sessionDidBecomeInvalid(session, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何接受授权挑战，如果此方法未实现，会调用后边 NSURLSessionTaskDelegate 中的第一个代理方法 URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</span></span><br><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line"> completionHandler:(<span class="type">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  1.判断有没有自定义 block: sessionDidReceiveAuthenticationChallenge</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  2.如果没有自定义 block，判断 如果服务端要求的认证方法是不是 NSURLAuthenticationMethodServerTrust</span></span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//  3.基于客户端的安全策略来决定是否信任该服务器</span></span><br><span class="line">            <span class="comment">// *** 点开此方法</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                </span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (credential) &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>; <span class="comment">// 使用证书的 Challenge</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>; <span class="comment">// 默认 Challenge</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>; <span class="comment">// 取消 Challenge</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>; <span class="comment">// 默认 Challenge</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** 去执行 iOS 系统的认证方案</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于第一个方法 <code>URLSession: didBecomeInvalidWithError: </code>，当 session 失效时调用此方法。官方文档给出的具体说明是，如果我们调用了  <code>finishTasksAndInvalidate</code> 方法，则会等到 session 里边最后一个 task 执行完，才会调用此代理方法；如果调用了 <code>invalidateAndCancel</code> 这个方法，则会立即执行该代理方法。</p>
<p>第 2 个代理方法是当客户端收到 “授权挑战”（姑且这么翻译吧，虽然很别扭） 时实行的方法，流程如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e80abea104eb4724a835b824f5f40aed~tplv-k3u1fbpfcp-watermark.image" alt="AFNetWorking_Authentication_challenge.png"></p>
<ul>
<li><p>首先，判断用户(使用者)有没有自定义 block: sessionDidReceiveAuthenticationChallenge，如果有，则执行自定义的 block 处理挑战，返回一个枚举值给 <code>disposition</code>，并给 <code>credential</code> 赋值 (因为参数是 &amp;credential) 处理，他们都将作为最后一步执行 completionhandler() 时的参数。如果没有自定义处理挑战的 block，则接着进行下一步的判断； </p>
</li>
<li><p>然后，判断服务端要求的认证方法是不是 NSURLAuthenticationMethodServerTrust。如果是，则只需要验证服务端证书是否安全（即 https 的单向认证，这是 AFNetworking 默认处理的认证方式，其他的认证方式，只能通过定义 block 来实现）。这种情况下，还需要做下一步处理；</p>
</li>
<li><p>接下来，有一个 if 判断，条件是 <code>securityPolicy</code> 调用 <code>evaluateServerTrust: forDomain:</code> 方法的执行结果，该方法实际是 AFNetWorking 自己对先做的一次 HTTPS 认证，返回结果表明该服务器是否可以信任，具体方法实现见<a href="">下一篇</a>。</p>
<ul>
<li>如果 if 条件成立，即 AFNetworking 认为服务器可信任，执行 <code>NSURLCredential</code> 的系统方法 <code>credentialForTrust:</code> 生成一个凭证或称证书 <code>credential</code>，如果成功生成，就给 <code>disposition</code> 赋相应的值。</li>
<li>如果 if 条件不成立，则取消认证。</li>
</ul>
</li>
<li><p>最后，执行 <code>completionHandler(disposition, credential)</code>，其中，<code>credential</code> 是根据服务端返回的证书及相关信息生成的用于客户端验证的对象；<code>disposition</code> 就是一个枚举值（常量），用于说明应该以何种方式处理凭证 <code>credential</code>。</p>
</li>
</ul>
<h5 id="NSURLSessionTaskDelegate"><a href="#NSURLSessionTaskDelegate" class="headerlink" title="NSURLSessionTaskDelegate"></a>NSURLSessionTaskDelegate</h5><p>这里以典型的请求结束的代理方法为例做一个简单介绍，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出 task 对应的 delegate</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是在后台完成的任务，则此处 delegate 为 nil。</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line">        [<span class="keyword">self</span> removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidComplete) &#123;</span><br><span class="line">        <span class="keyword">self</span>.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是在请求结束时执行的代理方法（可能成功或者失败，如果失败，error有值），调用自己的 <code>delegateForTask:</code> 方法，取出 task 对应的 delegate，如果取到了，则执行 delegate 的 <code>URLSession: task: didCompleteWithError:</code> 方法。</p>
<p>注意，实际我们最开始传到 GET、POST 等方法中的 block 都是赋值给了对应 task 的 delegate，所以真正执行那些 block 也是在转发到的 delegate(AFURLSessionManagerTaskDelegate) 的对应代理方法中，而不是上边代码最后的 block。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    __<span class="keyword">strong</span> AFURLSessionManager *manager = <span class="keyword">self</span>.manager;</span><br><span class="line"></span><br><span class="line">    __block <span class="type">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSMutableDictionary</span> *userInfo = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Performance Improvement from #2672</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mutableData) &#123;</span><br><span class="line">        data = [<span class="keyword">self</span>.mutableData <span class="keyword">copy</span>];</span><br><span class="line">        <span class="comment">//We no longer need the reference, so nil it out to gain back some memory.</span></span><br><span class="line">        <span class="keyword">self</span>.mutableData = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;    <span class="comment">// 出错的时候</span></span><br><span class="line">        </span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出错时，执行完成的回调 及 发送任务结束的通知</span></span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                <span class="keyword">self</span>.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 正常结束的时候</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// *** 使用 responseSerializer 处理返回结果</span></span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">                responseObject = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常结束的时候，执行完成的回调 及 发送任务结束的通知</span></span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细看了一下，这个方法里边就主要就为了做了  2 件事，第一件是执行 <code>self.completionHandler()</code>，包括请求结果的序列化将会在<a href="">下一篇</a>介绍；第二件是发送任务完成的通知，包括构建 userInfo 这个可变字典，详见代码。</p>
<p>至于其他协议及代理方法，大部分都是遵循将代理方法转发给 <code>AFURLSessionManagerTaskDelegate</code> 里的对应方法的逻辑，限于篇幅暂时就不做讨论了。</p>
<h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>忽然想起来，其实 AFNetWorking 的 readme.md 里边给的 4 个示例都是直接使用 AFURLSessionManager 而不是使用它的子类 AFHTTPSessionManager，难道我又说多了，哈哈。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://www.saitjr.com/ios/ios-ns_unavailable-ns_designated_initializer.html">NS_UNAVAILABLE 与 NS_DESIGNATED_INITIALIZER</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/239084afda5c">进度: NSProgress</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/02/23/AFNetWorking-Source-Learning-02/" data-id="cl7c2jebz0002lzfybyyu2y8y" data-title="AFNetWorking 源码学习笔记 ☞ NSURLSession" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/02/AFNetWorking-Source-Learning-03/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          AFNetWorking 源码学习笔记 ☞ Security
        
      </div>
    </a>
  
  
    <a href="/2019/02/17/AFNetWorking-Source-Learning-01/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">AFNetWorking 源码学习笔记 ☞ 主体流程</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/24/ijkplayer-Compilation-and-Packaging/">ijkplayer 编译-打包-Pod支持</a>
          </li>
        
          <li>
            <a href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/">iOS UITextView 实现类似微博的话题、提及功能</a>
          </li>
        
          <li>
            <a href="/2019/04/10/MLeaksFinder-Source-Learning/">MLeaksFinder 源码学习笔记</a>
          </li>
        
          <li>
            <a href="/2019/03/17/AFNetWorking-Source-Learning-05/">AFNetWorking 源码学习笔记 ☞ Reachability</a>
          </li>
        
          <li>
            <a href="/2019/03/10/AFNetWorking-Source-Learning-04/">AFNetWorking 源码学习笔记 ☞ Serialization</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 He Hai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>