<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>riversea2015</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="iOSer">
<meta property="og:type" content="website">
<meta property="og:title" content="riversea2015">
<meta property="og:url" content="https://devhe.com/index.html">
<meta property="og:site_name" content="riversea2015">
<meta property="og:description" content="iOSer">
<meta property="og:locale">
<meta property="article:author" content="He Hai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="riversea2015" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">riversea2015</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Stay Hungry, Stay Young.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://devhe.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-ijkplayer-Compilation-and-Packaging" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/24/ijkplayer-Compilation-and-Packaging/" class="article-date">
  <time class="dt-published" datetime="2022-08-24T06:16:06.000Z" itemprop="datePublished">2022-08-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/24/ijkplayer-Compilation-and-Packaging/">ijkplayer 编译-打包-Pod支持</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://github.com/Bilibili/ijkplayer">ijkplayer</a> 是 <a target="_blank" rel="noopener" href="https://github.com/Bilibili">bilibili</a> 开源的一款优秀的视频播放器，基于 <code>ffplay</code>，支持 <code>iOS/Android</code>，点播&#x2F;直播，以及多种编解码方式。官方虽不提供现成的 framework，但大家可以根据需要自定义配置后，自己打包。本文仅对自己之前编译打包的过程做一简要记录。 </p>
        
          <p class="article-more-link">
            <a href="/2022/08/24/ijkplayer-Compilation-and-Packaging/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2022/08/24/ijkplayer-Compilation-and-Packaging/" data-id="cl77860q50000safyafsld3np" data-title="ijkplayer 编译-打包-Pod支持" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Topics-and-mentions-similar-to-Weibo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/" class="article-date">
  <time class="dt-published" datetime="2022-08-23T08:52:46.000Z" itemprop="datePublished">2022-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/">iOS UITextView 实现类似微博的话题、提及功能</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近接了一个需求，在发布动态的时候，增加类似微博的<code>#话题#</code>、<code>@提及用户</code>的效果，在此做一简要记录。</p>
        
          <p class="article-more-link">
            <a href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2022/08/23/Topics-and-mentions-similar-to-Weibo/" data-id="cl75yesom0000rbfyahqw9rlk" data-title="iOS UITextView 实现类似微博的话题、提及功能" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SDWebImage-Source-Learning-05" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/02/03/SDWebImage-Source-Learning-05/" class="article-date">
  <time class="dt-published" datetime="2019-02-03T11:39:30.000Z" itemprop="datePublished">2019-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/02/03/SDWebImage-Source-Learning-05/">SDWebImage 源码学习笔记 ☞ SDImageCache</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-29157f1c1fb6719f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage-源码学习笔记.png"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是本系列的第 5 篇，也是最后一篇，主要讨论处理缓存的类 <code>SDImageCache</code> 及相关类 <code>SDMemoryCache</code> 、<code>SDImageCacheConfig</code> 等。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>先介绍 SDImageCache.h 中定义的 2 个枚举：<code>SDImageCacheType</code> 和 <code>SDImageCacheOptions</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">    // 不缓存，从网络下载数据</span><br><span class="line">    SDImageCacheTypeNone,</span><br><span class="line">    // 磁盘缓存</span><br><span class="line">    SDImageCacheTypeDisk,</span><br><span class="line">    // 内存缓存</span><br><span class="line">    SDImageCacheTypeMemory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDImageCacheOptions) &#123;</span><br><span class="line">    // 即使内存中有缓存，也要强制查询磁盘缓存</span><br><span class="line">    SDImageCacheQueryDataWhenInMemory = 1 &lt;&lt; 0,</span><br><span class="line">    // 强制同步查询磁盘缓存</span><br><span class="line">    SDImageCacheQueryDiskSync = 1 &lt;&lt; 1,</span><br><span class="line">    // 压缩大图</span><br><span class="line">    SDImageCacheScaleDownLargeImages = 1 &lt;&lt; 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>包含几个重要属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/// *** 缓存配置信息 ***</span><br><span class="line">@property (nonatomic, nonnull, readonly) SDImageCacheConfig *config;</span><br><span class="line">/// 内存缓存的最大消耗</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCost;</span><br><span class="line">/// 内存缓存的最大缓存数量</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCountLimit;</span><br><span class="line"></span><br><span class="line">/// *** 内存缓存 ***</span><br><span class="line">@property (strong, nonatomic, nonnull) SDMemoryCache *memCache;</span><br><span class="line">/// 磁盘缓存路径</span><br><span class="line">@property (strong, nonatomic, nonnull) NSString *diskCachePath;</span><br><span class="line">/// </span><br><span class="line">@property (strong, nonatomic, nullable) NSMutableArray&lt;NSString *&gt; *customPaths;</span><br><span class="line">/// 读写操作的串行队列</span><br><span class="line">@property (strong, nonatomic, nullable) dispatch_queue_t ioQueue;</span><br><span class="line">/// 用于操作文件的 fileManager</span><br><span class="line">@property (strong, nonatomic, nonnull) NSFileManager *fileManager;</span><br></pre></td></tr></table></figure>

<p>其中 2 个属性需要重点关注一下：</p>
<p>① <code>config</code> 所属类 <code>SDImageCacheConfig</code> 定义了很短属性，只提供了一个init方法，在里边给所有属性付了初值，详见下方法代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</span><br><span class="line"></span><br><span class="line">@implementation SDImageCacheConfig</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        _shouldDisableiCloud = YES;</span><br><span class="line">        _shouldCacheImagesInMemory = YES;</span><br><span class="line">        _shouldUseWeakMemoryCache = YES;</span><br><span class="line">        _diskCacheReadingOptions = 0;</span><br><span class="line">        _diskCacheWritingOptions = NSDataWritingAtomic;</span><br><span class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</span><br><span class="line">        _maxCacheSize = 0;</span><br><span class="line">        _diskCacheExpireType = SDImageCacheConfigExpireTypeModificationDate;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>② <code>memCache</code> 它属于一个继承自 NSCache 的缓存类 <code>SDMemoryCache</code>， 他有一个关键属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// weakCache 是 NSMapTable 类型</span><br><span class="line">@property (nonatomic, strong, nonnull) NSMapTable&lt;KeyType, ObjectType&gt; *weakCache; </span><br></pre></td></tr></table></figure>

<p>下面观察一下 SDMemoryCache 的初始化及相关代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line"></span><br><span class="line">        self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</span><br><span class="line"></span><br><span class="line">        // 其他省略 ...</span><br><span class="line"></span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(didReceiveMemoryWarning:)</span><br><span class="line">                                                     name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning:(NSNotification *)notification &#123;</span><br><span class="line">    // 注意：此处是调用的 suoper 方法，所以并没有移除 weak cache，如果是调用 self 重写的 removeAllObjects 方法，就会移除 weak cache。</span><br><span class="line">    [super removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self</span><br><span class="line">                                                    name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                                  object:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当遇到内存警告的时候，缓存会被清除，但 weak cache 并不会被移除，如果手动清除的话，weak cache 当然会被移除。</p>
<p>这里 value 设置成 weak 可以避免可能的循环引用，虽然是 weak，不过，image 实例可以被其他对象持有，像 imageView，这种情况下，value 就不是 nil。</p>
<h6 id="似乎扯远了O-∩-∩-O哈哈-，好了，我们还是切回来继续讨论-SDImageCache-提供的方法吧！"><a href="#似乎扯远了O-∩-∩-O哈哈-，好了，我们还是切回来继续讨论-SDImageCache-提供的方法吧！" class="headerlink" title="似乎扯远了O(∩_∩)O哈哈~，好了，我们还是切回来继续讨论 SDImageCache 提供的方法吧！"></a>似乎扯远了O(∩_∩)O哈哈~，好了，我们还是切回来继续讨论 SDImageCache 提供的方法吧！</h6><p>首先，是 <code>SDImageCache</code> 的创建方法，它给我们提供了一个单例方法 <code>+ (nonnull instancetype)sharedImageCache</code>，下边是他的方法实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (nonnull instancetype)sharedImageCache &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，看看初始化方法，我们发现所有初始化方法最后均调用了同一个核心方法 <code>- (nonnull instancetype)initWithNamespace: diskCacheDirectory:</code>，具体作用见下方代码注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    return [self initWithNamespace:@&quot;default&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns &#123;</span><br><span class="line">    NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">    return [self initWithNamespace:ns diskCacheDirectory:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line">        </span><br><span class="line">        // 创建一个 IO 串行队列 (依次执行操作)</span><br><span class="line">        _ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        </span><br><span class="line">        // 初始化内存缓存</span><br><span class="line">        _config = [[SDImageCacheConfig alloc] init];</span><br><span class="line">        _memCache = [[SDMemoryCache alloc] initWithConfig:_config];</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line"></span><br><span class="line">        // 初始化磁盘缓存路径</span><br><span class="line">        if (directory != nil) &#123;</span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace]; </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_sync(_ioQueue, ^&#123;</span><br><span class="line">            self.fileManager = [NSFileManager new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">#if SD_UIKIT</span><br><span class="line">        // App 即将关闭的时候，清除过期缓存</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(deleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationWillTerminateNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">        // App 即将进入后台的时候，清除过期缓存</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(backgroundDeleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/221b335cc760">上一篇</a> 介绍 SDWebImageManager 的时候，是这样使用 imageCache 的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key</span><br><span class="line">                                                              options:cacheOptions</span><br><span class="line">                                                                 done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType)</span><br><span class="line">&#123;</span><br><span class="line">      // 查询完成后的操作在这里，可能查到了，也可能没查到 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们就来揭开这个方法的什么面纱。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key</span><br><span class="line">                                            options:(SDImageCacheOptions)options</span><br><span class="line">                                               done:(nullable SDCacheQueryCompletedBlock)doneBlock</span><br><span class="line">&#123;</span><br><span class="line">    // 1.校验参数</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(nil, nil, SDImageCacheTypeNone);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2.查询内存缓存 (NSCache)</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));</span><br><span class="line">    if (shouldQueryMemoryOnly) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(image, nil, SDImageCacheTypeMemory);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    </span><br><span class="line">    // 3.将获取缓存及解压的 ‘耗时’ 操作封装成一个 block</span><br><span class="line">    void(^queryDiskBlock)(void) =  ^&#123;</span><br><span class="line">        </span><br><span class="line">        // 如果已经取消，不作任何处理，直接返回。</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            </span><br><span class="line">            NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            UIImage *diskImage;</span><br><span class="line">            SDImageCacheType cacheType = SDImageCacheTypeDisk;</span><br><span class="line">            </span><br><span class="line">            if (image) &#123;</span><br><span class="line">                </span><br><span class="line">                // A &gt; 从 memery 取的</span><br><span class="line"></span><br><span class="line">                diskImage = image;</span><br><span class="line">                cacheType = SDImageCacheTypeMemory;</span><br><span class="line">                </span><br><span class="line">            &#125; else if (diskData) &#123;</span><br><span class="line">                </span><br><span class="line">                // B &gt; 如果内存没有，但是从 disc 取到了，需要解压</span><br><span class="line">                </span><br><span class="line">                diskImage = [self diskImageForKey:key data:diskData options:options];</span><br><span class="line">                </span><br><span class="line">                if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; // 缓存到内存</span><br><span class="line">                    NSUInteger cost = SDCacheCostForImage(diskImage); // 计算大小</span><br><span class="line">                    [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (doneBlock) &#123;</span><br><span class="line">                if (options &amp; SDImageCacheQueryDiskSync) &#123;  // 同步执行完成回调</span><br><span class="line">                    doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                &#125; else &#123;                                    // 异步执行完成回调</span><br><span class="line">                    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 4.执行查询磁盘缓存的 block</span><br><span class="line">    if (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">        queryDiskBlock();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, queryDiskBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上边的代码所示，主要分了这么 4 步：</p>
<p>① 校验参数 — 如果 key 不存在，直接 doneBlock，返回 nil。</p>
<p>② 查询内存缓存 NSCache — 如果内存中有，并且没有强制要求必须查询磁盘，则 执行 doneBlock，将 image 返回。</p>
<p>③ 将获取缓存及解压的 ‘耗时’ 操作封装成一个 block — 这是为了最后执行异步操作的方便。</p>
<p>④ 执行查询磁盘缓存的 block — 如果设置了 <code>SDImageCacheQueryDiskSync </code>，则同步执行；否则，默认是异步执行。</p>
<p>第 ③ 步中查询磁盘缓存的 <code>queryDiskBlock</code> 里边有两个比较重要的方法：<code>- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:</code> 和 <code>- (nullable UIImage *)diskImageForKey: data: options:</code>，下边分别了解一下这两个方法：</p>
<ul>
<li>diskImageDataBySearchingAllPathsForKey:  这个方法用于查询磁盘缓存，实现及代码注释如下，拼接缓存路径的方法就不展开了，其中文件名的生成是对传入的 key 执行了一次 MD5。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:(nullable NSString *)key &#123;</span><br><span class="line">    // 1.尝试 通过默认路径查询磁盘缓存</span><br><span class="line">    NSString *defaultPath = [self defaultCachePathForKey:key];</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfFile:defaultPath options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.异常情况的处理：更换了路径再取一次，新路径是将默认路径的后缀去掉 (如果有的话)</span><br><span class="line">    data = [NSData dataWithContentsOfFile:defaultPath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.遍历所有用户自定义的路径，执行类似 1、2 的操作，查询磁盘缓存</span><br><span class="line">    NSArray&lt;NSString *&gt; *customPaths = [self.customPaths copy];</span><br><span class="line">    for (NSString *path in customPaths) &#123;</span><br><span class="line">        NSString *filePath = [self cachePathForKey:key inPath:path];</span><br><span class="line">        NSData *imageData = [NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        imageData = [NSData dataWithContentsOfFile:filePath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 没查到的话，返回 nil</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>diskImageForKey: data: options: 此方法的作用是对从 Disc 直接取的 data，进行 解码、解压操作，实现代码如下。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key data:(nullable NSData *)data options:(SDImageCacheOptions)options &#123;</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        </span><br><span class="line">        // 1.解码</span><br><span class="line">        UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:data];</span><br><span class="line">        image = [self scaledImageForKey:key image:image];</span><br><span class="line">        </span><br><span class="line">        // 2.解压</span><br><span class="line">        if (self.config.shouldDecompressImages) &#123;</span><br><span class="line">            BOOL shouldScaleDown = options &amp; SDImageCacheScaleDownLargeImages;</span><br><span class="line">            </span><br><span class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;data options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return image;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法分别使用了 SDWebImageCodersManager 的 2 个重要方法：</p>
<ul>
<li>解码方法 <code>- (UIImage *)decodedImageWithData:data</code>，其中 coder 可以理解为一个解码器，<code>SDWebImage</code> 提供了多种 coder，如 <code>SDWebImageIOCoder</code>、<code>SDWebImageGIFCoder</code> 分别用于解码某一种类型的图片，如果新增一种图片，可以将对应的 coder（需遵守协议：SDWebImageCoder） 添加到 coders 里即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCodersManager.m</span><br><span class="line"></span><br><span class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</span><br><span class="line">    </span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">    </span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        if ([coder canDecodeFromData:data]) &#123;</span><br><span class="line">            return [coder decodedImageWithData:data];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解压方法 <code>- (UIImage *)decompressedImageWithImage:image data:data options:optionsDict</code>，这个方法和上边的解码方法都属于   <code>SDWebImageCoder</code> 这个协议，与解码方法类似，也是针对不同类型的 image 有不同的 coder。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCodersManager.m</span><br><span class="line"></span><br><span class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</span><br><span class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</span><br><span class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        if ([coder canDecodeFromData:*data]) &#123;</span><br><span class="line">            UIImage *decompressedImage = [coder decompressedImageWithImage:image data:data options:optionsDict];</span><br><span class="line">            decompressedImage.sd_imageFormat = image.sd_imageFormat;</span><br><span class="line">            return decompressedImage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，这些 coder 是什么时候加进去的，又是怎么添加的呢？其实，这些逻辑都在 SDWebImageCodersManager 的实现代码里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCodersManager.m</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        // 初始化 coders</span><br><span class="line">        NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [@[[SDWebImageImageIOCoder sharedCoder]] mutableCopy];</span><br><span class="line">#ifdef SD_WEBP</span><br><span class="line">        [mutableCoders addObject:[SDWebImageWebPCoder sharedCoder]];</span><br><span class="line">#endif</span><br><span class="line">        _coders = [mutableCoders copy];</span><br><span class="line">        _codersLock = dispatch_semaphore_create(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从初始化方法可以看出来，此时只给 coders 添加了一种 coder，即 SDWebImageImageIOCoder，它是用来对普通的 JPG、PNG 等图片解码的。</p>
<p>为了支持对其他类型图片（如 GIF）的解码，manager 给我们提供了下边这个添加 coder 的方法，代码逻辑很简单，就不多做解释了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCodersManager.m</span><br><span class="line"></span><br><span class="line">- (void)addCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder &#123;</span><br><span class="line">    if (![coder conformsToProtocol:@protocol(SDWebImageCoder)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [self.coders mutableCopy];</span><br><span class="line">    if (!mutableCoders) &#123;</span><br><span class="line">        mutableCoders = [NSMutableArray array];</span><br><span class="line">    &#125;</span><br><span class="line">    [mutableCoders addObject:coder];</span><br><span class="line">    self.coders = [mutableCoders copy];</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于缓存相关的类暂时就先介绍到这里，当然还有很多细节没来得及讨论，不过可以查看 demo 中的注释。</p>
<p>到此，关于 SDWebImage 的源码学习就告一段落了，目前的理解可能有点肤浅，以后随着理解的深入，会不定时的更新。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/02/03/SDWebImage-Source-Learning-05/" data-id="cl7c27fh00004jlfy87pn52xv" data-title="SDWebImage 源码学习笔记 ☞ SDImageCache" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SDWebImage-Source-Learning-04" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/26/SDWebImage-Source-Learning-04/" class="article-date">
  <time class="dt-published" datetime="2019-01-26T12:01:44.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/26/SDWebImage-Source-Learning-04/">SDWebImage 源码学习笔记 ☞ SDWebImageDownloader</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-29157f1c1fb6719f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage-源码学习笔记.png"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是本系列的第 4 篇，本篇将主要介绍 <code>SDWebImageDownloader</code> 这个负责下载的类，当然还有一些相关类及协议，如： <code>SDWebImageDownloadToken</code>、<code>SDWebImageDownloaderOperation</code> 和 <code>SDWebImageDownloaderOperationInterface</code> 等。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>开启正文描述之前，依旧先看 2 个重要的枚举：<code>SDWebImageDownloaderOptions</code> 和 <code>SDWebImageDownloaderExecutionOrder</code>，具体含义见下方代码注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 控制下载过程的选项</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) &#123;</span><br><span class="line">    // 降低下载任务在队列中的优先级</span><br><span class="line">    SDWebImageDownloaderLowPriority = 1 &lt;&lt; 0,</span><br><span class="line">    // 图片将在下载过程中逐步展示，而不是等下载完成后才一次性展示</span><br><span class="line">    SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1,</span><br><span class="line">    // 使用 NSURLCache，默认是不使用的</span><br><span class="line">    SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2,</span><br><span class="line">    // 如果图片是从 NSURLCache 读取的，那么执行 completionHandler 的时候，回传 nil</span><br><span class="line">    SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3,</span><br><span class="line">    // 后台继续执行任务</span><br><span class="line">    SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4,</span><br><span class="line">    // 允许处理存储在 NSHTTPCookieStore 中的 Cookie</span><br><span class="line">    SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5,</span><br><span class="line">    // 允许不受信任的 SSL 证书，生产环境慎用</span><br><span class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6,</span><br><span class="line">    // 提高下载任务在队列中的优先级</span><br><span class="line">    SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7,</span><br><span class="line">    // 缩放大图</span><br><span class="line">    SDWebImageDownloaderScaleDownLargeImages = 1 &lt;&lt; 8,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 任务的执行顺序</span><br><span class="line">typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) &#123;</span><br><span class="line">    // 先进先出，也是队列的默认执行顺序</span><br><span class="line">    SDWebImageDownloaderFIFOExecutionOrder,</span><br><span class="line">    // 后进先出，栈的执行顺序</span><br><span class="line">    SDWebImageDownloaderLIFOExecutionOrder</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来就到了 SDWebImageDownloader 这个类，我不准备一个属性一个方法地按顺序讨论，而是先说创建方法，然后通过一个主要方法将主体串起来。先看创建方法吧！</p>
<p>对外其实只公开了一个创建单例的方法 <code>sharedDownloader </code>，仔细查看代码会发现，最终调用的是 <code>- (nonnull instancetype)initWithSessionConfiguration:</code> 这个初始化方法，主要做一些初始化工作，并创建一个新 session。如果使用单例方法创建 downloader，则只会有一个 session，而如果通过其他方法创建，则可能创建 session 之前已经有一个了，这时候就需要先将之前的 cancel 之后再创建新的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">+ (nonnull instancetype)sharedDownloader &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    return [self initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        // 执行下载任务的 operation</span><br><span class="line">        _operationClass = [SDWebImageDownloaderOperation class];</span><br><span class="line">        // 要求解压图片</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        // 执行顺序，先进先出</span><br><span class="line">        _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;</span><br><span class="line">        </span><br><span class="line">        // 设置下载操作的队列，由于最大并发数是 6，所以此 queue 是 并发队列，如果是 1，则为串行队列。</span><br><span class="line">        _downloadQueue = [NSOperationQueue new];</span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = 6;</span><br><span class="line">        _downloadQueue.name = @&quot;com.hackemist.SDWebImageDownloader&quot;;</span><br><span class="line">        </span><br><span class="line">        _URLOperations = [NSMutableDictionary new];</span><br><span class="line">        </span><br><span class="line">        // 请求头的字段，可接受的文件类型</span><br><span class="line">#ifdef SD_WEBP</span><br><span class="line">        _HTTPHeaders = [@&#123;@&quot;Accept&quot;: @&quot;image/webp,image/*;q=0.8&quot;&#125; mutableCopy];</span><br><span class="line">#else</span><br><span class="line">        _HTTPHeaders = [@&#123;@&quot;Accept&quot;: @&quot;image/*;q=0.8&quot;&#125; mutableCopy];</span><br><span class="line">#endif</span><br><span class="line">        </span><br><span class="line">        // 锁，这里使用了信号量</span><br><span class="line">        _operationsLock = dispatch_semaphore_create(1);</span><br><span class="line">        _headersLock = dispatch_semaphore_create(1);</span><br><span class="line">        // 超时时间</span><br><span class="line">        _downloadTimeout = 15.0;</span><br><span class="line"></span><br><span class="line">        [self createNewSessionWithConfiguration:sessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建新的 session</span><br><span class="line">- (void)createNewSessionWithConfiguration:(NSURLSessionConfiguration *)sessionConfiguration &#123;</span><br><span class="line">    // 为避免影响，先取消可能存在的下载任务</span><br><span class="line">    [self cancelAllDownloads];</span><br><span class="line"></span><br><span class="line">    // cancel 之前的 session，然后创建一个新的</span><br><span class="line">    if (self.session) &#123;</span><br><span class="line">        [self.session invalidateAndCancel];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sessionConfiguration.timeoutIntervalForRequest = self.downloadTimeout;</span><br><span class="line"></span><br><span class="line">    self.session = [NSURLSession sessionWithConfiguration:sessionConfiguration</span><br><span class="line">                                                 delegate:self</span><br><span class="line">                                            delegateQueue:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们看一下主要方法 <code>- (nullable SDWebImageDownloadToken *)downloadImageWithURL:url options:options progress:progressBlock completed:completedBlock</code>。直接调用了添加进度与完成回调的方法，并将返回值作为结果返回。</p>
<p>添加进度与完成回调的方法我们稍后再议，先看一下调用时传入的 <code>createCallback </code>。就做了两件事：先创建一个 request，用于准备一些基础参数，然后，依据 request 创建 operation，详见代码注释 ☟。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    __weak SDWebImageDownloader *wself = self;</span><br><span class="line"></span><br><span class="line">    return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</span><br><span class="line">        </span><br><span class="line">        __strong __typeof (wself) sself = wself;</span><br><span class="line">        NSTimeInterval timeoutInterval = sself.downloadTimeout;</span><br><span class="line">        if (timeoutInterval == 0.0) &#123;</span><br><span class="line">            timeoutInterval = 15.0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// *** 1.创建 request</span><br><span class="line">        </span><br><span class="line">        // 为避免重复缓存 (NSURLCache + SDImageCache) ，如果没有明确要求使用 NSURLCache，我们默认忽略本地缓存</span><br><span class="line">        NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;</span><br><span class="line">        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url</span><br><span class="line">                                                                    cachePolicy:cachePolicy</span><br><span class="line">                                                                timeoutInterval:timeoutInterval];</span><br><span class="line">        // The default is YES - in other words, cookies are sent from and stored to the cookie manager by default.</span><br><span class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        request.HTTPShouldUsePipelining = YES;</span><br><span class="line">        </span><br><span class="line">        // 设置 header，headersFilter 是过滤头部参数的block</span><br><span class="line">        if (sself.headersFilter) &#123;</span><br><span class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            request.allHTTPHeaderFields = [sself allHTTPHeaderFields];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">// *** 2.创建下载的 operation (这个 operationClass ，给他赋什么值，他就是什么，如果不设置，就是默认值：[SDWebImageDownloaderOperation class])</span><br><span class="line">        </span><br><span class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request</span><br><span class="line">                                                                                       inSession:sself.session</span><br><span class="line">                                                                                         options:options];</span><br><span class="line">        </span><br><span class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</span><br><span class="line">        </span><br><span class="line">        // NSURLCredential 身份认证</span><br><span class="line">        if (sself.urlCredential) &#123;</span><br><span class="line">            operation.credential = sself.urlCredential;</span><br><span class="line">        &#125; else if (sself.username &amp;&amp; sself.password) &#123;</span><br><span class="line">            // NSURLCredentialPersistenceForSession: Credential should be stored only for this session.</span><br><span class="line">            operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 设置优先级</span><br><span class="line">        if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">        &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 更改执行顺序：先进后出(可在此设置) or 先进先出(默认)</span><br><span class="line">        if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">            // 通过反向设置依赖，指定了队列中任务的执行顺序先加进去的依赖于后加进去的，那就成了后进先出了😎</span><br><span class="line">            [sself.lastAddedOperation addDependency:operation];</span><br><span class="line">            sself.lastAddedOperation = operation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return operation;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们来看看添加进度与完成回调的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">                                                   forURL:(nullable NSURL *)url</span><br><span class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback &#123;</span><br><span class="line">    // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span><br><span class="line">    if (url == nil) &#123;</span><br><span class="line">        if (completedBlock != nil) &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LOCK(self.operationsLock);</span><br><span class="line">    </span><br><span class="line">    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</span><br><span class="line">    </span><br><span class="line">    // 如果是第 1 次进来，通过 url 是取不出 URLOperation 的，但是第 2 次就有可能找到，也就是想要重复发第 2 次请求的话，就可以取到。</span><br><span class="line">    // 第 2 次可以取到(并且已经完成的情况下)，则不会走括号里边，也就不会执行关键步骤：[self.downloadQueue addOperation:operation]; ，所以就不会发起请求了，因为将 operation 添加到队列的时候，系统会自动触发请求。</span><br><span class="line">    if (!operation || operation.isFinished) &#123;</span><br><span class="line">        // 创建 operation</span><br><span class="line">        operation = createCallback();</span><br><span class="line">        __weak typeof(self) wself = self;</span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line">            __strong typeof(wself) sself = wself;</span><br><span class="line">            if (!sself) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            LOCK(sself.operationsLock);</span><br><span class="line">            [sself.URLOperations removeObjectForKey:url];</span><br><span class="line">            UNLOCK(sself.operationsLock);</span><br><span class="line">        &#125;;</span><br><span class="line">        [self.URLOperations setObject:operation forKey:url];</span><br><span class="line">        </span><br><span class="line">        // 添加到队列，即开始执行！</span><br><span class="line">        // Add operation to operation queue only after all configuration done according to Apple&#x27;s doc.</span><br><span class="line">        // `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.</span><br><span class="line">        [self.downloadQueue addOperation:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UNLOCK(self.operationsLock);</span><br><span class="line"></span><br><span class="line">    // 存放进度和完成回调的 数组 array</span><br><span class="line">    id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">    </span><br><span class="line">    // 与下载任务关联的一个对象，用于取消操作的时候</span><br><span class="line">    SDWebImageDownloadToken *token = [SDWebImageDownloadToken new];</span><br><span class="line">    token.downloadOperation = operation;</span><br><span class="line">    token.url = url;</span><br><span class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</span><br><span class="line"></span><br><span class="line">    return token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了这么几件事：</p>
<ul>
<li><p>开始依然是参数校验</p>
</li>
<li><p>然后从 self.URLOperation 里边取 operation</p>
</li>
<li><p>第一次进来当然取不到 operation，于是就会进入 <code> if (!operation || operation.isFinished) &#123; ... &#125;</code> 的代码块。先执行我们传入的 <code>createCallback()</code> 创建 operation，然后将 operation 加入到 self.URLOperations 里边，同时设置好 operation 的 completionBlock，到时将 operation 移除，最后将 operation 加入到操作队列里，就会自动开始执行了。</p>
</li>
<li><p>创建一个 token，他是 <code>SDWebImageDownloadToken</code> 的实例，将它与 operation、url、progressBlock  及 completedBlock 关联起来，用于后边之后的取消操作。其中 progressBlock  及 completedBlock 是通过 downloadOperationCancelToken 与 token 关联起来的，这里用到了 operation 中的一个方法：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageDownloaderOperation</span><br><span class="line"></span><br><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    </span><br><span class="line">    SDCallbacksDictionary *callbacks = [NSMutableDictionary new];</span><br><span class="line">    </span><br><span class="line">    if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</span><br><span class="line">    </span><br><span class="line">    if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</span><br><span class="line">    </span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    </span><br><span class="line">    [self.callbackBlocks addObject:callbacks];</span><br><span class="line">    </span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    </span><br><span class="line">    return callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可知，这个 <code>id downloadOperationCancelToken</code> 是一个存放 progressBlock 和 completedBlock 的 dictionary。</p>
<p>这里 if 语句起到了一个非常重要的作用，即 避免重复下载相同数据，具体原因就不解释了，上边的代码注释里已经写了。</p>
<p>到这里是不是觉得少了点什么，是的，<code>SDWebImageDownloaderOperation</code> 和 <code>SDWebImageDownloadToken</code> 的具体实现还不知道呢，接下来我们就分别查看这 2 个类，先从简单的开始吧！</p>
<h5 id="SDWebImageDownloadToken"><a href="#SDWebImageDownloadToken" class="headerlink" title="SDWebImageDownloadToken"></a>SDWebImageDownloadToken</h5><p>这个类只有 3 个属性，前边都用到了，属性声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 下载任务对应的 url</span><br><span class="line">@property (nonatomic, strong, nullable) NSURL *url;</span><br><span class="line">// 实际是包含 progressBlock 和 completionBlock 的字典，是通过 `addHandlersForProgress:completed:` 返回的，用于取消操作</span><br><span class="line">@property (nonatomic, strong, nullable) id downloadOperationCancelToken;</span><br><span class="line">// 操作的 operation，继承自 NSOperation，不过又遵守了 `SDWebImageDownloaderOperationInterface` 这个协议，扩展了一些方法。</span><br><span class="line">@property (nonatomic, weak, nullable) NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *downloadOperation;</span><br></pre></td></tr></table></figure>

<p>它只实现了一个协议方法 <code>cancel</code>（Protocol: SDWebImageOperation），其中 <code>self.downloadOperationCancelToken</code>就是存放 progressBlock 和 completionBlock 的字典，然后将这个 token 创递给了 operation 的 <code>cancel:</code> 方法（也是一个协议方法），这个方法的具体实现下边就会说到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancel &#123;</span><br><span class="line">    if (self.downloadOperation) &#123;</span><br><span class="line">        SDWebImageDownloadToken *cancelToken = self.downloadOperationCancelToken;</span><br><span class="line">        if (cancelToken) &#123;</span><br><span class="line">            [self.downloadOperation cancel:cancelToken];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SDWebImageDownloaderOperationInterface"><a href="#SDWebImageDownloaderOperationInterface" class="headerlink" title="SDWebImageDownloaderOperationInterface"></a>SDWebImageDownloaderOperationInterface</h5><p>在开始介绍 operation 之前，先看看他遵守的协议 <code>SDWebImageDownloaderOperationInterface</code>，声明了以下协议方法。如果想要使用自定义的 operation，则它必须继承自 NSOperation 并且遵守这个协议。这些方法的实现可以参考 <code>SDWebImageDownloaderOperation </code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageDownloaderOperationInterface</span><br><span class="line">// 初始化方法</span><br><span class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</span><br><span class="line">                              inSession:(nullable NSURLSession *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options;</span><br><span class="line">// 保存进度和完成的回调</span><br><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line">// 是否需要解压图片</span><br><span class="line">- (BOOL)shouldDecompressImages;</span><br><span class="line">- (void)setShouldDecompressImages:(BOOL)value;</span><br><span class="line">// 凭证或称证书信息</span><br><span class="line">- (nullable NSURLCredential *)credential;</span><br><span class="line">- (void)setCredential:(nullable NSURLCredential *)value;</span><br><span class="line">// 取消</span><br><span class="line">- (BOOL)cancel:(nullable id)token;</span><br></pre></td></tr></table></figure>

<h5 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h5><p>现在开始讨论 <code>SDWebImageDownloaderOperation</code> 这个类，下边是初始化方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    return [self initWithRequest:nil inSession:nil options:0];</span><br><span class="line">&#125;</span><br><span class="line">// 也是协议方法</span><br><span class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</span><br><span class="line">                              inSession:(nullable NSURLSession *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _request = [request copy];</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        _options = options;</span><br><span class="line">        _callbackBlocks = [NSMutableArray new];</span><br><span class="line">        _executing = NO;</span><br><span class="line">        _finished = NO;</span><br><span class="line">        _expectedSize = 0;</span><br><span class="line">        _unownedSession = session;</span><br><span class="line">        _callbacksLock = dispatch_semaphore_create(1);</span><br><span class="line">        _coderQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageDownloaderOperationCoderQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面介绍 2 个比较重要的方法：</p>
<ul>
<li>核心方法 start</li>
</ul>
<p>这是重写父类 NSOperation 的 start 方法，添加了自定义的操作。这个方法不需要手动调用，在将 operation 添加到 operationQueue 中的时候，系统会自动调用其 start 方法。重写后的操作包括以下几点：</p>
<p>①检测操作是否已取消，如果取消了，重置数据后直接返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (self.isCancelled) &#123;</span><br><span class="line">    self.finished = YES;</span><br><span class="line">    [self reset];</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②如果需要 App 进入后台时，继续执行下载操作，需要开启后台任务。并设置 ExpirationHandler，取消下载任务，并结束后台操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 如果需要App进入后台时，继续执行此操作，需要开启后台任务。</span><br><span class="line">Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</span><br><span class="line">if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">    __weak __typeof__ (self) wself = self;</span><br><span class="line">    UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</span><br><span class="line">    self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        __strong __typeof (wself) sself = wself;</span><br><span class="line"></span><br><span class="line">        if (sself) &#123;</span><br><span class="line">            [sself cancel];</span><br><span class="line"></span><br><span class="line">            [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">            sself.backgroundTaskId = UIBackgroundTaskInvalid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③获取或创建 session，然后创建 dataTask，</p>
<p>④若 dataTask 创建成功，启动下载任务 <code> [self.dataTask resume];</code>，然后执行一次 progressBlock，并发送开始下载的通知。</p>
<p>④若 dataTask 创建失败，直接调用完成回调，构建 error 信息并返回，然后重置数据。</p>
<p>⑤关闭可能存在的后台下载任务。</p>
<p>具体下载过程中的操作，都在 session 相关的那些协议方法里边，详见代码注释，这里就不啰嗦了。</p>
<ul>
<li>取消操作</li>
</ul>
<p>最后看一下取消操作，即协议方法 <code>- (BOOL)cancel:(nullable id)token;</code> 的实现，将取消过程中用到的所有方法都展开就是下边这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)cancel:(nullable id)token &#123;</span><br><span class="line">    BOOL shouldCancel = NO;</span><br><span class="line">    </span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    </span><br><span class="line">    // 移除 token，即移除一个存储着 completionBlock 和 progressBlock 的字典</span><br><span class="line">    [self.callbackBlocks removeObjectIdenticalTo:token];</span><br><span class="line">    </span><br><span class="line">    // 如果已经没有回调，就去执行整体的 cancel 操作</span><br><span class="line">    if (self.callbackBlocks.count == 0) &#123;</span><br><span class="line">        shouldCancel = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    </span><br><span class="line">    if (shouldCancel) &#123;</span><br><span class="line">        // *** 点开 ☟</span><br><span class="line">        [self cancel];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return shouldCancel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        // *** 点开 ☟</span><br><span class="line">        [self cancelInternal];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cancelInternal &#123;</span><br><span class="line">    if (self.isFinished) return;</span><br><span class="line">    [super cancel];</span><br><span class="line"></span><br><span class="line">    if (self.dataTask) &#123;</span><br><span class="line">        // 取消下载任务，并发出停止的通知</span><br><span class="line">        [self.dataTask cancel];</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // As we cancelled the task, its callback won&#x27;t be called and thus won&#x27;t</span><br><span class="line">        // maintain the isFinished and isExecuting flags.</span><br><span class="line">        if (self.isExecuting) self.executing = NO;</span><br><span class="line">        if (!self.isFinished) self.finished = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    // *** 点开 ☟</span><br><span class="line">    [self reset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重置变量</span><br><span class="line">- (void)reset &#123;</span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    [self.callbackBlocks removeAllObjects];</span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    self.dataTask = nil;</span><br><span class="line">    </span><br><span class="line">    if (self.ownedSession) &#123;</span><br><span class="line">        [self.ownedSession invalidateAndCancel];</span><br><span class="line">        self.ownedSession = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>SDWebImageDownloader 的内容就先介绍到这类，其他细节见 <a target="_blank" rel="noopener" href="https://github.com/riversea2015/CodeForBlogs/tree/master/HHSDWebImageStudy">HHSDWebImageStudy</a> 中的源码注释。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/01/26/SDWebImage-Source-Learning-04/" data-id="cl7c27fgx0002jlfy9ochh1nh" data-title="SDWebImage 源码学习笔记 ☞ SDWebImageDownloader" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SDWebImage-Source-Learning-03" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/20/SDWebImage-Source-Learning-03/" class="article-date">
  <time class="dt-published" datetime="2019-01-20T10:19:06.000Z" itemprop="datePublished">2019-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/20/SDWebImage-Source-Learning-03/">SDWebImage 源码学习笔记 ☞ SDWebImageManager</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-29157f1c1fb6719f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage-源码学习笔记.png"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是本系列的第 3 篇，在前一篇中，我们了解了 SDWebImage 执行的基本流程，本篇就来介绍第一个核心类 <code>SDWebImageMananger</code>。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>SDWebImageMananger.h 文件基本可以分为 3 各部分：</p>
<p>①定义了一个枚举 <code>SDWebImageOptions </code>，列举了可能会用到的一些场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</span><br><span class="line">    // 重试已经失败的 url</span><br><span class="line">    SDWebImageRetryFailed = 1 &lt;&lt; 0,</span><br><span class="line">    // 低优先级，比如，在有 UI 交互的情况下，会延迟下载操作</span><br><span class="line">    SDWebImageLowPriority = 1 &lt;&lt; 1,</span><br><span class="line">    // 下载完成后，仅做内存缓存，不做磁盘缓存</span><br><span class="line">    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</span><br><span class="line">    // 下载过程中逐步加载图片，而不是完全下载完之后才展示</span><br><span class="line">    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</span><br><span class="line">    // 刷新缓存</span><br><span class="line">    SDWebImageRefreshCached = 1 &lt;&lt; 4,</span><br><span class="line">    // 当 App 进入后台时，继续下载任务，如果后台任务超时，操作将被自动取消</span><br><span class="line">    SDWebImageContinueInBackground = 1 &lt;&lt; 5,</span><br><span class="line">    // 允许处理 Cookie</span><br><span class="line">    SDWebImageHandleCookies = 1 &lt;&lt; 6,</span><br><span class="line">    // 允许不受信任的 SSL 证书，生产环境慎用</span><br><span class="line">    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</span><br><span class="line">    // 高优先级，即会把相应的图片放到最前边加载，而不是按照加入队列时的顺序执行</span><br><span class="line">    SDWebImageHighPriority = 1 &lt;&lt; 8,</span><br><span class="line">    // 延迟 placeholder 的加载，即在下载完成时才加载</span><br><span class="line">    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</span><br><span class="line">    // 对动图也执行 transform 操作</span><br><span class="line">    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</span><br><span class="line">    // 图片下载完成后，不直接自动给 imageView 赋值，给用户调整图片的机会</span><br><span class="line">    SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</span><br><span class="line">    // 依据设备内存缩放图片，如果设置了 `SDWebImageProgressiveDownload` ，此设置无效</span><br><span class="line">    SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12,</span><br><span class="line">    // 在有内存缓存的情况下，依然需要查询磁盘缓存，建议与 SDWebImageQueryDiskSync 配合使用</span><br><span class="line">    SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13,</span><br><span class="line">    // 同步查询磁盘缓存</span><br><span class="line">    SDWebImageQueryDiskSync = 1 &lt;&lt; 14,</span><br><span class="line">    // 仅加载缓存图片</span><br><span class="line">    SDWebImageFromCacheOnly = 1 &lt;&lt; 15,</span><br><span class="line">    // 对内存和磁盘中的 image 也执行 transition 的操作</span><br><span class="line">    SDWebImageForceTransition = 1 &lt;&lt; 16</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>②定义了一个协议 <code>SDWebImageManagerDelegate</code>，这里提供了以下 3 个协议方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 缓存中没有指定图片时，是否需要下载</span><br><span class="line">- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldDownloadImageForURL:(nullable NSURL *)imageURL;</span><br><span class="line"></span><br><span class="line">// 是否需要将制定 URL 标记为失败的 URL</span><br><span class="line">- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldBlockFailedURL:(nonnull NSURL *)imageURL withError:(nonnull NSError *)error;</span><br><span class="line"></span><br><span class="line">// 允许在刚刚下载到 image 并且未做缓存之前，对图片执行 transform，返回处理后的 image</span><br><span class="line">- (nullable UIImage *)imageManager:(nonnull SDWebImageManager *)imageManager transformDownloadedImage:(nullable UIImage *)image withURL:(nullable NSURL *)imageURL;</span><br></pre></td></tr></table></figure>

<p>③SDWebImageManager 的头文件，有几个重要属性，他们的作用见下边的注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 代理对象</span><br><span class="line">@property (weak, nonatomic, nullable) id &lt;SDWebImageManagerDelegate&gt; delegate;</span><br><span class="line">// 处理缓存的对象</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) SDImageCache *imageCache;</span><br><span class="line">// 处理下载工作的对象</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) SDWebImageDownloader *imageDownloader;</span><br><span class="line">// 一个用户定义的 block，用于生成 cacheKey</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</span><br><span class="line">// 一个用户定义的 block，用于序列化下载到的数据</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageCacheSerializerBlock cacheSerializer;</span><br></pre></td></tr></table></figure>

<p>下面是 2 个常用的创建方法：<code>+ (nonnull instancetype)sharedManager;</code> 和 <code>- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader;</code>，其实最终都是调用了后者 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 单例</span><br><span class="line">+ (nonnull instancetype)sharedManager &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化，创建处理缓存和下载任务的对象 cache 和 downloader</span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    SDImageCache *cache = [SDImageCache sharedImageCache];</span><br><span class="line">    SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</span><br><span class="line">    return [self initWithCache:cache downloader:downloader];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 核心的初始化方法，为各属性赋初值</span><br><span class="line">- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        // 处理缓存和下载任务的对象</span><br><span class="line">        _imageCache = cache;</span><br><span class="line">        _imageDownloader = downloader;</span><br><span class="line">        // 用于存储请求失败的 URL 的集合及操作时用的锁 (信号量)</span><br><span class="line">        _failedURLs = [NSMutableSet new];</span><br><span class="line">        _failedURLsLock = dispatch_semaphore_create(1);</span><br><span class="line">        // 存储运行中 operation 的集合，通过判断他的 count 是否为 0，判断操作是否在进行中：BOOL isRunning = (self.runningOperations.count &gt; 0);</span><br><span class="line">        _runningOperations = [NSMutableSet new];</span><br><span class="line">        // 操作时用的锁 (信号量)</span><br><span class="line">        _runningOperationsLock = dispatch_semaphore_create(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外几个方法，就不单独介绍了，用到的时候再继续讨论。此处，我们只看一个核心方法 <code>- (nullable id &lt;SDWebImageOperation&gt;)loadImageWithURL:url options:options progress:progressBlock completed:completedBlock;</code>，下面我们来一步步讨论这个方法的具体实现。</p>
<h5 id="1-校验参数"><a href="#1-校验参数" class="headerlink" title="1.校验参数"></a>1.校验参数</h5><p>依次做如下处理：如果传入的 completedBlock 为空，就直接报错；如果传入的参数是 NSString * 类型的，需要将其转换成 NSURL；最后，如果 url 还不是 NSURL 类型，那就只能将其置为 nil，以免造成后边 Crash。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line"></span><br><span class="line">if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">    url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">    url = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-生成总的-operation"><a href="#2-生成总的-operation" class="headerlink" title="2.生成总的 operation"></a>2.生成总的 operation</h5><p>他是 <code>SDWebImageCombinedOperation</code> 实例对象，也是当前方法要返回的结果，并将当前类赋值给 operation 的一个 weak 属性(避免循环引用)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">operation.manager = self; // 肯定是 weak 属性</span><br></pre></td></tr></table></figure>

<p><code>SDWebImageCombinedOperation</code> 的声明与实现文件均在当前类 <code>SDWebImageManager</code> 的实现文件里边，简单看一下他的 .h&#x2F;.m 文件吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCombinedOperation.h</span><br><span class="line">@interface SDWebImageCombinedOperation : NSObject &lt;SDWebImageOperation&gt;</span><br><span class="line">// 标识是否已取消</span><br><span class="line">@property (assign, nonatomic, getter = isCanceled) BOOL cancelled;</span><br><span class="line">// downloadToken 这是一个继承自 NSObject 的类，他有一个继承自 NSOperation 的属性，也就是真正执行下载操作时的 operation，cancel 时会用到</span><br><span class="line">@property (strong, nonatomic, nullable) SDWebImageDownloadToken *downloadToken;</span><br><span class="line">// 查询缓存时的 operation，用于标识当前 operation 是否已经被取消。其实查询缓存时，首先查看 operation.isCanceled，如果没被取消了，就会再去查询了。cancel 时会将其 isCanceled 属性置为 YES。</span><br><span class="line">@property (strong, nonatomic, nullable) NSOperation *cacheOperation;</span><br><span class="line">// manager</span><br><span class="line">@property (weak, nonatomic, nullable) SDWebImageManager *manager;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// SDWebImageCombinedOperation.m</span><br><span class="line">#pragma mark - 代理方法实现</span><br><span class="line"></span><br><span class="line">@implementation SDWebImageCombinedOperation</span><br><span class="line"></span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        self.cancelled = YES;</span><br><span class="line">        // 取消查询缓存的 Operation，此时 isCanceled 会被置为 YES。</span><br><span class="line">        if (self.cacheOperation) &#123;</span><br><span class="line">            [self.cacheOperation cancel];</span><br><span class="line">            self.cacheOperation = nil;</span><br><span class="line">        &#125;</span><br><span class="line">        // 取消下载操作</span><br><span class="line">        if (self.downloadToken) &#123;</span><br><span class="line">            [self.manager.imageDownloader cancel:self.downloadToken];</span><br><span class="line">        &#125;</span><br><span class="line">        // 将当前 operation 从 manager 中运行着的 operation 数组中移除。</span><br><span class="line">        [self.manager safelyRemoveOperationFromRunning:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  SDWebImageOperation 协议的定义</span><br><span class="line">@protocol SDWebImageOperation &lt;NSObject&gt;</span><br><span class="line">- (void)cancel;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>SDWebImageCombinedOperation</code> 这个类的主要作用就是 cancel 操作，包括 cancel 查询缓存 和 cancel 下载数据。</p>
<h5 id="3-再次检测一下-url"><a href="#3-再次检测一下-url" class="headerlink" title="3.再次检测一下 url"></a>3.再次检测一下 url</h5><p>如果是曾经失败的 url，而且不允许重试，或者 url 为空时，执行 completionBlock，并返回当前 operation。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// self.failedURLs 是一个保存曾经失败过的 URL 的数组，用于检测当前 URL 是不是曾经请求失败过的URL.另外，搜索一个个元素的时候，NSSet 比 NSArray 查询更快。</span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        LOCK(self.failedURLsLock);</span><br><span class="line">        isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">        UNLOCK(self.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 若出现以下两种情况就不再往下走了，直接执行 CompletionBlock：① URL 是空的；② 此 URL 是曾经请求失败的 URL，并且规定不允许重新请求曾经失败的 URL。</span><br><span class="line">    if (url.absoluteString.length == 0</span><br><span class="line">        || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl))</span><br><span class="line">    &#123;</span><br><span class="line">        [self callCompletionBlockForOperation:operation</span><br><span class="line">                                   completion:completedBlock</span><br><span class="line">                                        error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil]</span><br><span class="line">                                          url:url];</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-保存-operation-至-self-runningOperations"><a href="#4-保存-operation-至-self-runningOperations" class="headerlink" title="4.保存 operation 至 self.runningOperations"></a>4.保存 <code>operation</code> 至 <code>self.runningOperations</code></h5><p>后者是一个数组，这里使用了信号量来确保线程安装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCK(self.runningOperationsLock);</span><br><span class="line">[self.runningOperations addObject:operation];</span><br><span class="line">UNLOCK(self.runningOperationsLock);</span><br></pre></td></tr></table></figure>

<h5 id="5-查询缓存。"><a href="#5-查询缓存。" class="headerlink" title="5.查询缓存。"></a>5.查询缓存。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSString *key = [self cacheKeyForURL:url];</span><br><span class="line"></span><br><span class="line">SDImageCacheOptions cacheOptions = 0;</span><br><span class="line">if (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;</span><br><span class="line">if (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;</span><br><span class="line">if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;</span><br><span class="line"></span><br><span class="line">__weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line"></span><br><span class="line">operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key</span><br><span class="line">                                                              options:cacheOptions</span><br><span class="line">                                                                 done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType)</span><br><span class="line">&#123;</span><br><span class="line">    // 查询完成后的操作在这里，可能查到了，也可能没查到...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先准备了 2 个参数，查询的依据 key 和一些条件 cacheOptions。key 的获取是通过一个私有方法 (如下)，如果自定义了 <code>key</code> 的生成规则 self.cacheKeyFilter，就用自定义的，如果没有，就直接取 url.absoluteString。<code>cacheOptions</code> 是一个用 NS_OPTIONS 定义的枚举类型 (前边已介绍过)，可组合多种情况，在这里综合了 2 个查询的要求和 1 个缩放图片的要求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)cacheKeyForURL:(nullable NSURL *)url &#123;</span><br><span class="line">    if (!url) &#123;</span><br><span class="line">        return @&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.cacheKeyFilter) &#123;</span><br><span class="line">        return self.cacheKeyFilter(url);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return url.absoluteString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-查询的具体过程"><a href="#6-查询的具体过程" class="headerlink" title="6.查询的具体过程"></a>6.查询的具体过程</h5><p>详情将会在 <a href="">SDImageCache</a> 中介绍，下面讨论一下查询缓存结束后的操作。</p>
<h5 id="7-移除当前-operation"><a href="#7-移除当前-operation" class="headerlink" title="7.移除当前 operation"></a>7.移除当前 operation</h5><p>从 self.runningOperations 这个数组中移除当前 operation。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">    [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="8-判断是否需要下载"><a href="#8-判断是否需要下载" class="headerlink" title="8.判断是否需要下载"></a>8.判断是否需要下载</h5><p>当同时满足 3 个要求时，就需要下载新数据了：<br>①没要求只能从缓存获取数据，即当缓存找不到时，可以去下载；<br>②找不到缓存 或 要求必须更新缓存；<br>③当 self.delegate 没有遵守协议， 或者 协议方法返回 YES。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly)) </span><br><span class="line">        &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached) </span><br><span class="line">        &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]);</span><br></pre></td></tr></table></figure>

<h5 id="9-若需要下载"><a href="#9-若需要下载" class="headerlink" title="9.若需要下载"></a>9.若需要下载</h5><ul>
<li>首先依然要做一个判断，即 如果有缓存数据并且要求刷新缓存数据时，需要先调用一次 CompletionBlock，将缓存数据返回去，然后再开始下载新数据，代码如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">    [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，准备下载数据时所需的一些基本选项，可以参考篇头介绍的枚举 <code>SDWebImageOptions</code>。</p>
<ul>
<li>开始下载，调用了 SDWebImageDownloader 的下载方法，留待 <a href="">SDWebImageDownloader</a> 介绍，这里只讨论下载完成之后的操作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(strongOperation) weakSubOperation = strongOperation;</span><br><span class="line">            strongOperation.downloadToken = [self.imageDownloader downloadImageWithURL:url</span><br><span class="line">                                                                               options:downloaderOptions</span><br><span class="line">                                                                              progress:progressBlock</span><br><span class="line">                                                                             completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished)</span><br><span class="line">&#123;</span><br><span class="line">        // 下载完成后的操作...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下载完成后，可以分这么几种情况：<br>a.当前 operation 已经被取消，这种情况下不作任何操作，包括回调。</p>
<p>b.下载出错，先将失败的 error 信息返回，然后决定是否需要将当前 URL 存入失败的 URL 数组。</p>
<p>c.下载成功，此时要做的工作还有许多：</p>
<p> ①如果设置了失败重发，则将当前 URL 从失败的 URL 数组中移除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">    LOCK(self.failedURLsLock);</span><br><span class="line">    [self.failedURLs removeObject:url];</span><br><span class="line">    UNLOCK(self.failedURLsLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②对于自定义的 manager，需要执行另外一套缩放标准。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (self != [SDWebImageManager sharedManager]</span><br><span class="line">                        &amp;&amp; self.cacheKeyFilter</span><br><span class="line">                        &amp;&amp; downloadedImage)</span><br><span class="line">&#123;</span><br><span class="line">    downloadedImage = [self scaledImageForKey:key image:downloadedImage];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③若需要更新缓存，但是未下载到图片，且缓存中本来有值的情况下，什么也不做，因为下载之前早已经缓存数据返回了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">// 需要更新缓存，但是未下载到图片，且缓存中本来有值的情况下，什么也不做，因为下载之前早已经缓存数据返回了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④如果下载到了图片，并且要求 transform 图片的情况下，异步执行 transform 和缓存图片的工作，然后回到主线程执行 completionBlock。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        </span><br><span class="line">        UIImage *transformedImage = [self.delegate imageManager:self</span><br><span class="line">                                       transformDownloadedImage:downloadedImage</span><br><span class="line">                                                        withURL:url];</span><br><span class="line">        </span><br><span class="line">        if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">            </span><br><span class="line">            BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">            NSData *cacheData;</span><br><span class="line">            // pass nil if the image was transformed, so we can recalculate the data from the image</span><br><span class="line">            if (self.cacheSerializer) &#123;</span><br><span class="line">                cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cacheData = (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // *** 存盘：注意是存的 imageData</span><br><span class="line">            [self.imageCache storeImage:transformedImage</span><br><span class="line">                              imageData:cacheData</span><br><span class="line">                                 forKey:key</span><br><span class="line">                                 toDisk:cacheOnDisk</span><br><span class="line">                             completion:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [self callCompletionBlockForOperation:strongSubOperation</span><br><span class="line">                                   completion:completedBlock</span><br><span class="line">                                        image:transformedImage</span><br><span class="line">                                         data:downloadedData</span><br><span class="line">                                        error:nil</span><br><span class="line">                                    cacheType:SDImageCacheTypeNone</span><br><span class="line">                                     finished:finished</span><br><span class="line">                                          url:url];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>⑤如果下载到了图片，并且下载完成的话，则存盘并执行 completionBlock。存盘调用了 <code>SDImageCache</code> 的方法，随后介绍。</p>
<p>最后将当前 operation 移除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        </span><br><span class="line">        UIImage *transformedImage = [self.delegate imageManager:self</span><br><span class="line">                                       transformDownloadedImage:downloadedImage</span><br><span class="line">                                                        withURL:url];</span><br><span class="line">        </span><br><span class="line">        if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">            </span><br><span class="line">            BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">            NSData *cacheData;</span><br><span class="line">            // pass nil if the image was transformed, so we can recalculate the data from the image</span><br><span class="line">            if (self.cacheSerializer) &#123;</span><br><span class="line">                cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cacheData = (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // *** 存盘：注意是存的 imageData</span><br><span class="line">            [self.imageCache storeImage:transformedImage</span><br><span class="line">                              imageData:cacheData</span><br><span class="line">                                 forKey:key</span><br><span class="line">                                 toDisk:cacheOnDisk</span><br><span class="line">                             completion:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [self callCompletionBlockForOperation:strongSubOperation</span><br><span class="line">                                   completion:completedBlock</span><br><span class="line">                                        image:transformedImage</span><br><span class="line">                                         data:downloadedData</span><br><span class="line">                                        error:nil</span><br><span class="line">                                    cacheType:SDImageCacheTypeNone</span><br><span class="line">                                     finished:finished</span><br><span class="line">                                          url:url];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">if (finished) &#123;</span><br><span class="line">    [self safelyRemoveOperationFromRunning:strongSubOperation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-若不需要下载，并且有缓存"><a href="#10-若不需要下载，并且有缓存" class="headerlink" title="10.若不需要下载，并且有缓存"></a>10.若不需要下载，并且有缓存</h5><p>此时，执行 completionBlock 将缓存数据返回，然后移除当前 operation。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[self callCompletionBlockForOperation:strongOperation</span><br><span class="line">                           completion:completedBlock</span><br><span class="line">                                image:cachedImage</span><br><span class="line">                                 data:cachedData</span><br><span class="line">                                error:nil</span><br><span class="line">                            cacheType:cacheType</span><br><span class="line">                             finished:YES</span><br><span class="line">                                  url:url];</span><br><span class="line">            </span><br><span class="line">[self safelyRemoveOperationFromRunning:strongOperation];</span><br></pre></td></tr></table></figure>

<h5 id="11-其它，即没有缓存，且不需要下载"><a href="#11-其它，即没有缓存，且不需要下载" class="headerlink" title="11.其它，即没有缓存，且不需要下载"></a>11.其它，即没有缓存，且不需要下载</h5><p>和上边的操作类似，只不过传回的 image 和 data 均为 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[self callCompletionBlockForOperation:strongOperation</span><br><span class="line">                           completion:completedBlock</span><br><span class="line">                                image:nil</span><br><span class="line">                                 data:nil</span><br><span class="line">                                error:nil</span><br><span class="line">                            cacheType:SDImageCacheTypeNone</span><br><span class="line">                             finished:YES</span><br><span class="line">                                  url:url];</span><br><span class="line"></span><br><span class="line">[self safelyRemoveOperationFromRunning:strongOperation];</span><br></pre></td></tr></table></figure>

<p>最后将 operation 返回。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上就是 SDWebImageManager 这个类的主要功能，其中关于缓存和下载的内容，详见后边几篇的讨论。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/01/20/SDWebImage-Source-Learning-03/" data-id="cl7c27fgz0003jlfy0sq5corh" data-title="SDWebImage 源码学习笔记 ☞ SDWebImageManager" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SDWebImage-Source-Learning-02" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/12/SDWebImage-Source-Learning-02/" class="article-date">
  <time class="dt-published" datetime="2019-01-12T12:30:24.000Z" itemprop="datePublished">2019-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/12/SDWebImage-Source-Learning-02/">SDWebImage 源码学习笔记 ☞ 结构及基本流程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-29157f1c1fb6719f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage-源码学习笔记.png"></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>这是本系列的第 2 篇，本篇的目的如题所示，就是了解 SDWebImage 这个常用框架的文件结构，然后通过案例梳理流程，作为后边章节的主线。</p>
<h3 id="二、目录结构"><a href="#二、目录结构" class="headerlink" title="二、目录结构"></a>二、目录结构</h3><p>为了查看 <code>SDWebImage </code> 的完整目录结构，首先需要导入 <a target="_blank" rel="noopener" href="https://github.com/SDWebImage/SDWebImage">SDWebImage</a>，由 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c3ec50e1942f">上一篇</a> 我们了解到，新版 <code>SDWebImage </code> 总共分了 4 个子 pod，默认只导入了 Core，为了将它们全部导入 demo 中，Podfile 文件需要这么来写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">source &#x27;https://github.com/CocoaPods/Specs.git&#x27;</span><br><span class="line">platform :ios, &#x27;9.0&#x27;</span><br><span class="line"></span><br><span class="line">target &#x27;HHSDWebImageStudy&#x27; do</span><br><span class="line"></span><br><span class="line">pod &#x27;SDWebImage&#x27;, &#x27;4.4.2&#x27;  // 为了讨论方便，这里选定了一个比较新的版本</span><br><span class="line">pod &#x27;SDWebImage/WebP&#x27;</span><br><span class="line">pod &#x27;SDWebImage/GIF&#x27;</span><br><span class="line">pod &#x27;SDWebImage/MapKit&#x27;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>执行 <code>pod install</code> 之后得到的目录结构如下图所示，<a target="_blank" rel="noopener" href="https://upload-images.jianshu.io/upload_images/2208988-043e98867ce30bf6.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">点此查看完整目录结构</a> 。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-6a0eabcaabb5ee6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage-目录结构.png"></p>
<h3 id="三、示例：用-UIImageView-展示一张静态网络图片"><a href="#三、示例：用-UIImageView-展示一张静态网络图片" class="headerlink" title="三、示例：用 UIImageView 展示一张静态网络图片"></a>三、示例：用 UIImageView 展示一张静态网络图片</h3><p>下面是使用时的代码，加载图片时调用的是 <code>UIImageView+WebCache</code> 中的方法 <code>sd_setImageWithURL:</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1.创建 UIImageView</span><br><span class="line">UIImageView *imgV = [[UIImageView alloc] initWithFrame:CGRectMake(125, 70, 160, 160)];</span><br><span class="line">[self.view addSubview:imgV];</span><br><span class="line"></span><br><span class="line">// 2.加载网络图片</span><br><span class="line">[imgV sd_setImageWithURL:[NSURL URLWithString:@&quot;https://img.zcool.cn/community/01c81558a2723ca801219c77a1e34e.jpg&quot;]];</span><br></pre></td></tr></table></figure>

<p>查看 <code>sd_setImageWithURL:</code> 的实现，内部调用了一个参数很全的方法 <code>sd_setImageWithURL: placeholderImage: options: progress: completed:</code>，只不过其他参数已经给了默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url &#123;</span><br><span class="line">    [self sd_setImageWithURL:url placeholderImage:nil options:0 progress:nil completed:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，还有很多类似方法，都是对这个方法不同程度的封装，即给一些参数提供了默认值，或者增加了一些额外操作，比如下边这几个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder &#123;</span><br><span class="line">    [self sd_setImageWithURL:url placeholderImage:placeholder options:0 progress:nil completed:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options &#123;</span><br><span class="line">    [self sd_setImageWithURL:url placeholderImage:placeholder options:options progress:nil completed:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url completed:(nullable SDExternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    [self sd_setImageWithURL:url placeholderImage:nil options:0 progress:nil completed:completedBlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder completed:(nullable SDExternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    [self sd_setImageWithURL:url placeholderImage:placeholder options:0 progress:nil completed:completedBlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options completed:(nullable SDExternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    [self sd_setImageWithURL:url placeholderImage:placeholder options:options progress:nil completed:completedBlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)sd_setImageWithPreviousCachedImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                 placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                                          options:(SDWebImageOptions)options</span><br><span class="line">                                         progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                        completed:(nullable SDExternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    // 1.取出本地缓存</span><br><span class="line">    NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:url];</span><br><span class="line">    UIImage *lastPreviousCachedImage = [[SDImageCache sharedImageCache] imageFromCacheForKey:key];</span><br><span class="line">    </span><br><span class="line">    // 2.调用本类中的 参数很多的方法，并将缓存数据 (没有时用 placeholder) 传给 placeholder</span><br><span class="line">    [self sd_setImageWithURL:url</span><br><span class="line">            placeholderImage:lastPreviousCachedImage ?: placeholder</span><br><span class="line">                     options:options</span><br><span class="line">                    progress:progressBlock</span><br><span class="line">                   completed:completedBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看看这个参数巨多的方法  <code>sd_setImageWithURL: placeholderImage: options: progress: completed:</code> 究竟是如何实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    // 跳转 UIView+WebCache 中的 sd_internalSetImageWithURL: 方法执行，若 &lt;= 3.x.x 时，sd_internalSetImageWithURL: 在本类内部</span><br><span class="line">    [self sd_internalSetImageWithURL:url</span><br><span class="line">                    placeholderImage:placeholder</span><br><span class="line">                             options:options</span><br><span class="line">                        operationKey:nil</span><br><span class="line">                       setImageBlock:nil</span><br><span class="line">                            progress:progressBlock</span><br><span class="line">                           completed:completedBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是继续调用别的方法，不过这次是调用父类分类 (UIView+WebCache) 中的方法，之所以要调用直接或间接父类的方法，是为了让其他控件 (如 UIButton 等) 可以复用加载网络图片的方法，他们间的关系如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-f414668709bfccc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UIView和直接或间接子类间的关系.png"></p>
<p>现在去父类的分类 <code>UIView+WebCache</code> 看看吧，为了缩减篇幅，以下代码做了适当精简。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</span><br><span class="line">                  placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(nullable NSString *)operationKey</span><br><span class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(nullable SDExternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    return [self sd_internalSetImageWithURL:url</span><br><span class="line">                           placeholderImage:placeholder</span><br><span class="line">                                    options:options</span><br><span class="line">                               operationKey:operationKey</span><br><span class="line">                              setImageBlock:setImageBlock</span><br><span class="line">                                   progress:progressBlock</span><br><span class="line">                                  completed:completedBlock</span><br><span class="line">                                    context:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// *** 核心方法</span><br><span class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</span><br><span class="line">                  placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(nullable NSString *)operationKey</span><br><span class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(nullable SDExternalCompletionBlock)completedBlock</span><br><span class="line">                           context:(nullable NSDictionary&lt;NSString *, id&gt; *)context &#123;</span><br><span class="line">    </span><br><span class="line">        // 1.取消当前 validOperationKey 对应的 loadOperation</span><br><span class="line">        NSString *validOperationKey = operationKey ?: NSStringFromClass([self class]);</span><br><span class="line">        [self sd_cancelImageLoadOperationWithKey:validOperationKey];</span><br><span class="line">            </span><br><span class="line">        // 创建 manager（两种：1.用户自定义 2.此库自带的单例）</span><br><span class="line">        SDWebImageManager *manager;</span><br><span class="line">        if ([context valueForKey:SDWebImageExternalCustomManagerKey]) &#123;</span><br><span class="line">            manager = (SDWebImageManager *)[context valueForKey:SDWebImageExternalCustomManagerKey];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            manager = [SDWebImageManager sharedManager];</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        // 2.下载</span><br><span class="line">        id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url</span><br><span class="line">                                                               options:options</span><br><span class="line">                                                              progress:combinedProgressBlock</span><br><span class="line">                                                             completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL)</span><br><span class="line">        &#123;</span><br><span class="line">            __strong __typeof (wself) sself = wself;</span><br><span class="line">            // ...</span><br><span class="line">            SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">                if (!sself) &#123; return; &#125;</span><br><span class="line">                if (!shouldNotSetImage) &#123;</span><br><span class="line">                    [sself sd_setNeedsLayout];</span><br><span class="line">                &#125;</span><br><span class="line">                if (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            // ...</span><br><span class="line">            dispatch_main_async_safe(^&#123;</span><br><span class="line">#if SD_UIKIT || SD_MAC</span><br><span class="line">                [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</span><br><span class="line">#else</span><br><span class="line">                [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">#endif</span><br><span class="line">                callCompletedBlockClojure();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">// 3.为 UIImageView 绑定新的 operation，即上边这个 operation</span><br><span class="line">        [self sd_setImageLoadOperation:operation forKey:validOperationKey];</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123; // 如果图片 URL 不存在，执行 completedBlock，返回错误提示</span><br><span class="line">        </span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            </span><br><span class="line">            if (completedBlock) &#123;</span><br><span class="line">                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];</span><br><span class="line">                completedBlock(nil, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，父类最终调用了 <code>- (void)sd_internalSetImageWithURL: ...</code> 这个核心方法，虽然实现代码较多，其实主要就做了这么 3 件事：</p>
<p>① 取消 validOperationKey 对应的已经存在的 loadOperation。因为传进来的参数 validOperationKey 是 nil，所以 validOperationKey 实际取的是当前类名对应的字符串 NSStringFromClass([self class])。</p>
<p>② 执行 <code>SDWebImageManager</code> 的方法 <code>- (id &lt;SDWebImageOperation&gt;)loadImageWithURL: ...</code> 下载图片，并返回一个 operation 对象，其实是这个类 <code>SDWebImageCombinedOperation</code> 的实例，与上一步 cancel 的对象是同一类型，下面就会用到。</p>
<p>③ 保存 validOperationKey 与刚刚生成的 operation 之间的映射关系，以备取消时使用（如 ①）。</p>
<p>对于 ② 用到的方法，其实现代码太长，此处代码也做了精简：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageManager</span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                     options:(SDWebImageOptions)options</span><br><span class="line">                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                   completed:(nullable SDInternalCompletionBlock)completedBlock</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line">    // 1.创建 operation</span><br><span class="line">    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    operation.manager = self; // 肯定是 weak 属性</span><br><span class="line"></span><br><span class="line">    __weak typeof(strongOperation) weakSubOperation = strongOperation;</span><br><span class="line">    </span><br><span class="line">    // 2.使用 imageCache 的方法查询缓存</span><br><span class="line">    operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key</span><br><span class="line">                                                                  options:cacheOptions</span><br><span class="line">                                                                     done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType)</span><br><span class="line">    &#123;</span><br><span class="line">// 以下都是查询结束后 (查到/没查到) 的操作</span><br><span class="line"></span><br><span class="line">        if (shouldDownload) &#123;</span><br><span class="line"></span><br><span class="line">// 3. 需要下载</span><br><span class="line"></span><br><span class="line">        __weak typeof(strongOperation) weakSubOperation = strongOperation;</span><br><span class="line">            strongOperation.downloadToken = [self.imageDownloader downloadImageWithURL:url</span><br><span class="line">                                                                               options:downloaderOptions</span><br><span class="line">                                                                              progress:progressBlock</span><br><span class="line">                                                                             completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished)</span><br><span class="line">            &#123;</span><br><span class="line">                // 缩放图片(如果可以的话)</span><br><span class="line">                // 缓存图片</span><br><span class="line">                // 执行完成的回调</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (cachedImage) &#123;</span><br><span class="line">            </span><br><span class="line">// 4. 如果取到了缓存</span><br><span class="line">            // 执行完成的回调</span><br><span class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">            // 从正在运行的 operation 数组中移除当前 operation</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           </span><br><span class="line">// 5. 没取到缓存 &amp;&amp; 不允许下载</span><br><span class="line">            // 执行完成的回调</span><br><span class="line">            // Image not in cache and download disallowed by delegate</span><br><span class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url];</span><br><span class="line">            // 从正在运行的 operation 数组中移除当前 operation</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要是在创建 <code>SDWebImageCombinedOperation</code> 对象，大概的操作见上边的代码注释。只对其中 2 个自己认为更重要点的方法做一个简要说明，详细的讨论可以查看后边的相关篇章。</p>
<ul>
<li><code>SDImageCache</code> 中查询缓存的方法 <code>- (nullable NSOperation *)queryCacheOperationForKey: ...</code>。这个方法的作用是查询二级缓存，也就依次从内存、磁盘两处缓存查询我们需要的图片数据，前者查不到时，才在后者中查找。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// SDImageCache</span><br><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key</span><br><span class="line">                                            options:(SDImageCacheOptions)options</span><br><span class="line">                                               done:(nullable SDCacheQueryCompletedBlock)doneBlock;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SDWebImageDownloader</code> 中下载图片的方法 <code>- (nullable SDWebImageDownloadToken *)downloadImageWithURL: ...</code>。此方法的实现通过 operation 和 operationQueue 配合使用来执行下载操作的，即 先分别创建 operation 和 operationQueue，然后将 operation 添加到 operationQueue 中，就自动启动任务了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageDownloader</span><br><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br></pre></td></tr></table></figure>

<ul>
<li>无论是查询缓存还是请求网络数据，最终都会给 imageView 赋值，也就是我们通常希望达到的效果。</li>
</ul>
<h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><p>至此，我们大概理了一下 使用 <code>SDWebImage</code> 加载网络图片的主要流程，最后借用 <code>SDWebImage</code>  作者提供的一张时序图做个简单总结吧。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-90d9b6495d87a6c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImageSequenceDiagram.png"></p>
<h3 id="源码注释及-demo"><a href="#源码注释及-demo" class="headerlink" title="源码注释及 demo"></a>源码注释及 demo</h3><p><a target="_blank" rel="noopener" href="https://github.com/riversea2015/CodeForBlogs/tree/master/HHSDWebImageStudy">HHSDWebImageStudy</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/01/12/SDWebImage-Source-Learning-02/" data-id="cl7c27fgu0000jlfyenar9181" data-title="SDWebImage 源码学习笔记 ☞ 结构及基本流程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SDWebImage-Source-Learning-01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/06/SDWebImage-Source-Learning-01/" class="article-date">
  <time class="dt-published" datetime="2019-01-06T04:19:15.000Z" itemprop="datePublished">2019-01-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/06/SDWebImage-Source-Learning-01/">SDWebImage 源码学习笔记·前传 ☞ 升级</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-29157f1c1fb6719f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage-源码学习笔记.png"></p>
<p>2019.12.27 更新：最近发现 <a target="_blank" rel="noopener" href="https://github.com/SDWebImage/SDWebImage">SDWebImage</a>  升级到 5.0 以后加载 WebP 和 Gif 的方式也发生了改变，详见文末。</p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>前段时间对项目中使用的 <a target="_blank" rel="noopener" href="https://github.com/SDWebImage/SDWebImage">SDWebImage</a> 进行了一次升级 (3.7.6 → 4.4.2)，升级过程中遇到了一些问题，于是又把源码读了一遍，为了记录读码过程，就有了这个系列：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c3ec50e1942f">SDWebImage 源码学习笔记·前传 ☞ 升级 4.0 &#x2F; 5.0 后适配 WebP&#x2F;GIF</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/99c9564043d2">SDWebImage源码学习笔记 ☞ 结构及基本流程</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/221b335cc760">SDWebImage源码学习笔记 ☞ SDWebImageManager</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/06071cba3404">SDWebImage源码学习笔记 ☞ SDWebImageDownloader</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e3f4a7f57899">SDWebImage源码学习笔记 ☞ SDImageCache</a></li>
</ul>
<p>本篇是第 1 篇，主要记述了升级过程中的遇到的问题及处理方案。</p>
<h3 id="二、升级"><a href="#二、升级" class="headerlink" title="二、升级"></a>二、升级</h3><p>现在转回到本篇的主要内容，首先当然是升级了，不过最新版的 SDWebImage 里边分了几个子 pod ，默认下载不全。为了满足我们的日常使用要求，还需要加上 WebP 和 GIF 这两个子 pod：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &#x27;7.0&#x27;</span><br><span class="line"></span><br><span class="line">pod &#x27;SDWebImage&#x27;, &#x27;~&gt; 4.0&#x27;</span><br><span class="line">pod &#x27;SDWebImage/WebP&#x27;</span><br><span class="line">pod &#x27;SDWebImage/GIF&#x27;</span><br></pre></td></tr></table></figure>

<p>不过，在执行 <code>pod install</code> 的时候，发现 <code>pod &#39;SDWebImage/WebP&#39;</code> 卡在了 <code>Installing libwebp (0.6.0)</code> 的地方。</p>
<p>据说 WebP 的解析库是 Google 的开源库，目前还无法直接使用，可以使用github上的镜像文件，这个网上很容易搜到，示例见文末参考。</p>
<p>完成后 pod 内部的结构如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-89f6ed8da3d73c10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage4.0.png"></p>
<h3 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h3><p>为叙述方便，此处将图片的 URL 定义成了宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define URL_Normal          [NSURL URLWithString:@&quot;此处是 普通静态图 地址&quot;]</span><br><span class="line">#define URL_WebP_Normal     [NSURL URLWithString:@&quot;此处是 静态 WebP 地址&quot;]</span><br><span class="line">#define URL_WebP_Dynamic    [NSURL URLWithString:@&quot;此处是 动态 WebP 地址&quot;]</span><br><span class="line">#define URL_GIF             [NSURL URLWithString:@&quot;此处是 GIF 地址&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="第一种方案"><a href="#第一种方案" class="headerlink" title="第一种方案"></a>第一种方案</h4><ul>
<li>png&#x2F;jpg，直接使用 SDWebImage 提供的普通方法即可。</li>
<li>WebP，只要导入了 WebP 的子 pod，直接使用普通方法即可正常加载静态、动态的 WebP。</li>
<li>GIF，此处使用了 FLAnimatedImageView 代替 UIImageView 来展示 GIF。因为 SDWebImage4.0 以后，如果继续 <code>直接</code> 使用 UIImageView 将只展示 GIF 的第一帧，可以使用推荐的 FLAnimatedImageView 替换 UIImageView。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    // 普通静态图</span><br><span class="line">    UIImageView *imgV = [[UIImageView alloc] initWithFrame:CGRectMake(125, 70, 160, 160)];</span><br><span class="line">    imgV.backgroundColor = [UIColor lightGrayColor];</span><br><span class="line">    [self.view addSubview:imgV];</span><br><span class="line">    [imgV sd_setImageWithURL:URL_Normal];</span><br><span class="line"></span><br><span class="line">    // WebP</span><br><span class="line">    UIImageView *imgVB = [[UIImageView alloc] initWithFrame:CGRectMake(125, 70+160+10, 160, 160)];</span><br><span class="line">    imgVB.backgroundColor = [UIColor lightGrayColor];</span><br><span class="line">    imgVB.contentMode = UIViewContentModeScaleAspectFill;</span><br><span class="line">    [self.view addSubview:imgVB];</span><br><span class="line">    // WebP 静态图</span><br><span class="line">//    [imgVB sd_setImageWithURL:URL_WebP_Normal];</span><br><span class="line">    // WebP 动态图</span><br><span class="line">    [imgVB sd_setImageWithURL:URL_WebP_Dynamic];</span><br><span class="line">    </span><br><span class="line">    // GIF</span><br><span class="line">    FLAnimatedImageView *imgView = [[FLAnimatedImageView alloc] initWithFrame:CGRectMake(125, 70+160+10+160+10, 160, 200)];</span><br><span class="line">    imgView.backgroundColor = [UIColor lightGrayColor];</span><br><span class="line">    imgView.contentMode = UIViewContentModeScaleAspectFill;</span><br><span class="line">    [self.view addSubview:imgView];</span><br><span class="line">    [imgView sd_setShowActivityIndicatorView:YES];</span><br><span class="line">    [imgView sd_setImageWithURL:URL_GIF</span><br><span class="line">             placeholderImage:[UIImage imageNamed:@&quot;placeholder&quot;]</span><br><span class="line">                      options:1];</span><br></pre></td></tr></table></figure>
<h4 id="第二种方案"><a href="#第二种方案" class="headerlink" title="第二种方案"></a>第二种方案</h4><p>统一都使用 UIImageView 展示图片，不过和上边的第一种方案有以下不同：</p>
<ul>
<li>使用 <code>SDWebImageManager</code> 的 <code>loadImageWithURL: options: progress: completed:</code> 方法下载图片；</li>
<li>根据得到的 data 判断图片类型: <code>SDImageFormat format = [NSData sd_imageFormatForImageData:data];</code>，基本原理是根据 data 的第一个字节来判断；</li>
<li>WebP 使用专用方法 <code>sd_imageWithWebPData: </code> 解码；</li>
<li>GIF 也使用专用方法 <code>sd_animatedGIFWithData:</code> 解码。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">UIImageView *gifView = [[UIImageView alloc] initWithFrame:CGRectMake(10, 70+160+10+160+10+200+10, kScreenW-20, 200)];</span><br><span class="line">    gifView.backgroundColor = [UIColor lightGrayColor];</span><br><span class="line">    [self.view addSubview:gifView];</span><br><span class="line">    self.imgView = gifView;</span><br><span class="line">    </span><br><span class="line">    SDWebImageManager *mgr = [SDWebImageManager sharedManager];</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    [mgr loadImageWithURL:URL_GIF // URL_WebP_Dynamic // URL_WebP_Normal // URL_Normal</span><br><span class="line">                  options:1</span><br><span class="line">                 progress:nil</span><br><span class="line">                completed:^(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL)</span><br><span class="line">    &#123;</span><br><span class="line">        SDImageFormat format = [NSData sd_imageFormatForImageData:data];</span><br><span class="line">        switch (format) &#123;</span><br><span class="line">            case SDImageFormatGIF:</span><br><span class="line">                weakSelf.imgView.image = [UIImage sd_animatedGIFWithData:data];</span><br><span class="line">                break;</span><br><span class="line">            case SDImageFormatWebP:</span><br><span class="line">                weakSelf.imgView.image = [UIImage sd_imageWithWebPData:data];</span><br><span class="line">                break;</span><br><span class="line">            case SDImageFormatPNG:</span><br><span class="line">            case SDImageFormatJPEG:</span><br><span class="line">                weakSelf.imgView.image = image;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h4 id="第三种方案"><a href="#第三种方案" class="headerlink" title="第三种方案"></a>第三种方案</h4><p>自定义 HHImageView，在它的 init 系列方法中添加了对 GIF 的解析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[SDWebImageCodersManager sharedInstance] addCoder:[SDWebImageGIFCoder sharedCoder]];</span><br></pre></td></tr></table></figure>

<p>这种方案对最终的调用方来说，非常简洁，不需要对各种图片区别对待。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    HHImageView *customView = [[HHImageView alloc] initWithFrame:CGRectMake(125, 70, 160, 160)];</span><br><span class="line">    customView.backgroundColor = [UIColor lightGrayColor];</span><br><span class="line">    [self.view addSubview:customView];</span><br><span class="line">    [customView sd_setShowActivityIndicatorView:YES];</span><br><span class="line">    // 静态图</span><br><span class="line">//    [customView sd_setImageWithURL:URL_Normal];</span><br><span class="line">    // WebP 动图</span><br><span class="line">//    [customView sd_setImageWithURL:URL_WebP_Normal];</span><br><span class="line">    // WebP 静态图</span><br><span class="line">//    [customView sd_setImageWithURL:URL_WebP_Dynamic];</span><br><span class="line">    // GIF</span><br><span class="line">    [customView sd_setImageWithURL:URL_GIF];</span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="2019-12-27-更新："><a href="#2019-12-27-更新：" class="headerlink" title="2019.12.27 更新："></a>2019.12.27 更新：</h3><ul>
<li>5.0 之后的版本中，默认添加了对 Gif 的支持，也就是说，需要移除 podfile 中的 <code>pod &#39;SDWebImage/GIF&#39;</code>（不移除的话，pod install&#x2F;update 会报错），然后直接使用加载 png&#x2F;jpg 的方法就可以加载 Gif 图了，比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageViewA.sd_setImage(with: URL(string: &quot;http://hbimg.b0.upaiyun.com/43efd35d1e9cadc6d8ff5cdc5faccec06f1082bb4efc4-o8K27E_fw658&quot;), completed: nil) // 皮卡丘揉脸的动画^_^</span><br></pre></td></tr></table></figure></li>
<li>对于 WebP，将之前的 subspec 抽出来，创建了一个单独的库 <code>SDImageWebPCoder</code>，使用时需要两步操作：<ul>
<li>在 podfile 文件中用下边的内容替换之前的 <code>pod &#39;SDWebImage/GIF&#39;</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#x27;SDImageWebPCoder&#x27;</span><br></pre></td></tr></table></figure></li>
<li>使用前，先给 <code>SDImageCodersManager</code> 添加一个 coder：<code>WebPCoder</code>，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let WebPCoder = SDImageWebPCoder.shared</span><br><span class="line">SDImageCodersManager.shared.addCoder(WebPCoder)</span><br></pre></td></tr></table></figure>
然后，就可以使用通用的方法加载 WebP 了，示例代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 静态图</span><br><span class="line">imageViewA.sd_setImage(with: URL(string: &quot;https://www.gstatic.com/webp/gallery/2.webp&quot;), completed: nil)</span><br><span class="line">// 动图</span><br><span class="line">imageViewB.sd_setImage(with: URL(string: &quot;http://littlesvr.ca/apng/images/world-cup-2014-42.webp&quot;), completed: nil) </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</blockquote>
<p>本文完整示例代码见: <a target="_blank" rel="noopener" href="https://github.com/riversea2015/CodeForBlogs/tree/master/HHSDWebImageStudy">HHSDWebImageStudy</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/009caf1df1d5">iOS pod Error installing libwebp错误超详细解决办法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4468f03cf606">iOS SDWebImage加载webP</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/01/06/SDWebImage-Source-Learning-01/" data-id="cl7c27fgw0001jlfyesys8w9o" data-title="SDWebImage 源码学习笔记·前传 ☞ 升级" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MJRefresh-Source-Learning-Notes" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/12/25/MJRefresh-Source-Learning-Notes/" class="article-date">
  <time class="dt-published" datetime="2018-12-25T06:23:22.000Z" itemprop="datePublished">2018-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/12/25/MJRefresh-Source-Learning-Notes/">MJRefresh 源码学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p><a target="_blank" rel="noopener" href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a> 是日常 iOS 开发中使用频率比较高的一款<code>下拉刷新</code>&#x2F;<code>上拉加载更多</code>的第三方控件，平时似乎没有完整查看过源码，此处就记录一下探究源码的过程吧。</p>
        
          <p class="article-more-link">
            <a href="/2018/12/25/MJRefresh-Source-Learning-Notes/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2018/12/25/MJRefresh-Source-Learning-Notes/" data-id="cl778ex770000tvfycvek6x2j" data-title="MJRefresh 源码学习笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MBProgressHUD-Source-Learning-Notes" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/12/23/MBProgressHUD-Source-Learning-Notes/" class="article-date">
  <time class="dt-published" datetime="2018-12-23T09:07:23.000Z" itemprop="datePublished">2018-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/12/23/MBProgressHUD-Source-Learning-Notes/">MBProgressHUD 源码阅读笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98ef95e68aad4ac5899763af97dce85d~tplv-k3u1fbpfcp-watermark.image" alt="mbprogress_cover.png"></p>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p><a target="_blank" rel="noopener" href="https://github.com/jdg/MBProgressHUD">MBProgressHUD</a> 是 iOS 开发中经常会用到的一个加载动画库，现在就来阅读一下源码。</p>
        
          <p class="article-more-link">
            <a href="/2018/12/23/MBProgressHUD-Source-Learning-Notes/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2018/12/23/MBProgressHUD-Source-Learning-Notes/" data-id="cl77ebd5100003jfy2u33cwny" data-title="MBProgressHUD 源码阅读笔记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/12/15/hello-world/" class="article-date">
  <time class="dt-published" datetime="2018-12-15T09:07:23.000Z" itemprop="datePublished">2018-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/12/15/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
        
          <p class="article-more-link">
            <a href="/2018/12/15/hello-world/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2018/12/15/hello-world/" data-id="cl6man13d000056fy33kv62jk" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/24/ijkplayer-Compilation-and-Packaging/">ijkplayer 编译-打包-Pod支持</a>
          </li>
        
          <li>
            <a href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/">iOS UITextView 实现类似微博的话题、提及功能</a>
          </li>
        
          <li>
            <a href="/2019/02/03/SDWebImage-Source-Learning-05/">SDWebImage 源码学习笔记 ☞ SDImageCache</a>
          </li>
        
          <li>
            <a href="/2019/01/26/SDWebImage-Source-Learning-04/">SDWebImage 源码学习笔记 ☞ SDWebImageDownloader</a>
          </li>
        
          <li>
            <a href="/2019/01/20/SDWebImage-Source-Learning-03/">SDWebImage 源码学习笔记 ☞ SDWebImageManager</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 He Hai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>