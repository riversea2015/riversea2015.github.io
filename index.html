<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>riversea2015</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="iOSer">
<meta property="og:type" content="website">
<meta property="og:title" content="riversea2015">
<meta property="og:url" content="https://devhe.com/index.html">
<meta property="og:site_name" content="riversea2015">
<meta property="og:description" content="iOSer">
<meta property="og:locale">
<meta property="article:author" content="He Hai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="riversea2015" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">riversea2015</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Stay Hungry, Stay Young.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://devhe.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-ijkplayer-Compilation-and-Packaging" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/24/ijkplayer-Compilation-and-Packaging/" class="article-date">
  <time class="dt-published" datetime="2022-08-24T06:16:06.000Z" itemprop="datePublished">2022-08-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/24/ijkplayer-Compilation-and-Packaging/">ijkplayer 编译-打包-Pod支持</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://github.com/Bilibili/ijkplayer">ijkplayer</a> 是 <a target="_blank" rel="noopener" href="https://github.com/Bilibili">bilibili</a> 开源的一款优秀的视频播放器，基于 <code>ffplay</code>，支持 <code>iOS/Android</code>，点播&#x2F;直播，以及多种编解码方式。官方虽不提供现成的 framework，但大家可以根据需要自定义配置后，自己打包。本文仅对自己之前编译打包的过程做一简要记录。 </p>
        
          <p class="article-more-link">
            <a href="/2022/08/24/ijkplayer-Compilation-and-Packaging/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2022/08/24/ijkplayer-Compilation-and-Packaging/" data-id="cl77860q50000safyafsld3np" data-title="ijkplayer 编译-打包-Pod支持" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Topics-and-mentions-similar-to-Weibo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/" class="article-date">
  <time class="dt-published" datetime="2022-08-23T08:52:46.000Z" itemprop="datePublished">2022-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/">iOS UITextView 实现类似微博的话题、提及功能</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>最近接了一个需求，在发布动态的时候，增加类似微博的<code>#话题#</code>、<code>@提及用户</code>的效果，在此做一简要记录。</p>
        
          <p class="article-more-link">
            <a href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2022/08/23/Topics-and-mentions-similar-to-Weibo/" data-id="cl75yesom0000rbfyahqw9rlk" data-title="iOS UITextView 实现类似微博的话题、提及功能" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-AFNetWorking-Source-Learning-05" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/03/17/AFNetWorking-Source-Learning-05/" class="article-date">
  <time class="dt-published" datetime="2019-03-16T17:20:40.000Z" itemprop="datePublished">2019-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/03/17/AFNetWorking-Source-Learning-05/">AFNetWorking 源码学习笔记 ☞ Reachability</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-6bf242f27828bbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking 源码学习笔记.png"></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>本文是 AFNetWorking 源码学习笔记的第五篇，本篇将介绍第四部分 – Reachability 目录下的类，也就是 AFNetworkReachabilityManager。</p>
<p>虽然之前经历的几个项目里边都是对苹果提供的 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/samplecode/reachability/">Reachability</a> 进行了一次封装，不过，还是有必要学习一下 AFNetWorking 中监听网络状态的类 AFNetworkReachabilityManager，也就是本文的重点。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-840cbc8066feaf52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking-Reachability.png"></p>
<h3 id="二、使用示例"><a href="#二、使用示例" class="headerlink" title="二、使用示例"></a>二、使用示例</h3><p>先来看一个使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"></span><br><span class="line">[manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    </span><br><span class="line">    switch (status) &#123;</span><br><span class="line">        case AFNetworkReachabilityStatusUnknown:</span><br><span class="line">            NSLog(@&quot;网络状态未知&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case AFNetworkReachabilityStatusNotReachable:</span><br><span class="line">            NSLog(@&quot;无网络&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case AFNetworkReachabilityStatusReachableViaWWAN:</span><br><span class="line">            NSLog(@&quot;手机自带网络&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case AFNetworkReachabilityStatusReachableViaWiFi:</span><br><span class="line">            NSLog(@&quot;WiFi&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[manager startMonitoring];</span><br></pre></td></tr></table></figure>

<p>运行后发现，状态改变时会有相应的输出，在模拟器上可能不太准确，断网后再连网，监测不到，不过真机是正常的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018-11-28 16:42:40.825948+0800 HHAFNetworkingStudy[5703:831886] WiFi</span><br><span class="line">2018-11-28 16:42:51.052528+0800 HHAFNetworkingStudy[5703:831886] 无网络</span><br></pre></td></tr></table></figure>

<h3 id="三、正文"><a href="#三、正文" class="headerlink" title="三、正文"></a>三、正文</h3><p>现在开始查看源码，点开 AFNetworkReachabilityManager 的头文件，首先是 4 个属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly, nonatomic, assign) AFNetworkReachabilityStatus networkReachabilityStatus;  // 标识网络状态的枚举值</span><br><span class="line">@property (readonly, nonatomic, assign, getter = isReachable) BOOL reachable; // 网络是否可用</span><br><span class="line">@property (readonly, nonatomic, assign, getter = isReachableViaWWAN) BOOL reachableViaWWAN; // 手机自带网络是否可用</span><br><span class="line">@property (readonly, nonatomic, assign, getter = isReachableViaWiFi) BOOL reachableViaWiFi; // Wifi是否可用</span><br></pre></td></tr></table></figure>

<p>后 3 个属性的 getter 如下，我们发现，他们都是通过第一个属性 networkReachabilityStatus 的值来做判断的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isReachable &#123;</span><br><span class="line">    return [self isReachableViaWWAN] || [self isReachableViaWiFi];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isReachableViaWWAN &#123;</span><br><span class="line">    return self.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWWAN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isReachableViaWiFi &#123;</span><br><span class="line">    return self.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWiFi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下方所示是创建及初始化方法，其中 new 和 init 方法被标识为不可用，查看实现文件得知，如果调用他们，会直接 crash。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedManager;  // 单例</span><br><span class="line">+ (instancetype)manager; // 针对默认地址（零地址）</span><br><span class="line">+ (instancetype)managerForDomain:(NSString *)domain;  // 针对域名</span><br><span class="line">+ (instancetype)managerForAddress:(const void *)address; // 针对地址</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability NS_DESIGNATED_INITIALIZER; // 最终调用的方法</span><br><span class="line"></span><br><span class="line">+ (instancetype)new NS_UNAVAILABLE;    // 不可用</span><br><span class="line">- (instancetype)init NS_UNAVAILABLE;   // 不可用</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 如果直接或间接调用此方法会抛出异常 crash</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    @throw [NSException exceptionWithName:NSGenericException</span><br><span class="line">                                   reason:@&quot;`-init` unavailable. Use `-initWithReachability:` instead&quot;</span><br><span class="line">                                 userInfo:nil];</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他创建方法最终调用的都是 <code>initWithReachability:</code> ，实现如下，给 _networkReachability 和 networkReachabilityStatus 赋初值。对于其中的 _networkReachability，提供了 2 种创建方法，见下方 2 个创建 manager 的类方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // 网络连接的对象</span><br><span class="line">    _networkReachability = CFRetain(reachability);</span><br><span class="line">    // 初始状态为未知</span><br><span class="line">    self.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 2 个创建 manager 的类方法</span><br><span class="line">+ (instancetype)managerForDomain:(NSString *)domain &#123;</span><br><span class="line">    </span><br><span class="line">    // 创建网络连接的对象：根据传入的域名创建网络连接引用</span><br><span class="line">    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);</span><br><span class="line"></span><br><span class="line">    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];</span><br><span class="line">    </span><br><span class="line">    CFRelease(reachability);</span><br><span class="line"></span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)managerForAddress:(const void *)address &#123;</span><br><span class="line">    </span><br><span class="line">    // 创建网络连接的对象：根据传入的地址创建网络连接的引用</span><br><span class="line">    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithAddress(kCFAllocatorDefault, (const struct sockaddr *)address);</span><br><span class="line">    </span><br><span class="line">    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];</span><br><span class="line"></span><br><span class="line">    CFRelease(reachability);</span><br><span class="line">    </span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，根据地址创建网络连接的对象 reachability 时，地址的创建在 <code>+ (instancetype)manager;</code> 这个类方法的实现里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)manager</span><br><span class="line">&#123;</span><br><span class="line">    // 创建零地址，0.0.0.0 的地址表示查询本机的网络连接状态</span><br><span class="line">#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 90000) || (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &gt;= 101100)</span><br><span class="line">    struct sockaddr_in6 address;</span><br><span class="line">    bzero(&amp;address, sizeof(address));</span><br><span class="line">    address.sin6_len = sizeof(address);</span><br><span class="line">    address.sin6_family = AF_INET6;</span><br><span class="line">#else</span><br><span class="line">    struct sockaddr_in address;</span><br><span class="line">    bzero(&amp;address, sizeof(address));</span><br><span class="line">    address.sin_len = sizeof(address);</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    return [self managerForAddress:&amp;address];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是控制网络状态监听开启&#x2F;关闭的 2 个方法，以及 2 个辅助方法，详见注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 开启监听</span><br><span class="line">- (void)startMonitoring; </span><br><span class="line">// 关闭监听</span><br><span class="line">- (void)stopMonitoring;   </span><br><span class="line"></span><br><span class="line">// 返回一个描述网络状态的本地化字符串，即将不同的网络状态转变成对应的文字描述后输出</span><br><span class="line">- (NSString *)localizedNetworkReachabilityStatusString;</span><br><span class="line">// 设置网络状态发生变化时的回调，用户自定义，实际会将这个 block 赋值给内部的一个 block 属性，当状态发生改变时执行这个 block。</span><br><span class="line">- (void)setReachabilityStatusChangeBlock:(nullable void (^)(AFNetworkReachabilityStatus status))block;</span><br></pre></td></tr></table></figure>

<p>接下来，我们重点研究一下 <code>- (void)startMonitoring;</code> 这个方法，先贴上图和代码，然后我们按照图示顺序依次讨论各个环节。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-dbe316a603bc81f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking-Reachability.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (void)startMonitoring &#123;</span><br><span class="line">    </span><br><span class="line">    // 1.停止已经存在的监听</span><br><span class="line">    [self stopMonitoring];</span><br><span class="line"></span><br><span class="line">    if (!self.networkReachability) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.构建 block：AFNetworkReachabilityStatusBlock callback</span><br><span class="line">    __weak __typeof(self)weakSelf = self;</span><br><span class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        __strong __typeof(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">        strongSelf.networkReachabilityStatus = status;</span><br><span class="line">        if (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">            strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 3.构建结构体 SCNetworkReachabilityContext context</span><br><span class="line">    SCNetworkReachabilityContext context = &#123;</span><br><span class="line">        0,</span><br><span class="line">        (__bridge void *)callback,</span><br><span class="line">        AFNetworkReachabilityRetainCallback,</span><br><span class="line">        AFNetworkReachabilityReleaseCallback,</span><br><span class="line">        NULL</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 4.设置回调</span><br><span class="line">    // AFNetworkReachabilityCallback =&gt; 监听到网络状态变化时需要执行的 block</span><br><span class="line">    SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br><span class="line">    </span><br><span class="line">    // 5.启动：将监听任务添加到 mainRunloop 的 CommonModes 里边</span><br><span class="line">    SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line">    // 测试</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^&#123;</span><br><span class="line">        SCNetworkReachabilityFlags flags;</span><br><span class="line">        // 这个函数用来获得测试连接的状态，第一个参数为之前建立的测试连接的引用，第二个参数用来保存获得的状态，如果能获得状态则返回TRUE，否则返回FALSE</span><br><span class="line">        if (SCNetworkReachabilityGetFlags(self.networkReachability, &amp;flags)) &#123;</span><br><span class="line">            AFPostReachabilityStatusChange(flags, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.结束之前已经存在的网络状态监听 <code>[self stopMonitoring];</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)stopMonitoring &#123;</span><br><span class="line">    if (!self.networkReachability) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // Unschedules the specified target from the specified run loop and mode.</span><br><span class="line">    SCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.创建一个 block (AFNetworkReachabilityStatusBlock)，用于在网络状态发生改变时，以 status 为参数，执行之前用户设置的 block。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__weak __typeof(self)weakSelf = self;</span><br><span class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        __strong __typeof(weakSelf)strongSelf = weakSelf;</span><br><span class="line">        // 为 networkReachabilityStatus 赋新值</span><br><span class="line">        strongSelf.networkReachabilityStatus = status;</span><br><span class="line">        // 执行用户定义的 block</span><br><span class="line">        if (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">            strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>3.创建一个网络状态上下文对象 (结构体)，内含上一步创建的 block，用于下一步设置 callback。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SCNetworkReachabilityContext context = &#123;</span><br><span class="line">        0,</span><br><span class="line">        (__bridge void *)callback,  // 第 2 步创建的 block</span><br><span class="line">        AFNetworkReachabilityRetainCallback,</span><br><span class="line">        AFNetworkReachabilityReleaseCallback,</span><br><span class="line">        NULL</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>4.为 networkReachability 设置回调，即当网络状态发生改变的时候，会执行对应的 block。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br></pre></td></tr></table></figure>

<p>5.启动监听，即将监听任务添加到 mainRunloop 的 commonModes 里边。至此，启动了对网络状态的监听。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Schedules the specified network target with the specified run loop and mode.</span><br><span class="line">SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>当状态发生改变时，首先会执行 <code>AFNetworkReachabilityCallback()</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void AFNetworkReachabilityCallback(SCNetworkReachabilityRef __unused target, SCNetworkReachabilityFlags flags, void *info) &#123;</span><br><span class="line">    AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.内部又调用了 <code>AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);</code>，其中 info 就是第 2 步时创建的那个 block。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) &#123;</span><br><span class="line">    </span><br><span class="line">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        // 1.执行 block, 即外边传进来的 info</span><br><span class="line">        if (block) &#123;</span><br><span class="line">            block(status);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 2.发送网络状态改变的通知</span><br><span class="line">        NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];</span><br><span class="line">        NSDictionary *userInfo = @&#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &#125;;</span><br><span class="line">        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:userInfo];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这是《AFNetWorking 源码学习笔记》的最后一篇，算是将源码大概看了一遍，不过由于本人所知甚少，而且时间有限，难免出现粗浅错漏之处，后期会及时纠正。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/guchengfengyun/p/8097031.html">SCNetReachablity</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f7f480a456c8">https://www.jianshu.com/p/f7f480a456c8</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/03/17/AFNetWorking-Source-Learning-05/" data-id="cl7c2jec00004lzfy2kk8e9ij" data-title="AFNetWorking 源码学习笔记 ☞ Reachability" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-AFNetWorking-Source-Learning-04" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/03/10/AFNetWorking-Source-Learning-04/" class="article-date">
  <time class="dt-published" datetime="2019-03-10T12:10:40.000Z" itemprop="datePublished">2019-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/03/10/AFNetWorking-Source-Learning-04/">AFNetWorking 源码学习笔记 ☞ Serialization</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-6bf242f27828bbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking 源码学习笔记.png"></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>本文是 AFNetWorking 源码学习笔记的第四篇，将介绍第三部分 – Serialization 目录下的文件：AFURLRequestSerialization(.h&#x2F;.m) 和 AFURLResponseSerialization(.h&#x2F;.m) ，仔细观察这些文件发现，AFURLRequestSerialization 和 AFURLResponseSerialization 不仅是文件名，还是 2 个协议的名称。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-783a68d8aa71319d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking-Serialization.png"></p>
<h3 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h3><h4 id="1-AFURLRequestSerialization-h-x2F-m"><a href="#1-AFURLRequestSerialization-h-x2F-m" class="headerlink" title="1. AFURLRequestSerialization(.h&#x2F;.m)"></a>1. AFURLRequestSerialization(.h&#x2F;.m)</h4><p>先看 AFURLRequestSerialization.h 文件，这个文件里边共有 2 个协议和 3 个类，他们之间的关系如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-aa1da98b828a8a41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFURLRequestSerialization-Simple.png"></p>
<p>这里，我们以 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/569e184cc9aa">上一篇</a> 提到的构造 request 的 2 个方法为主线开始介绍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 方法一</span><br><span class="line"></span><br><span class="line">NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method</span><br><span class="line">                                                               URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString]</span><br><span class="line">                                                              parameters:parameters</span><br><span class="line">                                                                   error:&amp;serializationError];</span><br><span class="line">// 方法二</span><br><span class="line">NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@&quot;POST&quot; </span><br><span class="line">                                                                            URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] </span><br><span class="line">                                                                           parameters:parameters </span><br><span class="line">                                                            constructingBodyWithBlock:block </span><br><span class="line">                                                                                error:&amp;serializationError];</span><br></pre></td></tr></table></figure>

<p>先来看看第一类请求方法的实现中构建 MutableURLRequest 用到的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)method</span><br><span class="line">                                 URLString:(NSString *)URLString</span><br><span class="line">                                parameters:(id)parameters</span><br><span class="line">                                     error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    // 0.检测 method、URLString 是否为空</span><br><span class="line">    NSParameterAssert(method);</span><br><span class="line">    NSParameterAssert(URLString);</span><br><span class="line"></span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line">    NSParameterAssert(url);    </span><br><span class="line"></span><br><span class="line">    // 1.开始创建（系统方法创建）</span><br><span class="line">    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];</span><br><span class="line">    </span><br><span class="line">    // 2.设置参数</span><br><span class="line">    // 2.1 请求方法</span><br><span class="line">    mutableRequest.HTTPMethod = method; // 方法默认是 “GET”</span><br><span class="line"></span><br><span class="line">    // 2.2 为 request 设置其一些默认参数</span><br><span class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        </span><br><span class="line">        // AFHTTPRequestSerializerObservedKeyPaths()：AFHTTPRequestSerializer 的 6个属性对应 getter 方法名 string 组成的数组</span><br><span class="line">        // self.mutableObservedChangedKeyPaths 中是 值非nil 的属性名</span><br><span class="line">        // requstSerializer 初始化时，创建了 self.mutableObservedChangedKeyPaths 这个空 mutableSet，然后，如果设置了对应的参数，它里边就会加上对应的属性名</span><br><span class="line">        </span><br><span class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.对参数进行序列化，并赋值给 request</span><br><span class="line">    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">	return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法来自 AFHTTPRequestSerializer，具体功能见上边的代码注释，简单看一下部分细节，2.2 for 循环的代码块，其中 AFHTTPRequestSerializerObservedKeyPaths() 是一个静态函数，实际返回了当前类 AFHTTPRequestSerializer 中的几个重要的属性名对应的字符串数组，也可以认为是其 get 方法名对应的字符串数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static NSArray * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class="line">    static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        _AFHTTPRequestSerializerObservedKeyPaths = @[NSStringFromSelector(@selector(allowsCellularAccess)),</span><br><span class="line">                                                     NSStringFromSelector(@selector(cachePolicy)),</span><br><span class="line">                                                     NSStringFromSelector(@selector(HTTPShouldHandleCookies)),</span><br><span class="line">                                                     NSStringFromSelector(@selector(HTTPShouldUsePipelining)),</span><br><span class="line">                                                     NSStringFromSelector(@selector(networkServiceType)),</span><br><span class="line">                                                     NSStringFromSelector(@selector(timeoutInterval))];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的初始化方法里边主要设置了一些 header，然后就是给上边方法提到的几个属性添加了 KVO 监听，当用户给这些属性赋值 (可以为nil)时，就会给 self.mutableObservedChangedKeyPaths 这个 mutableSet 增删元素 (相关代码如下)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 1. init 方法中给属性添加监听的代码</span><br><span class="line">for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &#123;</span><br><span class="line">            [self addObserver:self forKeyPath:keyPath options:NSKeyValueObservingOptionNew context:AFHTTPRequestSerializerObserverContext];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 2. 触发的监听方法</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                      ofObject:(__unused id)object</span><br><span class="line">                        change:(NSDictionary *)change</span><br><span class="line">                       context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    if (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class="line">        if ([change[NSKeyValueChangeNewKey] isEqual:[NSNull null]]) &#123;</span><br><span class="line">            [self.mutableObservedChangedKeyPaths removeObject:keyPath];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [self.mutableObservedChangedKeyPaths addObject:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到 for 循环中的语句，里边 if 语句的目的是将用户设置的属性值赋给 mutableRequest。</p>
<p>然后，来到 3. 序列化参数的时候，用到了这样一个方法 <code>requestBySerializingRequest: withParameters: error:</code>，它属于 AFURLRequestSerialization 这个协议，AFURLRequestSerializer 遵守协议并实现了该方法，注释见下方法注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - AFURLRequestSerialization</span><br><span class="line"></span><br><span class="line">// 为 request 设置参数</span><br><span class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</span><br><span class="line">                               withParameters:(id)parameters</span><br><span class="line">                                        error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(request);</span><br><span class="line"></span><br><span class="line">    // 0.将 request 转成 mutable，以便修改</span><br><span class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</span><br><span class="line"></span><br><span class="line">    // 1.设置 header 字段，self.HTTPRequestHeaders 是在 init 方法中设置的 useragent 等参数</span><br><span class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</span><br><span class="line">        // 将 self.HTTPRequestHeaders 中的 header 参数设置到 request 里边</span><br><span class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 2.参数序列化</span><br><span class="line">    NSString *query = nil;</span><br><span class="line">    if (parameters) &#123;</span><br><span class="line">        // 2.1 self.queryStringSerialization 是一个 block，如果从外边 设置了序列化规则</span><br><span class="line">        if (self.queryStringSerialization) &#123;</span><br><span class="line">            NSError *serializationError;</span><br><span class="line">            query = self.queryStringSerialization(request, parameters, &amp;serializationError);</span><br><span class="line"></span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line">                if (error) &#123;</span><br><span class="line">                    *error = serializationError;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">         // 2.2 使用AF提供的序列化规则，将 string、array、dictionary 的 parameters 统一转化成了 key1=value1&amp;key2=value2&amp;key3=value3 格式的字符串</span><br><span class="line">            switch (self.queryStringSerializationStyle) &#123;</span><br><span class="line">                case AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">                    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.设置 request 的 URL 或 HTTPBody 👇</span><br><span class="line">    </span><br><span class="line">    // 初始化时已经设置了 self.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@&quot;GET&quot;, @&quot;HEAD&quot;, @&quot;DELETE&quot;, nil];</span><br><span class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        </span><br><span class="line">        if (query &amp;&amp; query.length &gt; 0) &#123;</span><br><span class="line">            mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123; // POST 等其他方法，将 query 设置成 body</span><br><span class="line">        </span><br><span class="line">        // #2864: an empty string is a valid x-www-form-urlencoded payload</span><br><span class="line">        if (!query) &#123;</span><br><span class="line">            query = @&quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果设置了 body，需要有 Content-Type</span><br><span class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</span><br><span class="line">            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line">        &#125;</span><br><span class="line">        // self.stringEncoding 编码方式</span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，第一种创建 mutableRequest 的主要方法就介绍完了，在讨论第二种创建 MutableURLRequest 的方法实现之前，我们先看看 AFNetWorking 中给出的一个上传数据的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// AFNetWorking 中提供的示例</span><br><span class="line">NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@&quot;POST&quot;</span><br><span class="line">                                                                                          URLString:@&quot;http://example.com/upload&quot;</span><br><span class="line">                                                                                         parameters:nil</span><br><span class="line">                                                                          constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData)</span><br><span class="line">    &#123;</span><br><span class="line">        [formData appendPartWithFileURL:[NSURL fileURLWithPath:@&quot;file://path/to/image.jpg&quot;]</span><br><span class="line">                                   name:@&quot;file&quot;</span><br><span class="line">                               fileName:@&quot;filename.jpg&quot;</span><br><span class="line">                               mimeType:@&quot;image/jpeg&quot;</span><br><span class="line">                                  error:nil];</span><br><span class="line">    &#125; error:nil];</span><br></pre></td></tr></table></figure>

<p>关注一下 constructingBodyWithBlock 中的代码就行，其中调用了参数 formData 遵守的一个协议方法 <code>appendPartWithFileURL: ...</code>。下面开始查看创建 MutableURLRequest 的方法实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *)multipartFormRequestWithMethod:(NSString *)method</span><br><span class="line">                                              URLString:(NSString *)URLString</span><br><span class="line">                                             parameters:(NSDictionary *)parameters</span><br><span class="line">                              constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                                                  error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    // 0.过滤不符合要求的情况</span><br><span class="line">    NSParameterAssert(method);</span><br><span class="line">    NSParameterAssert(![method isEqualToString:@&quot;GET&quot;] &amp;&amp; ![method isEqualToString:@&quot;HEAD&quot;]);</span><br><span class="line"></span><br><span class="line">    // 1.创建 mutableRequest</span><br><span class="line">    NSMutableURLRequest *mutableRequest = [self requestWithMethod:method URLString:URLString parameters:nil error:error];</span><br><span class="line"></span><br><span class="line">    // 2.构建 formData</span><br><span class="line">    __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">    if (parameters) &#123;</span><br><span class="line">        for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">            NSData *data = nil;</span><br><span class="line">            if ([pair.value isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">                data = pair.value;</span><br><span class="line">            &#125; else if ([pair.value isEqual:[NSNull null]]) &#123;</span><br><span class="line">                data = [NSData data];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                data = [[pair.value description] dataUsingEncoding:self.stringEncoding];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (data) &#123;</span><br><span class="line">                [formData appendPartWithFormData:data name:[pair.field description]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.执行外部传入的 block</span><br><span class="line">    if (block) &#123;</span><br><span class="line">        block(formData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4.返回最终处理完的 request</span><br><span class="line">    return [formData requestByFinalizingMultipartFormData];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概内容见上方代码注释，下面我们讨论一下细节部分。</p>
<p>1.创建 mutableRequest 的方法实现及注释如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)method</span><br><span class="line">                                 URLString:(NSString *)URLString</span><br><span class="line">                                parameters:(id)parameters</span><br><span class="line">                                     error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    // 0.检测 method、URLString 是否为空</span><br><span class="line">    NSParameterAssert(method);</span><br><span class="line">    NSParameterAssert(URLString);</span><br><span class="line"></span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line">    NSParameterAssert(url);    </span><br><span class="line"></span><br><span class="line">    // 1.开始创建（系统方法创建）</span><br><span class="line">    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];</span><br><span class="line">    </span><br><span class="line">    // 2.设置参数</span><br><span class="line">    // 2.1 请求方法</span><br><span class="line">    mutableRequest.HTTPMethod = method; // 方法默认是 “GET”</span><br><span class="line"></span><br><span class="line">    // 2.2 为 request 设置其一些默认参数</span><br><span class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        </span><br><span class="line">        // AFHTTPRequestSerializerObservedKeyPaths()：AFHTTPRequestSerializer 的 6个属性对应 getter 方法名 string 组成的数组</span><br><span class="line">        // self.mutableObservedChangedKeyPaths 中是 值非nil 的属性名</span><br><span class="line">        // requstSerializer 初始化时，创建了 self.mutableObservedChangedKeyPaths 这个空 mutableSet，然后，如果设置了对应的参数，它里边就会加上对应的属性名</span><br><span class="line">        </span><br><span class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.对参数进行序列化，与第一种方法调用的是相同的方法，不过多介绍</span><br><span class="line">    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">	return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.构建 <code>AFStreamingMultipartFormData *</code> 类型的 formData，并为其添加数据。下面是它的几个重要方法：</p>
<p>AFStreamingMultipartFormData 是一个用于给 request 设置数据的类。通过初始化方法 <code>initWithURLRequest: stringEncoding:</code> ，将 request 赋值给 AFStreamingMultipartFormData 内部的 copy 属性 request，用于后边的处理及最终返回，。</p>
<p>formData 遵守协议 AFMultipartFormData，当然要实现其中的一些协议方法了，几个重要的方法 (协议方法和非协议方法) 实现见下方代码片段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// AFStreamingMultipartFormData : NSObject &lt;AFMultipartFormData&gt;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithURLRequest:(NSMutableURLRequest *)urlRequest</span><br><span class="line">                    stringEncoding:(NSStringEncoding)encoding</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self.request = urlRequest;</span><br><span class="line">    self.stringEncoding = encoding;</span><br><span class="line">    self.boundary = AFCreateMultipartFormBoundary();</span><br><span class="line">    self.bodyStream = [[AFMultipartBodyStream alloc] initWithStringEncoding:encoding];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)appendPartWithFormData:(NSData *)data</span><br><span class="line">                          name:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(name);</span><br><span class="line"></span><br><span class="line">    NSMutableDictionary *mutableHeaders = [NSMutableDictionary dictionary];</span><br><span class="line">    [mutableHeaders setValue:[NSString stringWithFormat:@&quot;form-data; name=\&quot;%@\&quot;&quot;, name] forKey:@&quot;Content-Disposition&quot;];</span><br><span class="line"></span><br><span class="line">    [self appendPartWithHeaders:mutableHeaders body:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)appendPartWithHeaders:(NSDictionary *)headers</span><br><span class="line">                         body:(NSData *)body</span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(body);</span><br><span class="line"></span><br><span class="line">    AFHTTPBodyPart *bodyPart = [[AFHTTPBodyPart alloc] init];</span><br><span class="line">    bodyPart.stringEncoding = self.stringEncoding;</span><br><span class="line">    bodyPart.headers = headers;</span><br><span class="line">    bodyPart.boundary = self.boundary;</span><br><span class="line">    bodyPart.bodyContentLength = [body length];</span><br><span class="line">    bodyPart.body = body;</span><br><span class="line"></span><br><span class="line">    [self.bodyStream appendHTTPBodyPart:bodyPart];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMutableURLRequest *)requestByFinalizingMultipartFormData &#123;</span><br><span class="line">    if ([self.bodyStream isEmpty]) &#123;</span><br><span class="line">        return self.request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Reset the initial and final boundaries to ensure correct Content-Length</span><br><span class="line">    [self.bodyStream setInitialAndFinalBoundaries];</span><br><span class="line">    [self.request setHTTPBodyStream:self.bodyStream];</span><br><span class="line"></span><br><span class="line">    [self.request setValue:[NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;, self.boundary] forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line">    [self.request setValue:[NSString stringWithFormat:@&quot;%llu&quot;, [self.bodyStream contentLength]] forHTTPHeaderField:@&quot;Content-Length&quot;];</span><br><span class="line"></span><br><span class="line">    return self.request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，其中用到了 AFMultipartBodyStream 和 AFHTTPBodyPart 这 2 个类，其中 AFMultipartBodyStream 继承自 NSInputStream，将会作为参数传给 request。而 AFHTTPBodyPart 用于构造分段数据，并传递给 AFMultipartBodyStream。下边是 2 者的部分方法实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// AFMultipartBodyStream : NSInputStream &lt;NSStreamDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (readwrite, nonatomic, strong) NSMutableArray *HTTPBodyParts;</span><br><span class="line"></span><br><span class="line">// 添加 part</span><br><span class="line">- (void)appendHTTPBodyPart:(AFHTTPBodyPart *)bodyPart &#123;</span><br><span class="line">    [self.HTTPBodyParts addObject:bodyPart];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对所有的 part 组成的数组进行处理：第一个 part 的 hasInitialBoundary = YES，最后一个 part 的 hasFinalBoundary = YES，其他 part 的这两个属性s都是 NO。</span><br><span class="line">// 这个在计算分段大小的时候会用到</span><br><span class="line">- (void)setInitialAndFinalBoundaries &#123;</span><br><span class="line"></span><br><span class="line">    if ([self.HTTPBodyParts count] &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line">        for (AFHTTPBodyPart *bodyPart in self.HTTPBodyParts) &#123;</span><br><span class="line">            bodyPart.hasInitialBoundary = NO;</span><br><span class="line">            bodyPart.hasFinalBoundary = NO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [[self.HTTPBodyParts firstObject] setHasInitialBoundary:YES];</span><br><span class="line">        [[self.HTTPBodyParts lastObject] setHasFinalBoundary:YES];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算所有分段加起来的总数据</span><br><span class="line">- (unsigned long long)contentLength &#123;</span><br><span class="line">    unsigned long long length = 0;</span><br><span class="line">    for (AFHTTPBodyPart *bodyPart in self.HTTPBodyParts) &#123;</span><br><span class="line">        length += [bodyPart contentLength];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// AFHTTPBodyPart : NSObject</span><br><span class="line"></span><br><span class="line">// 计算每一个分段的大小</span><br><span class="line">- (unsigned long long)contentLength &#123;</span><br><span class="line">    unsigned long long length = 0;</span><br><span class="line"></span><br><span class="line">    // hasInitialBoundary 是前边 AFMultipartBodyStream 里的 setInitialAndFinalBoundaries 方法里边设置过的哦</span><br><span class="line">    NSData *encapsulationBoundaryData = [([self hasInitialBoundary] ? AFMultipartFormInitialBoundary(self.boundary) : AFMultipartFormEncapsulationBoundary(self.boundary)) dataUsingEncoding:self.stringEncoding];</span><br><span class="line">    length += [encapsulationBoundaryData length];</span><br><span class="line"></span><br><span class="line">    NSData *headersData = [[self stringForHeaders] dataUsingEncoding:self.stringEncoding];</span><br><span class="line">    length += [headersData length];</span><br><span class="line"></span><br><span class="line">    length += _bodyContentLength;</span><br><span class="line"></span><br><span class="line">    // hasFinalBoundary 也是前边设置过的</span><br><span class="line">    NSData *closingBoundaryData = ([self hasFinalBoundary] ? [AFMultipartFormFinalBoundary(self.boundary) dataUsingEncoding:self.stringEncoding] : [NSData data]);</span><br><span class="line">    length += [closingBoundaryData length];</span><br><span class="line"></span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.执行 block ，其实也是在给 formData 添加数据，block 的实现中必须调用 AFMultipartFormData 中的协议方法。</p>
<p>4.返回结果时，调用了 formData 自己的方法 <code>requestByFinalizingMultipartFormData</code>（非协议方法），即为 request 的相关字段赋值，并将其返回。</p>
<p>最后，我们以这些类之间的关系图最为本部分的小结：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-5657873419b4799f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFURLRequestSerialization.png"></p>
<h4 id="2-AFURLResponseSerialization"><a href="#2-AFURLResponseSerialization" class="headerlink" title="2. AFURLResponseSerialization"></a>2. AFURLResponseSerialization</h4><p>如前文所述，AFURLResponseSerialization 即是协议名称，又是文件名。之前在讨论 NSURLSessionTaskDelegate 的代理方法 <code>- (void)URLSession:(__unused NSURLSession *)session               task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error;</code> 时有这样一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// AFURLSessionManagerTaskDelegate（Class）</span><br><span class="line"></span><br><span class="line">// *** 使用 responseSerializer 处理返回结果</span><br><span class="line">responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">// AFURLSessionManager（Class）</span><br><span class="line">self.responseSerializer = [AFJSONResponseSerializer serializer];</span><br></pre></td></tr></table></figure>

<p>我们知道，这里的 manager 指的是 AFURLSessionManager，在其 init() 方法中初始化了一个重要属性 responseSerializer。那么 AFURLResponseSerialization 这个文件里边到底有哪些类，他们之间的关系又是怎样的？</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-25fe8586040d3a11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFURLResponseSerialization.png"></p>
<p>从上图可以发现，这里有一个重要的基类 AFHTTPResponseSerializer，他遵守 AFURLResponseSerialization 这个协议 (只有一个协议方法：<code>- (id)responseObjectForResponse:(NSURLResponse *)response data:(NSData *)data error:(NSError *__autoreleasing *)error;</code>)，其它几个类都是他的子类，他们都各自实现了该协议方法 ，用来处理接口返回的数据。</p>
<p>下面我们从基类 AFHTTPResponseSerializer 开始讨论，下面是它的头文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@interface AFHTTPResponseSerializer : NSObject &lt;AFURLResponseSerialization&gt;</span><br><span class="line"></span><br><span class="line">// 编码方式，不过源码中已经指明 It is never used。</span><br><span class="line">@property (nonatomic, assign) NSStringEncoding stringEncoding;</span><br><span class="line">// 可接受的 HTTP 状态码</span><br><span class="line">@property (nonatomic, copy, nullable) NSIndexSet *acceptableStatusCodes;</span><br><span class="line">// 可接受的 MIME types</span><br><span class="line">@property (nonatomic, copy, nullable) NSSet &lt;NSString *&gt; *acceptableContentTypes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建及初始化方法，创建默认配置的 serializer</span><br><span class="line">- (instancetype)init;</span><br><span class="line">+ (instancetype)serializer;</span><br><span class="line"></span><br><span class="line">// 校验接口返回的指定 response 和 data，默认检查了 acceptable status code 和 content type</span><br><span class="line">- (BOOL)validateResponse:(nullable NSHTTPURLResponse *)response</span><br><span class="line">                    data:(nullable NSData *)data</span><br><span class="line">                   error:(NSError * _Nullable __autoreleasing *)error;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>上边 3 个属性中的第 1 个 stringEncoding 已经被标记为过期，即不再对接收到的数据进行解码 (decode)。acceptableStatusCodes 和 acceptableContentTypes 是两个集合（set），依次表示客户端可以接受的响应报文的 HTTP 状态码和 Content-Type，用于后边对响应报文 response 和 data 进行校验。</p>
<p>再来看创建及初始化方法的实现，实际重点在 init 方法中，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)serializer &#123;</span><br><span class="line">    return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];</span><br><span class="line">    self.acceptableContentTypes = nil;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即给 acceptableStatusCodes 和 acceptableContentTypes 赋初值，前者默认为从 200 到 299 之间的整数，及成功的状态码，后者默认为 nil，也就是说接收任何类型 (Content-Type) 的响应数据。</p>
<p>现在来看开头提的解析数据的方法：<code>- (id)responseObjectForResponse: data: error:</code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - AFURLResponseSerialization</span><br><span class="line"></span><br><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];</span><br><span class="line"></span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其实是 AFURLResponseSerialization 规定的协议方法，首先校验了返回的 response 和 data，如果出错，就将错误信息写入 error。最后将 data 返回。用于校验的方法实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateResponse:(NSHTTPURLResponse *)response</span><br><span class="line">                    data:(NSData *)data</span><br><span class="line">                   error:(NSError * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    BOOL responseIsValid = YES;</span><br><span class="line">    NSError *validationError = nil;</span><br><span class="line"></span><br><span class="line">    // 1.response 是 HTTP 响应报文的情况</span><br><span class="line">    if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</span><br><span class="line">        </span><br><span class="line">        // 2.ContentType 不符的情况</span><br><span class="line">        if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class="line">            !([response MIMEType] == nil &amp;&amp; [data length] == 0)) &#123;</span><br><span class="line"></span><br><span class="line">            if ([data length] &gt; 0 &amp;&amp; [response URL]) &#123;</span><br><span class="line">                </span><br><span class="line">                NSMutableDictionary *mutableUserInfo = [@&#123;</span><br><span class="line">                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: unacceptable content-type: %@&quot;, @&quot;AFNetworking&quot;, nil), [response MIMEType]],</span><br><span class="line">                                                          NSURLErrorFailingURLErrorKey:[response URL],</span><br><span class="line">                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                                                        &#125; mutableCopy];</span><br><span class="line">                if (data) &#123;</span><br><span class="line">                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            responseIsValid = NO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2.StatusCode 不符的情况</span><br><span class="line">        if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class="line">            NSMutableDictionary *mutableUserInfo = [@&#123;</span><br><span class="line">                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: %@ (%ld)&quot;, @&quot;AFNetworking&quot;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],</span><br><span class="line">                                               NSURLErrorFailingURLErrorKey:[response URL],</span><br><span class="line">                                               AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                                       &#125; mutableCopy];</span><br><span class="line"></span><br><span class="line">            if (data) &#123;</span><br><span class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);</span><br><span class="line"></span><br><span class="line">            responseIsValid = NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.保存错误信息-有错误信息并且response不符合要求的情况</span><br><span class="line">    if (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line">        *error = validationError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4.返回</span><br><span class="line">    return responseIsValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看起来有点长，实际做的事情比较少，首先判断响应的报文是否是 HTTP 的响应报文，如果不是，直接返回 responseIsValid （此时为 YES），如果是 HTTP 报文时才会进行接下来的判断。接着分别判断 StatusCode 和 ContentType 是否符合要求，如果不符合要求，则构建相应的 validationError 信息，并将 responseIsValid 置为 NO。</p>
<p>当 error 存在，并且 responseIsValid 为 NO 时，将 validationError 赋值给 error。最后返回校验结果。</p>
<p>至于 AFHTTPResponseSerializer 的子类，我们就只看一下 AFJSONResponseSerializer，其他子类与之类似，就不多做介绍了。</p>
<p>AFJSONResponseSerializer 是专门用于解析 JSON 格式的响应数据的。他重写了父类的初始化方法，给 acceptableContentTypes 添加了 application&#x2F;json、text&#x2F;json、text&#x2F;javascript 这 3 中 json 相关的格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;, nil];</span><br></pre></td></tr></table></figure>

<p>同时通过两个工厂方法为属性 readingOptions 赋初值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)serializer &#123;</span><br><span class="line">    return [self serializerWithReadingOptions:(NSJSONReadingOptions)0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)serializerWithReadingOptions:(NSJSONReadingOptions)readingOptions &#123;</span><br><span class="line">    AFJSONResponseSerializer *serializer = [[self alloc] init];</span><br><span class="line">    serializer.readingOptions = readingOptions;</span><br><span class="line"></span><br><span class="line">    return serializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，重写了解析数据的方法 (如下)，先是和父类一样校验了 ContentType 和 StatusCode，然后反序列化拿到的响应数据，过滤掉反序列化后的数据中的 value 为 Null 的数据，最后将处理完的数据返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - AFURLResponseSerialization</span><br><span class="line"></span><br><span class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</span><br><span class="line">                           data:(NSData *)data</span><br><span class="line">                          error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    // 1.调用父类方法，校验 ContentType 和 statusCode</span><br><span class="line">    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;</span><br><span class="line">        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 异常处理</span><br><span class="line">    // Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</span><br><span class="line">    // See https://github.com/rails/rails/issues/1742</span><br><span class="line">    BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:&quot; &quot; length:1]];</span><br><span class="line">    if (data.length == 0 || isSpace) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    </span><br><span class="line">    // 2.反序列化数据</span><br><span class="line">    id responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;serializationError];</span><br><span class="line">    if (!responseObject)</span><br><span class="line">    &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 3.移除 value 为 Null 的 键值对</span><br><span class="line">    if (self.removesKeysWithNullValues) &#123;</span><br><span class="line">        return AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是构建及序列化请求参数的 AFHTTPRequestSerializer 和 处理响应数据的 AFHTTPResponseSerializer 的主要实现代码，当然还有很多细节，在此就不再多做介绍了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tsunamier/article/details/53611811">https://blog.csdn.net/tsunamier/article/details/53611811</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/tsunamier/article/details/53673751">https://blog.csdn.net/tsunamier/article/details/53673751</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/03/10/AFNetWorking-Source-Learning-04/" data-id="cl7c2jec00003lzfy5r7l9irt" data-title="AFNetWorking 源码学习笔记 ☞ Serialization" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-AFNetWorking-Source-Learning-03" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/03/02/AFNetWorking-Source-Learning-03/" class="article-date">
  <time class="dt-published" datetime="2019-03-02T13:32:01.000Z" itemprop="datePublished">2019-03-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/03/02/AFNetWorking-Source-Learning-03/">AFNetWorking 源码学习笔记 ☞ Security</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-6bf242f27828bbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking 源码学习笔记.png"></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>本文是 AFNetWorking 源码学习笔记的第三篇，本篇将介绍第二部分 – Security 目录下的类，其实只有一个就是 AFSecurityPolicy。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-309ecb42b9c3870d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking-Security.png"></p>
<h3 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h3><p>依照惯例，先从声明文件开始，打开 AFSecurityPolicy.h 文件，我们发现内容非常少，只有 4 个属性和 5 个方法。</p>
<p>首先来看看这几个属性，各自的作用见代码注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 根据 SSL 证书验证 server trust 的标准，默认为不验证。</span><br><span class="line">@property (readonly, nonatomic, assign) AFSSLPinningMode SSLPinningMode;</span><br><span class="line"></span><br><span class="line">// 根据 SSL pinning mode 验证 server trust  的证书</span><br><span class="line">@property (nonatomic, strong, nullable) NSSet &lt;NSData *&gt; *pinnedCertificates;</span><br><span class="line"></span><br><span class="line">// 是否允许无效或已经过期的 SSL 证书。</span><br><span class="line">@property (nonatomic, assign) BOOL allowInvalidCertificates;</span><br><span class="line"></span><br><span class="line">// 是否验证证书中的域名，默认为 YES。</span><br><span class="line">@property (nonatomic, assign) BOOL validatesDomainName;</span><br></pre></td></tr></table></figure>

<p>然后再来看看它提供的 5 个代理方法，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (NSSet &lt;NSData *&gt; *)certificatesInBundle:(NSBundle *)bundle;</span><br></pre></td></tr></table></figure>
<p>此类方法的作用是获取 Bundle 中的所有证书文件（xxx.cer）存放在 set 里边。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)defaultPolicy;</span><br><span class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode；</span><br><span class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(NSSet *)pinnedCertificates;</span><br></pre></td></tr></table></figure>
<p>这 3 个方法都在创建 AFSecurityPolicy 对象，第一个默认将属性 SSLPinningMode 设置为 AFSSLPinningModeNone，即不做验证；第二个可以指定 SSLPinningMode，最后一个还可以指定 pinnedCertificates。</p>
<p>下边这个实例方法负责基于当前安全策略评估传入的 serverTrust 是否可以接受，也就是我们在上一篇中接受认证挑战时掉那个的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(nullable NSString *)domain;</span><br></pre></td></tr></table></figure>

<p>接下来，我们看看 .m 文件，这里就只介绍其中的两个主要方法实现。第一个是 <code>- (void)setPinnedCertificates:(NSSet *)pinnedCertificates</code>，这里不仅给 _pinnedCertificates 赋值，而且取出了所有证书中的公钥（public key），存放到集合 self.pinnedPublicKeys 里边。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)setPinnedCertificates:(NSSet *)pinnedCertificates &#123;</span><br><span class="line">    // 1.给 _pinnedCertificates 赋值</span><br><span class="line">    _pinnedCertificates = pinnedCertificates;</span><br><span class="line"></span><br><span class="line">    // 2.给 self.pinnedPublicKeys 赋值，值是从 Certificates 中提取的 publicKeys</span><br><span class="line">    if (self.pinnedCertificates) &#123;</span><br><span class="line">        </span><br><span class="line">        NSMutableSet *mutablePinnedPublicKeys = [NSMutableSet setWithCapacity:[self.pinnedCertificates count]];</span><br><span class="line">        for (NSData *certificate in self.pinnedCertificates) &#123;</span><br><span class="line">            id publicKey = AFPublicKeyForCertificate(certificate);</span><br><span class="line">            if (!publicKey) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            [mutablePinnedPublicKeys addObject:publicKey];</span><br><span class="line">        &#125;</span><br><span class="line">        self.pinnedPublicKeys = [NSSet setWithSet:mutablePinnedPublicKeys];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        self.pinnedPublicKeys = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提取 Certificate 中的 public key 时，利用了 <code>AFPublicKeyForCertificate()</code> 这个静态函数，下面来看看它的具体实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static id AFPublicKeyForCertificate(NSData *certificate) &#123;</span><br><span class="line">    // 1.初始化会用到的局部变量</span><br><span class="line">    id allowedPublicKey = nil;</span><br><span class="line">    SecCertificateRef allowedCertificate;</span><br><span class="line">    SecPolicyRef policy = nil;</span><br><span class="line">    SecTrustRef allowedTrust = nil;</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line"></span><br><span class="line">    // 2.提取公钥</span><br><span class="line">    // ① 根据传入的二进制证书数据生成一个 SecCertificateRef 类型的证书，并验证结果</span><br><span class="line">    allowedCertificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificate);</span><br><span class="line">    __Require_Quiet(allowedCertificate != NULL, _out);</span><br><span class="line"></span><br><span class="line">    // ② 生成一个默认 X.509 policy 的实例</span><br><span class="line">    policy = SecPolicyCreateBasicX509();</span><br><span class="line">    </span><br><span class="line">    // ③ 基于证书 (allowedCertificate) 和安全策略 (policy) 创建一个信任管理对象 (a trust management object)</span><br><span class="line">    __Require_noErr_Quiet(SecTrustCreateWithCertificates(allowedCertificate, policy, &amp;allowedTrust), _out);</span><br><span class="line">    // ④ 利用步骤 ③ 创建的 allowedTrust 校验证书，并将结果写入 result，不过后边好像没有用到它</span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _out);</span><br><span class="line"></span><br><span class="line">    // ⑤ 验证通过后，从 allowedTrust 中获取公钥</span><br><span class="line">    allowedPublicKey = (__bridge_transfer id)SecTrustCopyPublicKey(allowedTrust);</span><br><span class="line"></span><br><span class="line">_out:</span><br><span class="line">    // 3.释放内存</span><br><span class="line">    if (allowedTrust) &#123;</span><br><span class="line">        CFRelease(allowedTrust);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (policy) &#123;</span><br><span class="line">        CFRelease(policy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (allowedCertificate) &#123;</span><br><span class="line">        CFRelease(allowedCertificate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return allowedPublicKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上边的代码中我们发现，重点在第 2 步获取公钥的代码，具体内容建代码注释，这里就不啰嗦了。其中用到了系统提供的 2 个宏：<code>__Require_Quiet</code> 和 <code>__Require_noErr_Quiet</code>，下边来看看他们的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __Require_Quiet</span><br><span class="line">	#define __Require_Quiet(assertion, exceptionLabel)                            \</span><br><span class="line">	  do                                                                          \</span><br><span class="line">	  &#123;                                                                           \</span><br><span class="line">		  if ( __builtin_expect(!(assertion), 0) )                                \</span><br><span class="line">		  &#123;                                                                       \</span><br><span class="line">			  goto exceptionLabel;                                                \</span><br><span class="line">		  &#125;                                                                       \</span><br><span class="line">	  &#125; while ( 0 )</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __Require_noErr_Quiet</span><br><span class="line">	#define __Require_noErr_Quiet(errorCode, exceptionLabel)                      \</span><br><span class="line">	  do                                                                          \</span><br><span class="line">	  &#123;                                                                           \</span><br><span class="line">		  if ( __builtin_expect(0 != (errorCode), 0) )                            \</span><br><span class="line">		  &#123;                                                                       \</span><br><span class="line">			  goto exceptionLabel;                                                \</span><br><span class="line">		  &#125;                                                                       \</span><br><span class="line">	  &#125; while ( 0 )</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>从定义可以看出，对于 __Require_Quiet，当入参 assertion 为空的时候，会跳转到 exceptionLabel 所在位置去继续执行；而 __Require_noErr_Quiet，是当入参 errorCode !&#x3D; 0 即出错的时候会跳转至 exceptionLabel 所在行继续执行。</p>
<h5 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h5><p>下边我们来看看 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/569e184cc9aa">上一篇</a> 提到过的方法 <code>evaluateServerTrust: forDomain:</code>，该方法是 AFNetWorking 自己提前做的一次 HTTPS 认证，用于验证服务器是否合法，如果验证不通过就不再继续调用系统方法验证了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(NSString *)domain</span><br><span class="line">&#123;</span><br><span class="line">    // 1.过滤</span><br><span class="line">    // 域名存在 &amp;&amp; 允许自签名证书 &amp;&amp; 需要验证域名 &amp;&amp; (要求不做验证 || 没有证书)</span><br><span class="line">    if (domain &amp;&amp; self.allowInvalidCertificates &amp;&amp; self.validatesDomainName &amp;&amp; (self.SSLPinningMode == AFSSLPinningModeNone || [self.pinnedCertificates count] == 0)) &#123;</span><br><span class="line">        NSLog(@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;);</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.准备安全策略，并将其设置到 serverTrust 里边，以备后边验证使用</span><br><span class="line">    NSMutableArray *policies = [NSMutableArray array];</span><br><span class="line">    if (self.validatesDomainName) &#123;</span><br><span class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateSSL(true, (__bridge CFStringRef)domain)];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [policies addObject:(__bridge_transfer id)SecPolicyCreateBasicX509()];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Sets the policies to use in an evaluation.</span><br><span class="line">    SecTrustSetPolicies(serverTrust, (__bridge CFArrayRef)policies);</span><br><span class="line"></span><br><span class="line">    // 3.再次过滤</span><br><span class="line">    if (self.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class="line">        // 不验证的情况下</span><br><span class="line">        // 如果允许自签名证书或者 serverTrust 验证成功时，返回 YES</span><br><span class="line">        return self.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class="line">    &#125; else if (!AFServerTrustIsValid(serverTrust) &amp;&amp; !self.allowInvalidCertificates) &#123;</span><br><span class="line">        // 如果 serverTrust 验证失败 &amp;&amp; 不允许自签名证书，则返回 NO</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4.验证</span><br><span class="line">    switch (self.SSLPinningMode) &#123;</span><br><span class="line">        case AFSSLPinningModeNone:</span><br><span class="line">            /**</span><br><span class="line">             *  1.不验证</span><br><span class="line">             *</span><br><span class="line">             *  但 紧上边的那个 if-else 语句已经处理了 AFSSLPinningModeNone 的情况，这里还做这个判断有意义吗？难道是是为了看起来完整。</span><br><span class="line">             */</span><br><span class="line">        default:</span><br><span class="line">            return NO;</span><br><span class="line">        case AFSSLPinningModeCertificate: &#123;</span><br><span class="line">            </span><br><span class="line">            /**</span><br><span class="line">             *  2.验证证书</span><br><span class="line">             *</span><br><span class="line">             *  从serverTrust中去获取证书链，然后和我们一开始初始化设置的证书集合self.pinnedCertificates去匹配，如果有一对能匹配成功的，就返回YES，否则NO。</span><br><span class="line">             */</span><br><span class="line">            NSMutableArray *pinnedCertificates = [NSMutableArray array];</span><br><span class="line">            for (NSData *certificateData in self.pinnedCertificates) &#123;</span><br><span class="line">                [pinnedCertificates addObject:(__bridge_transfer id)SecCertificateCreateWithData(NULL, (__bridge CFDataRef)certificateData)];</span><br><span class="line">            &#125;</span><br><span class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);</span><br><span class="line"></span><br><span class="line">            if (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">                return NO;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&#x27;s the Root CA)</span><br><span class="line">            NSArray *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            </span><br><span class="line">            for (NSData *trustChainCertificate in [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">                if ([self.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class="line">                    return YES;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">        case AFSSLPinningModePublicKey: &#123;</span><br><span class="line">            </span><br><span class="line">            /**</span><br><span class="line">             *  3.验证公钥</span><br><span class="line">             *</span><br><span class="line">             *  从serverTrust，获取证书链每一个证书的公钥，放到数组中。和我们的self.pinnedPublicKeys，去配对，如果有一个相同的，就返回YES，否则NO。</span><br><span class="line">             */</span><br><span class="line">            NSUInteger trustedPublicKeyCount = 0;</span><br><span class="line">            NSArray *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line">            for (id trustChainPublicKey in publicKeys) &#123;</span><br><span class="line">                for (id pinnedPublicKey in self.pinnedPublicKeys) &#123;</span><br><span class="line">                    if (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">                        trustedPublicKeyCount += 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return trustedPublicKeyCount &gt; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码稍微有点长，不过主要做了这些事：</p>
<ul>
<li>过滤一些特殊情况：域名存在 &amp;&amp; 允许自签名证书 &amp;&amp; 需要验证域名 &amp;&amp; (要求不做验证 || 没有证书)；</li>
<li>准备安全策略，并将其设置到 serverTrust 里边，以备后边验证使用；</li>
<li>再次过滤：不验证、serverTrust 验证失败 &amp;&amp; 不允许自签名证书 的情况；</li>
<li>开始验证，根据 self.SSLPinningMode 分成了几种情况分别验证：<ul>
<li>1.不验证</li>
<li>2.验证证书</li>
<li>3.验证公钥</li>
</ul>
</li>
</ul>
<p>这一步的验证中又用到了几个静态函数，下边来简单看一下。</p>
<ul>
<li>验证serverTrust 是否有效，调用了系统方法 SecTrustEvaluate() 进行校验。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static BOOL AFServerTrustIsValid(SecTrustRef serverTrust) &#123;</span><br><span class="line">    BOOL isValid = NO;</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _out);</span><br><span class="line"></span><br><span class="line">    // 只有当 &quot;用户未指定验证的策略，即使用系统提供的默认策略&quot; 或者 &quot;要求永远信任&quot; 的时候，才会返回 YES，其他时候都是 NO。</span><br><span class="line">    isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</span><br><span class="line"></span><br><span class="line">_out:</span><br><span class="line">    return isValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>取出 serverTrust 里边的所有证书，将其二进制文件组成的数组返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static NSArray * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount];</span><br><span class="line"></span><br><span class="line">    for (CFIndex i = 0; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        [trustChain addObject:(__bridge_transfer NSData *)SecCertificateCopyData(certificate)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [NSArray arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>取出 serverTrust 里边的所有证书，然后遍历证书取出其中的 public key，将公钥组成的数组返回。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static NSArray * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    SecPolicyRef policy = SecPolicyCreateBasicX509();</span><br><span class="line">    CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    NSMutableArray *trustChain = [NSMutableArray arrayWithCapacity:(NSUInteger)certificateCount];</span><br><span class="line">    for (CFIndex i = 0; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line"></span><br><span class="line">        SecCertificateRef someCertificates[] = &#123;certificate&#125;;</span><br><span class="line">        CFArrayRef certificates = CFArrayCreate(NULL, (const void **)someCertificates, 1, NULL);</span><br><span class="line"></span><br><span class="line">        SecTrustRef trust;</span><br><span class="line">        __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &amp;trust), _out);</span><br><span class="line"></span><br><span class="line">        SecTrustResultType result;</span><br><span class="line">        __Require_noErr_Quiet(SecTrustEvaluate(trust, &amp;result), _out);</span><br><span class="line"></span><br><span class="line">        [trustChain addObject:(__bridge_transfer id)SecTrustCopyPublicKey(trust)];</span><br><span class="line"></span><br><span class="line">    _out:</span><br><span class="line">        if (trust) &#123;</span><br><span class="line">            CFRelease(trust);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (certificates) &#123;</span><br><span class="line">            CFRelease(certificates);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    CFRelease(policy);</span><br><span class="line"></span><br><span class="line">    return [NSArray arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上就是安全验证过程中会使用到的类 AFSecurityPolicy 中的主要内容，其他部分本文暂不做过多讨论，以后有时间再更新吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/03/02/AFNetWorking-Source-Learning-03/" data-id="cl7c2jebx0000lzfya1ic82qv" data-title="AFNetWorking 源码学习笔记 ☞ Security" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-AFNetWorking-Source-Learning-02" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/02/23/AFNetWorking-Source-Learning-02/" class="article-date">
  <time class="dt-published" datetime="2019-02-23T15:00:10.000Z" itemprop="datePublished">2019-02-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/02/23/AFNetWorking-Source-Learning-02/">AFNetWorking 源码学习笔记 ☞ NSURLSession</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-6bf242f27828bbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking 源码学习笔记.png"></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>本文是 AFNetWorking 源码学习笔记的第二篇，从本篇开始每次介绍四个部分中的一个，按顺序先介绍第一部分 – NSURLSession 目录下的两个关键类 AFHTTPSessionManager 和 AFURLSessionManager。</p>
<p>注：标题容易让人误解，其实指的是 AFNetWorking 源码中的 NSURLSession 目录，而不是真的 NSURLSession 这个类。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-8eac5a9ae89af994.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking-NSURLSession.png"></p>
<h3 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h3><p>我们从整个框架对外的最直接接口 AFHTTPSessionManager.h 文件开始查看，此文件主要分三部分：</p>
<h5 id="第一部分：4个基本属性："><a href="#第一部分：4个基本属性：" class="headerlink" title="第一部分：4个基本属性："></a>第一部分：4个基本属性：</h5><p>①baseURL：顾名思义，基础的 URL ，对于同一个 App，通常情况下，请求 url 的前半部分都是相同的，将这一部分赋值给 baseURL，发送请求时就可以使用相对路径了。<br>②requestSerializer：请求的序列化类，负责拼接参数，及对参数的编码。<br>③responseSerializer：负责对请求结果的处理，<br>④securityPolicy：安全策略类，负责对服务器证书的内部验证，即在 AFNetWorking 内部先进行一次验证。</p>
<h5 id="第二部分：创建及初始化方法"><a href="#第二部分：创建及初始化方法" class="headerlink" title="第二部分：创建及初始化方法"></a>第二部分：创建及初始化方法</h5><p>虽然提供了3种看似不同的创建及初始化方法(见下方代码)，实际上前两者只是对后者不同程度的封装，最终都是调用了最后一个参数最多的初始化方法。</p>
<p>AFHTTPSessionManager.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 并非单例，从方法名就可以看出来</span><br><span class="line">+ (instancetype)manager;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url</span><br><span class="line">           sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</span><br></pre></td></tr></table></figure>

<p>AFHTTPSessionManager.m</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// *** 初始化 最终都调用的是这个方法</span><br><span class="line">- (instancetype)initWithBaseURL:(NSURL *)url</span><br><span class="line">           sessionConfiguration:(NSURLSessionConfiguration *)configuration</span><br><span class="line">&#123;</span><br><span class="line">    // 0.调用父类初始化方法</span><br><span class="line">    self = [super initWithSessionConfiguration:configuration];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1.调整 url, 确保 NSURL 的 +URLWithString:relativeToURL:  方法能够正常调用</span><br><span class="line">    if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:@&quot;&quot;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.初始化本类的属性</span><br><span class="line">    self.baseURL = url;</span><br><span class="line">    self.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步就是调用父类（AFURLSessionManager）的 initWithSessionConfiguration: 方法初始化，然后才是初始化自己的属性，点开父类方法看看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// *** init 子类初始化时会通过 super 调用😎</span><br><span class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化 configuration，如果为空，则使用默认，即 defaultSessionConfiguration，默认配置使用的是持久化的硬盘缓存，存储证书到用户 keychain，存储 cookie 到 shareCookie。</span><br><span class="line">    if (!configuration) &#123;</span><br><span class="line">        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    self.sessionConfiguration = configuration;</span><br><span class="line"></span><br><span class="line">    // 创建 delegate 所在的操作队列，因为 maxConcurrentOperationCount = 1，所以此处是串行队列，如果 &gt; 1，则为并发队列。</span><br><span class="line">    self.operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    self.operationQueue.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  初始化 session</span><br><span class="line">     *  用于后边创建各种 task，这里设置了 delegate、operationQueue 和 sessionConfiguration</span><br><span class="line">     *  注意1: 这个 delegate 是 readonly，只能通过初始化方法设置；</span><br><span class="line">     *  注意2: self.operationQueue 默认是串行队列；</span><br><span class="line">     *  注意3: self.sessionConfiguration 默认取 defaultSessionConfiguration。</span><br><span class="line">     */</span><br><span class="line">    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br><span class="line"></span><br><span class="line">    // 用于对接口返回结果的处理 - 下一篇详细说明</span><br><span class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    // 设置默认的安全策略类</span><br><span class="line">    self.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">    // 如果是 Apple Watch，则不需要初始化 reachabilityManager</span><br><span class="line">#if !TARGET_OS_WATCH</span><br><span class="line">    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // 存放 task.idenfier 与其 delegate 组成的键值对，用于将系统提供的代理方法转发给其 delegate</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];</span><br><span class="line"></span><br><span class="line">    // 初始化锁 🔐</span><br><span class="line">    self.lock = [[NSLock alloc] init];</span><br><span class="line">    self.lock.name = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  理论上，在初始化的时候，应该是还没有创建 task 的。</span><br><span class="line">     *</span><br><span class="line">     *  一个代码贡献者给出的解释是 I believe this for restoring a session from the background. 即 为从后台恢复一个 session 的情况准备的，将其代理的所有回调全都置为 nil。</span><br><span class="line">     *  详见：https://github.com/AFNetworking/AFNetworking/issues/3499</span><br><span class="line">     */</span><br><span class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</span><br><span class="line">        for (NSURLSessionDataTask *task in dataTasks) &#123;</span><br><span class="line">            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123;</span><br><span class="line">            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123;</span><br><span class="line">            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="第三部分：核心-发送请求的方法"><a href="#第三部分：核心-发送请求的方法" class="headerlink" title="第三部分：核心 - 发送请求的方法"></a>第三部分：核心 - 发送请求的方法</h5><p>细数 AFHTTPSessionManager 中提供的一系列发送请求的方法，可以发现，其实主要可以分为两大类：一类是普通的 GET&#x2F;POST&#x2F;HEAD&#x2F;PUT&#x2F;PATCH&#x2F;DELETE 方法，另一类是包含复合结构 request 的 POST 请求方法。</p>
<h6 id="第一类方法"><a href="#第一类方法" class="headerlink" title="第一类方法"></a>第一类方法</h6><p>下面我们首先从第一类方法开始讨论，主要有以下几个方法，此处做了简化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSURLSessionDataTask *)GET: parameters: success: failure: DEPRECATED_ATTRIBUTE</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)GET: parameters: progress: success: failure:</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)HEAD: parameters: success: failure:</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)POST: parameters: success: failure: DEPRECATED_ATTRIBUTE</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)POST: parameters: progress: success: failure:</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)PUT: parameters: success: failure:</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)PATCH: parameters: success: failure:</span><br><span class="line"></span><br><span class="line">- (nullable NSURLSessionDataTask *)DELETE: parameters: success: failure:</span><br></pre></td></tr></table></figure>

<p>这些方法的实现类似，都是调用了同一个方法创建 task，只不过传入的 method 不同而已，然后 resume 这个 task。如下边的这个 GET 方法所示，其他方法，只是将 GET 换成了对应 POST、HEAD 等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)GET:(NSString *)URLString</span><br><span class="line">                   parameters:(id)parameters</span><br><span class="line">                     progress:(void (^)(NSProgress * _Nonnull))downloadProgress</span><br><span class="line">                      success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success</span><br><span class="line">                      failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure</span><br><span class="line">&#123;</span><br><span class="line">    // 1.创建任务</span><br><span class="line">    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot;</span><br><span class="line">                                                        URLString:URLString</span><br><span class="line">                                                       parameters:parameters</span><br><span class="line">                                                   uploadProgress:nil</span><br><span class="line">                                                 downloadProgress:downloadProgress</span><br><span class="line">                                                          success:success</span><br><span class="line">                                                          failure:failure];</span><br><span class="line">    // 2.启动任务</span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个创建方法 dataTaskWithHTTPMethod: … 最终做了 2 件事：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// *** 构建 NSURLSessionDataTask</span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</span><br><span class="line">                                       URLString:(NSString *)URLString</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</span><br><span class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</span><br><span class="line">&#123;</span><br><span class="line">    // 1. 构建 NSMutableURLRequest，实际调用 requestSerializer 中创建 request 的方法</span><br><span class="line">    // 因为 NSURLRequest 的属性都是 readonly，所以此处构建了 NSMutableURLRequest。</span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method</span><br><span class="line">                                                                   URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString]</span><br><span class="line">                                                                  parameters:parameters</span><br><span class="line">                                                                       error:&amp;serializationError];</span><br><span class="line">    // 构建失败的处理</span><br><span class="line">    if (serializationError) &#123;</span><br><span class="line">        if (failure) &#123;</span><br><span class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(nil, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2. 构建 NSURLSessionDataTask：实际调用父类 AFURLSessionManager 的方法</span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    dataTask = [self dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</span><br><span class="line">                           if (error) &#123;</span><br><span class="line">                               if (failure) &#123;</span><br><span class="line">                                   failure(dataTask, error);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125; else &#123;</span><br><span class="line">                               if (success) &#123;</span><br><span class="line">                                   success(dataTask, responseObject);</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;];</span><br><span class="line">    </span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.调用 AFHTTPRequestSerializer 的 requestWithMethod: URLString: parameters: error: 方法创建 mutableURLRequest；</p>
<p>2.利用 父类即 AFURLSessionManager 的 dataTaskWithRequest: uploadProgress: downloadProgress: completionHandler: 创建 task（需要上一步得到的 mutableURLRequest 做参数）。</p>
<p>AFHTTPRequestSerializer 中的方法主要做了一些拼接参数及编码的工作，留待<a href="">下一篇</a>介绍。这里来看看 AFURLSessionManager 中的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建Task(同时修复iOS8以下系统出现的Bug)</span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [self.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 2.为 task 添加代理</span><br><span class="line">[self addDelegateForDataTask:dataTask</span><br><span class="line">              uploadProgress:uploadProgressBlock</span><br><span class="line">            downloadProgress:downloadProgressBlock</span><br><span class="line">           completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里也做了 2 件事，见上边注释，不过，创建 dataTask 的时候使用了一个 block，点开定义发现，当 iOS 系统版本  ＜ 8.0 时，创建了一个串行队列来执行 block 中的任务。</p>
<p>这是为了防止 iOS8 以前的版本在并发队列上创建任务时，可能会调用错误的 completionHandlers。当任务返回一个重复的 taskIdentifier 时，先前的 completionHandler 被清除并替换为新的。 如果第一个请求的数据在第二个请求的数据之前返回，那么将针对第二个 completionHandler 调用第一个响应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static void url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123;</span><br><span class="line">        // Fix of bug</span><br><span class="line">        // Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span><br><span class="line">        // Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span><br><span class="line">        dispatch_sync(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static dispatch_queue_t url_session_manager_processing_queue() &#123;</span><br><span class="line">    static dispatch_queue_t af_url_session_manager_processing_queue;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_processing_queue = dispatch_queue_create(&quot;com.alamofire.networking.session.manager.processing&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return af_url_session_manager_processing_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="第二类方法"><a href="#第二类方法" class="headerlink" title="第二类方法"></a>第二类方法</h6><p>第二类方法最终调用的只有一个方法，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)POST:(NSString *)URLString</span><br><span class="line">                    parameters:(id)parameters</span><br><span class="line">     constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                      progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress</span><br><span class="line">                       success:(void (^)(NSURLSessionDataTask *task, id responseObject))success</span><br><span class="line">                       failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    // 1.创建 request</span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@&quot;POST&quot; URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError];</span><br><span class="line">    if (serializationError) &#123;</span><br><span class="line">        if (failure) &#123;</span><br><span class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(nil, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.创建 task</span><br><span class="line">    __block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            if (failure) &#123;</span><br><span class="line">                failure(task, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                success(task, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3.启动任务</span><br><span class="line">    [task resume];</span><br><span class="line"></span><br><span class="line">    return task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本步骤与第一类方法类似，只不过创建 request 和 task 的方法不一样，对于 request 的创建方法留待<a href="">下一篇</a>介绍，这里我们看看创建 dataTask 的方法有什么不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request</span><br><span class="line">                                                 progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                                        completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block NSURLSessionUploadTask *uploadTask = nil;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        uploadTask = [self.session uploadTaskWithStreamedRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [self addDelegateForUploadTask:uploadTask progress:uploadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return uploadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来是其中创建 task 的方法 uploadTaskWithStreamedRequest: 不同，生成的是 NSURLSessionUploadTask 类型，之后设置代理的方法与第一类方法类似。</p>
<p>注意：其实理论上应该还有第 3 类请求方法，即下载的请求，不过 AFHTTPSessionManager 里边并未封装，而只是在它的父类里边提供了创建 downloadTask 的方法，比如下边的。也是创建 task 使用的系统方法不同，其他类似。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                                             progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                                          destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</span><br><span class="line">                                    completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block NSURLSessionDownloadTask *downloadTask = nil;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        downloadTask = [self.session downloadTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [self addDelegateForDownloadTask:downloadTask progress:downloadProgressBlock destination:destination completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return downloadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在分别介绍完了 2 类发送请求的方法，下边我们看看为 task 添加代理的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class="line">    delegate.manager = self;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</span><br><span class="line">    // 保存 task 和 delegate 的映射关系，并添加对任务开始和暂停的监听</span><br><span class="line">    [self setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建了一个代理对象（AFURLSessionManagerTaskDelegate），在这个 task 中对请求过程进行处理；设置完代理的属性之后，才调用 setDelegate: forTask: 方法来为 task 及代理添加关联。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(NSURLSessionTask *)task</span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line">    NSParameterAssert(delegate);</span><br><span class="line"></span><br><span class="line">    [self.lock lock];</span><br><span class="line">    // 以 taskIdentifier 为 key，将 delegate 存储在一个字典(self.mutableTaskDelegatesKeyedByTaskIdentifier)里</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    // 添加对任务开始和暂停的监听</span><br><span class="line">    [self addNotificationObserverForTask:task];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是保存 task 和 代理之间的映射关系，保存在之前已经创建好的字典 mutableTaskDelegatesKeyedByTaskIdentifier 里边，并为 task 添加通知，监听了 task resume 和 suspend 两个状态。然后我们发现当状态发生改变的时候，实际上只是在主队列又发送了 2 中通知，只是改了个名字而已。全局搜索新的通知名后发现，只有在 UIKit 那个目录下的类里边才会用到。</p>
<p>然后看看代理类 AFURLSessionManagerTaskDelegate，从他的初始化方法开始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 1.存放下载的数据</span><br><span class="line">    _mutableData = [NSMutableData data];</span><br><span class="line">    </span><br><span class="line">    //  2.创建并初始化上传及下载进度 _uploadProgress 和 _downloadProgress</span><br><span class="line">   _uploadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil];</span><br><span class="line">    _downloadProgress = [[NSProgress alloc] initWithParent:nil userInfo:nil];</span><br><span class="line">    </span><br><span class="line">    __weak __typeof__(task) weakTask = task;</span><br><span class="line">    for (NSProgress *progress in @[ _uploadProgress, _downloadProgress ])</span><br><span class="line">    &#123;</span><br><span class="line">        progress.totalUnitCount = NSURLSessionTransferSizeUnknown;</span><br><span class="line">        </span><br><span class="line">        progress.cancellable = YES; // 可以取消</span><br><span class="line">        progress.cancellationHandler = ^&#123;</span><br><span class="line">            [weakTask cancel];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        progress.pausable = YES; // 可以暂停</span><br><span class="line">        progress.pausingHandler = ^&#123;</span><br><span class="line">            [weakTask suspend];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        // 恢复</span><br><span class="line">#if AF_CAN_USE_AT_AVAILABLE</span><br><span class="line">        if (@available(iOS 9, macOS 10.11, *))</span><br><span class="line">#else</span><br><span class="line">        if ([progress respondsToSelector:@selector(setResumingHandler:)])</span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            progress.resumingHandler = ^&#123;</span><br><span class="line">                [weakTask resume];</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 给 progress 添加监听</span><br><span class="line">        [progress addObserver:self</span><br><span class="line">                   forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</span><br><span class="line">                      options:NSKeyValueObservingOptionNew</span><br><span class="line">                      context:NULL];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上边的代码可以看到，就做了 2 件事：</p>
<ul>
<li>创建存放下载的数据的可变数组 _mutableData；</li>
<li>创建用于存储上传及下载进度的对象 _uploadProgress 和 _downloadProgress，并为其添加 KVO 监听。<br>查看了 KVO 对应的 <code>observeValueForKeyPath:</code> 方法实现后，发现只是将最新的下载或上传进度回传给了对应的 block。当然，会在 dealloc 方法中移除监听，否则会 Crash。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    </span><br><span class="line">   if ([object isEqual:self.downloadProgress]) &#123; // 下载进度</span><br><span class="line">        if (self.downloadProgressBlock) &#123;</span><br><span class="line">            self.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ([object isEqual:self.uploadProgress]) &#123; // 上传进度</span><br><span class="line">        if (self.uploadProgressBlock) &#123;</span><br><span class="line">            self.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是一些代理方法了，他们都是从 AFURLSessionManager 里边的代理方法转发过来的，后边再作介绍吧。</p>
<p>回到 AFURLSessionManager.m 中，前边都是在请求发送之前做的准备工作，现在我们来看看发起请求之后的情况，当然是看代理方法了。</p>
<h5 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h5><p>这里的 15 个代理方法分属 4 个不同的协议：<br><code>NSURLSessionDelegate</code><br><code>NSURLSessionTaskDelegate</code><br><code>NSURLSessionDataDelegate</code><br><code>NSURLSessionDownloadDelegate</code></p>
<p>我们依次看看其中实现的协议方法：</p>
<h5 id="NSURLSessionDelegate"><a href="#NSURLSessionDelegate" class="headerlink" title="NSURLSessionDelegate"></a>NSURLSessionDelegate</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 当 session 失效时调用</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didBecomeInvalidWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    if (self.sessionDidBecomeInvalid) &#123;</span><br><span class="line">        self.sessionDidBecomeInvalid(session, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如何接受授权挑战，如果此方法未实现，会调用后边 NSURLSessionTaskDelegate 中的第一个代理方法 URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    //  1.判断有没有自定义 block: sessionDidReceiveAuthenticationChallenge</span><br><span class="line">    if (self.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        //  2.如果没有自定义 block，判断 如果服务端要求的认证方法是不是 NSURLAuthenticationMethodServerTrust</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            </span><br><span class="line">            //  3.基于客户端的安全策略来决定是否信任该服务器</span><br><span class="line">            // *** 点开此方法</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                </span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                </span><br><span class="line">                if (credential) &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengeUseCredential; // 使用证书的 Challenge</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling; // 默认 Challenge</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge; // 取消 Challenge</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling; // 默认 Challenge</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // *** 去执行 iOS 系统的认证方案</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于第一个方法 <code>URLSession: didBecomeInvalidWithError: </code>，当 session 失效时调用此方法。官方文档给出的具体说明是，如果我们调用了  <code>finishTasksAndInvalidate</code> 方法，则会等到 session 里边最后一个 task 执行完，才会调用此代理方法；如果调用了 <code>invalidateAndCancel</code> 这个方法，则会立即执行该代理方法。</p>
<p>第 2 个代理方法是当客户端收到 “授权挑战”（姑且这么翻译吧，虽然很别扭） 时实行的方法，流程如下图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-0501a7562633de99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking认证挑战.png"></p>
<ul>
<li><p>首先，判断用户(使用者)有没有自定义 block: sessionDidReceiveAuthenticationChallenge，如果有，则执行自定义的 block 处理挑战，返回一个枚举值给 <code>disposition</code>，并给 <code>credential</code> 赋值 (因为参数是 &amp;credential) 处理，他们都将作为最后一步执行 completionhandler() 时的参数。如果没有自定义处理挑战的 block，则接着进行下一步的判断； </p>
</li>
<li><p>然后，判断服务端要求的认证方法是不是 NSURLAuthenticationMethodServerTrust。如果是，则只需要验证服务端证书是否安全（即 https 的单向认证，这是 AFNetworking 默认处理的认证方式，其他的认证方式，只能通过定义 block 来实现）。这种情况下，还需要做下一步处理；</p>
</li>
<li><p>接下来，有一个 if 判断，条件是 <code>securityPolicy</code> 调用 <code>evaluateServerTrust: forDomain:</code> 方法的执行结果，该方法实际是 AFNetWorking 自己对先做的一次 HTTPS 认证，返回结果表明该服务器是否可以信任，具体方法实现见<a href="">下一篇</a>。</p>
<ul>
<li>如果 if 条件成立，即 AFNetworking 认为服务器可信任，执行 <code>NSURLCredential</code> 的系统方法 <code>credentialForTrust:</code> 生成一个凭证或称证书 <code>credential</code>，如果成功生成，就给 <code>disposition</code> 赋相应的值。</li>
<li>如果 if 条件不成立，则取消认证。</li>
</ul>
</li>
<li><p>最后，执行 <code>completionHandler(disposition, credential)</code>，其中，<code>credential</code> 是根据服务端返回的证书及相关信息生成的用于客户端验证的对象；<code>disposition</code> 就是一个枚举值（常量），用于说明应该以何种方式处理凭证 <code>credential</code>。</p>
</li>
</ul>
<h5 id="NSURLSessionTaskDelegate"><a href="#NSURLSessionTaskDelegate" class="headerlink" title="NSURLSessionTaskDelegate"></a>NSURLSessionTaskDelegate</h5><p>这里以典型的请求结束的代理方法为例做一个简单介绍，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    // 取出 task 对应的 delegate</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    // 如果是在后台完成的任务，则此处 delegate 为 nil。</span><br><span class="line">    if (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line">        [self removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 执行 block</span><br><span class="line">    if (self.taskDidComplete) &#123;</span><br><span class="line">        self.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是在请求结束时执行的代理方法（可能成功或者失败，如果失败，error有值），调用自己的 <code>delegateForTask:</code> 方法，取出 task 对应的 delegate，如果取到了，则执行 delegate 的 <code>URLSession: task: didCompleteWithError:</code> 方法。</p>
<p>注意，实际我们最开始传到 GET、POST 等方法中的 block 都是赋值给了对应 task 的 delegate，所以真正执行那些 block 也是在转发到的 delegate(AFURLSessionManagerTaskDelegate) 的对应代理方法中，而不是上边代码最后的 block。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    __strong AFURLSessionManager *manager = self.manager;</span><br><span class="line"></span><br><span class="line">    __block id responseObject = nil;</span><br><span class="line"></span><br><span class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">    //Performance Improvement from #2672</span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    if (self.mutableData) &#123;</span><br><span class="line">        data = [self.mutableData copy];</span><br><span class="line">        //We no longer need the reference, so nil it out to gain back some memory.</span><br><span class="line">        self.mutableData = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</span><br><span class="line">    &#125; else if (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (error) &#123;    // 出错的时候</span><br><span class="line">        </span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">        // 出错时，执行完成的回调 及 发送任务结束的通知</span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">            if (self.completionHandler) &#123;</span><br><span class="line">                self.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125; else &#123;    // 正常结束的时候</span><br><span class="line">        </span><br><span class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            NSError *serializationError = nil;</span><br><span class="line">            </span><br><span class="line">            // *** 使用 responseSerializer 处理返回结果</span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            if (self.downloadFileURL) &#123;</span><br><span class="line">                responseObject = self.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 正常结束的时候，执行完成的回调 及 发送任务结束的通知</span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                </span><br><span class="line">                if (self.completionHandler) &#123;</span><br><span class="line">                    self.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细看了一下，这个方法里边就主要就为了做了  2 件事，第一件是执行 self.completionHandler()，包括请求结果的序列化将会在<a href="">下一篇</a>介绍；第二件是发送任务完成的通知，包括构建 userInfo 这个可变字典，详见代码。</p>
<p>至于其他协议及代理方法，大部分都是遵循将代理方法转发给 AFURLSessionManagerTaskDelegate 里的对应方法的逻辑，限于篇幅暂时就不做讨论了。</p>
<h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>忽然想起来，其实 AFNetWorking 的 readme.md 里边给的 4 个示例都是直接使用 AFURLSessionManager 而不是使用它的子类 AFHTTPSessionManager，难道我又说多了，哈哈。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://www.saitjr.com/ios/ios-ns_unavailable-ns_designated_initializer.html">NS_UNAVAILABLE 与 NS_DESIGNATED_INITIALIZER</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/239084afda5c">进度: NSProgress</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/02/23/AFNetWorking-Source-Learning-02/" data-id="cl7c2jebz0002lzfybyyu2y8y" data-title="AFNetWorking 源码学习笔记 ☞ NSURLSession" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-AFNetWorking-Source-Learning-01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/02/17/AFNetWorking-Source-Learning-01/" class="article-date">
  <time class="dt-published" datetime="2019-02-17T15:32:23.000Z" itemprop="datePublished">2019-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/02/17/AFNetWorking-Source-Learning-01/">AFNetWorking 源码学习笔记 ☞ 主体流程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-6bf242f27828bbcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking 源码学习笔记.png"></p>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p><a target="_blank" rel="noopener" href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a> 是使用 Objective-C 开发 iOS App 时首选的第三方网络框架，当然早期还有 ASI 的框架，不过因为长期无人维护，已很少与人使用了。本系列主要是对 AFNetWorking (3.2.1) 源码学习的一个记录，共分 5 篇进行讨论，目录如下：</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b1c9639207d2">AFNetWorking 源码学习笔记 ☞ 主体流程</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/569e184cc9aa">AFNetWorking 源码学习笔记 ☞ NSURLSession</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/77e8ab1b231e">AFNetWorking 源码学习笔记 ☞ Security</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0132afd13e24">AFNetWorking 源码学习笔记 ☞ Serialization</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/451eb3eebda7">AFNetWorking 源码学习笔记 ☞ Reachability</a></p>
<p>本文是第一篇，简要介绍一下框架结构和主体流程。</p>
<h3 id="二、框架结构"><a href="#二、框架结构" class="headerlink" title="二、框架结构"></a>二、框架结构</h3><p>为了找到一个合适的切入点，首先查看了 github 上的文档，然后根据示例写了一个粗略的 <a target="_blank" rel="noopener" href="https://github.com/riversea2015/CodeForBlogs/tree/master/HHAFNetworkingStudy">demo</a>，使用 cocoapods 导入了 AFNetWorking 之后，查看其文件结构，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-e9fbf65e04eaf59f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking-文件结构.png"></p>
<p>可以看到，除 UIKit 之外，主要分了 4 部分，各部分的主要作用如下：</p>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/569e184cc9aa">NSURLSession</a>，包括 2 个主要的类，AFHTTPSessionManager 和 AFURLSessionManager，前者提供一些对外接口，它继承自 AFURLSessionManager 这个核心类，主要的工作都在这里，包括创建及启动 task，代理方法的处理等等。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/77e8ab1b231e">Security</a>，只有一个类 AFSecurityPolicy，代码也不多，负责在系统底层认证 HTTPS 之前，AFNetWorking 自己做一次认证。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0132afd13e24">Serialization</a>，包含 2 个类，AFURLRequestSerialization 和 AFURLResponseSerialization 分别负责请求参数和接口返回结果的处理。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/451eb3eebda7">Reachability</a>，提供了一个监听网络状态的类 AFNetworkReachabilityManager，不太常用，我们一般都是用苹果提供的 Reachability 这个类，然后自己封装一下，不过需要手动将它的 .h&#x2F;.m 文件导入到工程里。</p>
</li>
</ol>
<h3 id="三、主体流程"><a href="#三、主体流程" class="headerlink" title="三、主体流程"></a>三、主体流程</h3><p>本文的 demo 创建了一个简单的网络请求，我们以此作为突破口，开始一步一步研究这个框架的基本流程。下边是自己添加的发送请求的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">#import &lt;AFNetworking/AFNetworking.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [self startLoadData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)startLoadData &#123;</span><br><span class="line">    // 1.拼接参数</span><br><span class="line">    NSString *urlString          = [[unsplash_ENDPOINT_HOST stringByAppendingString:unsplash_ENDPOINT_POPULAR] stringByAppendingString:unsplash_CONSUMER_KEY_PARAM];</span><br><span class="line">    NSUInteger nextPage          = 1;</span><br><span class="line">    NSString *imageSizeParam     = @&quot;&amp;image_size=600&quot;;</span><br><span class="line">    NSString *urlAdditions       = [NSString stringWithFormat:@&quot;&amp;page=%lu&amp;per_page=%d%@&quot;, (unsigned long)nextPage, 10, imageSizeParam];</span><br><span class="line">    NSString *URLString = [urlString stringByAppendingString:urlAdditions];</span><br><span class="line">    </span><br><span class="line">    // 2.发送请求</span><br><span class="line">    // *** 点开此处 GET 方法</span><br><span class="line">    [[AFHTTPSessionManager manager] GET:URLString parameters:urlAdditions progress:^(NSProgress * _Nonnull downloadProgress) &#123;</span><br><span class="line">        NSLog(@&quot;+++++&gt; 进行中...：%@&quot;, downloadProgress);</span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line">        NSLog(@&quot;=====&gt; 成功：%@&quot;, responseObject);</span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            NSLog(@&quot;-----&gt; 失败原因：%@&quot;, error.domain);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 GET 方法上 “command + 右键” 跳转到位于 AFHTTPSessionManager.m 文件中的方法实现（见下方代码），做了两件事：<br>①创建 dataTask；<br>②启动任务（使用 resume 可能有感觉有点怪，不过苹果文档给出的解释是，新创建的 task 是处于挂起状态的，需要使用 resume 启动任务）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)GET:(NSString *)URLString</span><br><span class="line">                   parameters:(id)parameters</span><br><span class="line">                     progress:(void (^)(NSProgress * _Nonnull))downloadProgress</span><br><span class="line">                      success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success</span><br><span class="line">                      failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure</span><br><span class="line">&#123;</span><br><span class="line">    // 1.创建任务</span><br><span class="line">    // *** 点开此方法</span><br><span class="line">    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot;</span><br><span class="line">                                                        URLString:URLString</span><br><span class="line">                                                       parameters:parameters</span><br><span class="line">                                                   uploadProgress:nil</span><br><span class="line">                                                 downloadProgress:downloadProgress</span><br><span class="line">                                                          success:success</span><br><span class="line">                                                          failure:failure];</span><br><span class="line">    // 2.启动任务</span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再点开 dataTaskWithHTTPMethod: 方法，看看他里边究竟做了什么。我们发现其实也差不多做了两件事：<br>①使用 requestSerializer 这个类创建 NSMutableURLRequest 对象；<br>②又是创建 task ，这里将 上一步得到的 request 及下载、上传的 block 作为参数传入下一层创建 task 的方法，该方法位于 AFURLSessionManager 类中，它是 AFHTTPSessionManager 的父类，主要工作都在这个类里边处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</span><br><span class="line">                                       URLString:(NSString *)URLString</span><br><span class="line">                                      parameters:(id)parameters</span><br><span class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</span><br><span class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</span><br><span class="line">&#123;</span><br><span class="line">    // 1.1 构建 NSMutableURLRequest，实际调用 requestSerializer 中创建 request 的方法</span><br><span class="line">    // 因为 NSURLRequest 的属性都是 readonly，所以此处构建了 NSMutableURLRequest。</span><br><span class="line">    NSError *serializationError = nil;</span><br><span class="line">    // *** 点开此方法</span><br><span class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method</span><br><span class="line">                                                                   URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString]</span><br><span class="line">                                                                  parameters:parameters</span><br><span class="line">                                                                       error:&amp;serializationError];</span><br><span class="line">    // 构建失败的处理</span><br><span class="line">    if (serializationError) &#123;</span><br><span class="line">        if (failure) &#123;</span><br><span class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(nil, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1.2 构建 NSURLSessionDataTask：实际调用父类 AFURLSessionManager 的方法</span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    // *** 点开此方法</span><br><span class="line">    dataTask = [self dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            if (failure) &#123;</span><br><span class="line">                failure(dataTask, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (success) &#123;</span><br><span class="line">                success(dataTask, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现这里创建 request 和 创建 task 的方法还可继续深入，先点开 requestWithMethod 方法看看，从下边的代码中可以发现，这里主要就是调用系统方法创建 NSMutableURLRequest，然后设置参数并序列化，最后将该 request 返回。</p>
<p>这里说件出糗的事，记得刚学编程的时候曾被人问过 URLRequest 是否可以发起网络请求，还信心满满的回答可以，心想 request 翻译过来可不就是请求吗 😓。简单点说，request 在这里的作用其实就是拼装参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *)requestWithMethod:(NSString *)method</span><br><span class="line">                                 URLString:(NSString *)URLString</span><br><span class="line">                                parameters:(id)parameters</span><br><span class="line">                                     error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    // 0.检测 method、URLString 是否为空</span><br><span class="line">    NSParameterAssert(method);</span><br><span class="line">    NSParameterAssert(URLString);</span><br><span class="line"></span><br><span class="line">    NSURL *url = [NSURL URLWithString:URLString];</span><br><span class="line">    NSParameterAssert(url);    </span><br><span class="line"></span><br><span class="line">    // 1.开始创建 NSMutableURLRequest，因为 NSURLRequest 的属性都是 readonly，为了能够修改，只能创建可变的了。</span><br><span class="line">    NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initWithURL:url];</span><br><span class="line">    </span><br><span class="line">    // 2.设置参数</span><br><span class="line">    mutableRequest.HTTPMethod = method;</span><br><span class="line"></span><br><span class="line">    // 为 request 设置其一些默认参数</span><br><span class="line">    // AFHTTPRequestSerializerObservedKeyPaths()：AFHTTPRequestSerializer 的 6个属性对应 get特然 的 方法名string 组成的数组</span><br><span class="line">    for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        // self.mutableObservedChangedKeyPaths 中是 值非nil 的属性名</span><br><span class="line">        // requstSerializer 初始化时，创建了 self.mutableObservedChangedKeyPaths 这个空 mutableSet，然后，如果设置了对应的参数，它里边就会加上对应的属性名</span><br><span class="line">        if ([self.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">            [mutableRequest setValue:[self valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.对参数进行序列化，并赋值给 request，另外，设置必要的 header。</span><br><span class="line">    mutableRequest = [[self requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">	return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看看这一层创建 task 的方法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 供子类调用</span><br><span class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</span><br><span class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    // 1.创建Task，同时修复iOS8以下系统出现的一个Bug</span><br><span class="line">    __block NSURLSessionDataTask *dataTask = nil;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [self.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 2.为 task 添加代理</span><br><span class="line">    // *** 点开此方法</span><br><span class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也做了 2 件事：</p>
<p>①先是 利用 session 创建 task（这是系统方法）。<br>这里用了 self.session，于是我们回到 AFURLSessionManager 的初始化方法里，查看 session 的创建过程，非常简单，只有一句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br></pre></td></tr></table></figure>
<p>这里我只关注 delegate，这说明网络请求过程中的代理方法，将会在 AFURLSessionManager 这个类里边实现。</p>
<p>②然后 为 task 添加代理。<br>添加代理的方法是将 delegate（AFURLSessionManagerTaskDelegate）和 task 的标识组成的键值对存储在当前对象中的一个字典里边，以备使用，具体实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] initWithTask:dataTask];</span><br><span class="line">    delegate.manager = self;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</span><br><span class="line">    // 保存 task 和 delegate 的对应关系到一个字典里，并添加对任务开始和暂停的监听</span><br><span class="line">    [self setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;                                         </span><br></pre></td></tr></table></figure>

<p>请求开始前的准备工作基本已经做完了，现在让我们看看请求发起后都做了什么，当然是看 AFURLSessionManager 里边的实现的代理方法了，因为代理方法较多，这里挑其中最重要的 2 个作简要介绍。</p>
<p>1.如何接受挑战</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">    __block NSURLCredential *credential = nil;</span><br><span class="line"></span><br><span class="line">    if (self.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = self.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">            if ([self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                if (credential) &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengeUseCredential;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            disposition = NSURLSessionAuthChallengePerformDefaultHandling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.请求结束成功或失败的回调</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    // delegate may be nil when completing a task in the background</span><br><span class="line">    if (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line"></span><br><span class="line">        [self removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.taskDidComplete) &#123;</span><br><span class="line">        self.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转发给了代理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - NSURLSessionTaskDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(__unused NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    __strong AFURLSessionManager *manager = self.manager;</span><br><span class="line"></span><br><span class="line">    __block id responseObject = nil;</span><br><span class="line"></span><br><span class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">    //Performance Improvement from #2672</span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    if (self.mutableData) &#123;</span><br><span class="line">        data = [self.mutableData copy];</span><br><span class="line">        //We no longer need the reference, so nil it out to gain back some memory.</span><br><span class="line">        self.mutableData = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</span><br><span class="line">    &#125; else if (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (error) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            if (self.completionHandler) &#123;</span><br><span class="line">                self.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            NSError *serializationError = nil;</span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            if (self.downloadFileURL) &#123;</span><br><span class="line">                responseObject = self.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                if (self.completionHandler) &#123;</span><br><span class="line">                    self.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><p>至此，我们大概了解了一下 AFNetWorking 工作的主体流程，简单画了个图总结一下，当然略去了很多细节，不过都将会在后边的章节继续讨论。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2208988-27f56f36213354ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AFNetWorking 主体流程.png"></p>
<h3 id="Demo及源码注释"><a href="#Demo及源码注释" class="headerlink" title="Demo及源码注释"></a>Demo及源码注释</h3><p><a target="_blank" rel="noopener" href="https://github.com/riversea2015/CodeForBlogs/tree/master/HHAFNetworkingStudy">HHAFNetworkingStudy</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/02/17/AFNetWorking-Source-Learning-01/" data-id="cl7c2jebz0001lzfy85dcebef" data-title="AFNetWorking 源码学习笔记 ☞ 主体流程" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SDWebImage-Source-Learning-05" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/02/03/SDWebImage-Source-Learning-05/" class="article-date">
  <time class="dt-published" datetime="2019-02-03T11:39:30.000Z" itemprop="datePublished">2019-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/02/03/SDWebImage-Source-Learning-05/">SDWebImage 源码学习笔记 ☞ SDImageCache</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-29157f1c1fb6719f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage-源码学习笔记.png"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是本系列的第 5 篇，也是最后一篇，主要讨论处理缓存的类 <code>SDImageCache</code> 及相关类 <code>SDMemoryCache</code> 、<code>SDImageCacheConfig</code> 等。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>先介绍 SDImageCache.h 中定义的 2 个枚举：<code>SDImageCacheType</code> 和 <code>SDImageCacheOptions</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">    // 不缓存，从网络下载数据</span><br><span class="line">    SDImageCacheTypeNone,</span><br><span class="line">    // 磁盘缓存</span><br><span class="line">    SDImageCacheTypeDisk,</span><br><span class="line">    // 内存缓存</span><br><span class="line">    SDImageCacheTypeMemory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDImageCacheOptions) &#123;</span><br><span class="line">    // 即使内存中有缓存，也要强制查询磁盘缓存</span><br><span class="line">    SDImageCacheQueryDataWhenInMemory = 1 &lt;&lt; 0,</span><br><span class="line">    // 强制同步查询磁盘缓存</span><br><span class="line">    SDImageCacheQueryDiskSync = 1 &lt;&lt; 1,</span><br><span class="line">    // 压缩大图</span><br><span class="line">    SDImageCacheScaleDownLargeImages = 1 &lt;&lt; 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>包含几个重要属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/// *** 缓存配置信息 ***</span><br><span class="line">@property (nonatomic, nonnull, readonly) SDImageCacheConfig *config;</span><br><span class="line">/// 内存缓存的最大消耗</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCost;</span><br><span class="line">/// 内存缓存的最大缓存数量</span><br><span class="line">@property (assign, nonatomic) NSUInteger maxMemoryCountLimit;</span><br><span class="line"></span><br><span class="line">/// *** 内存缓存 ***</span><br><span class="line">@property (strong, nonatomic, nonnull) SDMemoryCache *memCache;</span><br><span class="line">/// 磁盘缓存路径</span><br><span class="line">@property (strong, nonatomic, nonnull) NSString *diskCachePath;</span><br><span class="line">/// </span><br><span class="line">@property (strong, nonatomic, nullable) NSMutableArray&lt;NSString *&gt; *customPaths;</span><br><span class="line">/// 读写操作的串行队列</span><br><span class="line">@property (strong, nonatomic, nullable) dispatch_queue_t ioQueue;</span><br><span class="line">/// 用于操作文件的 fileManager</span><br><span class="line">@property (strong, nonatomic, nonnull) NSFileManager *fileManager;</span><br></pre></td></tr></table></figure>

<p>其中 2 个属性需要重点关注一下：</p>
<p>① <code>config</code> 所属类 <code>SDImageCacheConfig</code> 定义了很短属性，只提供了一个init方法，在里边给所有属性付了初值，详见下方法代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</span><br><span class="line"></span><br><span class="line">@implementation SDImageCacheConfig</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        _shouldDisableiCloud = YES;</span><br><span class="line">        _shouldCacheImagesInMemory = YES;</span><br><span class="line">        _shouldUseWeakMemoryCache = YES;</span><br><span class="line">        _diskCacheReadingOptions = 0;</span><br><span class="line">        _diskCacheWritingOptions = NSDataWritingAtomic;</span><br><span class="line">        _maxCacheAge = kDefaultCacheMaxCacheAge;</span><br><span class="line">        _maxCacheSize = 0;</span><br><span class="line">        _diskCacheExpireType = SDImageCacheConfigExpireTypeModificationDate;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>② <code>memCache</code> 它属于一个继承自 NSCache 的缓存类 <code>SDMemoryCache</code>， 他有一个关键属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// weakCache 是 NSMapTable 类型</span><br><span class="line">@property (nonatomic, strong, nonnull) NSMapTable&lt;KeyType, ObjectType&gt; *weakCache; </span><br></pre></td></tr></table></figure>

<p>下面观察一下 SDMemoryCache 的初始化及相关代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithConfig:(SDImageCacheConfig *)config &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line"></span><br><span class="line">        self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</span><br><span class="line"></span><br><span class="line">        // 其他省略 ...</span><br><span class="line"></span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(didReceiveMemoryWarning:)</span><br><span class="line">                                                     name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning:(NSNotification *)notification &#123;</span><br><span class="line">    // 注意：此处是调用的 suoper 方法，所以并没有移除 weak cache，如果是调用 self 重写的 removeAllObjects 方法，就会移除 weak cache。</span><br><span class="line">    [super removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self</span><br><span class="line">                                                    name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                                  object:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当遇到内存警告的时候，缓存会被清除，但 weak cache 并不会被移除，如果手动清除的话，weak cache 当然会被移除。</p>
<p>这里 value 设置成 weak 可以避免可能的循环引用，虽然是 weak，不过，image 实例可以被其他对象持有，像 imageView，这种情况下，value 就不是 nil。</p>
<h6 id="似乎扯远了O-∩-∩-O哈哈-，好了，我们还是切回来继续讨论-SDImageCache-提供的方法吧！"><a href="#似乎扯远了O-∩-∩-O哈哈-，好了，我们还是切回来继续讨论-SDImageCache-提供的方法吧！" class="headerlink" title="似乎扯远了O(∩_∩)O哈哈~，好了，我们还是切回来继续讨论 SDImageCache 提供的方法吧！"></a>似乎扯远了O(∩_∩)O哈哈~，好了，我们还是切回来继续讨论 SDImageCache 提供的方法吧！</h6><p>首先，是 <code>SDImageCache</code> 的创建方法，它给我们提供了一个单例方法 <code>+ (nonnull instancetype)sharedImageCache</code>，下边是他的方法实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (nonnull instancetype)sharedImageCache &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，看看初始化方法，我们发现所有初始化方法最后均调用了同一个核心方法 <code>- (nonnull instancetype)initWithNamespace: diskCacheDirectory:</code>，具体作用见下方代码注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    return [self initWithNamespace:@&quot;default&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns &#123;</span><br><span class="line">    NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">    return [self initWithNamespace:ns diskCacheDirectory:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns];</span><br><span class="line">        </span><br><span class="line">        // 创建一个 IO 串行队列 (依次执行操作)</span><br><span class="line">        _ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        </span><br><span class="line">        // 初始化内存缓存</span><br><span class="line">        _config = [[SDImageCacheConfig alloc] init];</span><br><span class="line">        _memCache = [[SDMemoryCache alloc] initWithConfig:_config];</span><br><span class="line">        _memCache.name = fullNamespace;</span><br><span class="line"></span><br><span class="line">        // 初始化磁盘缓存路径</span><br><span class="line">        if (directory != nil) &#123;</span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace]; </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_sync(_ioQueue, ^&#123;</span><br><span class="line">            self.fileManager = [NSFileManager new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">#if SD_UIKIT</span><br><span class="line">        // App 即将关闭的时候，清除过期缓存</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(deleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationWillTerminateNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">        // App 即将进入后台的时候，清除过期缓存</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(backgroundDeleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记得 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/221b335cc760">上一篇</a> 介绍 SDWebImageManager 的时候，是这样使用 imageCache 的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key</span><br><span class="line">                                                              options:cacheOptions</span><br><span class="line">                                                                 done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType)</span><br><span class="line">&#123;</span><br><span class="line">      // 查询完成后的操作在这里，可能查到了，也可能没查到 ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们就来揭开这个方法的什么面纱。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key</span><br><span class="line">                                            options:(SDImageCacheOptions)options</span><br><span class="line">                                               done:(nullable SDCacheQueryCompletedBlock)doneBlock</span><br><span class="line">&#123;</span><br><span class="line">    // 1.校验参数</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(nil, nil, SDImageCacheTypeNone);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 2.查询内存缓存 (NSCache)</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    BOOL shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));</span><br><span class="line">    if (shouldQueryMemoryOnly) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(image, nil, SDImageCacheTypeMemory);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    </span><br><span class="line">    // 3.将获取缓存及解压的 ‘耗时’ 操作封装成一个 block</span><br><span class="line">    void(^queryDiskBlock)(void) =  ^&#123;</span><br><span class="line">        </span><br><span class="line">        // 如果已经取消，不作任何处理，直接返回。</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            </span><br><span class="line">            NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            UIImage *diskImage;</span><br><span class="line">            SDImageCacheType cacheType = SDImageCacheTypeDisk;</span><br><span class="line">            </span><br><span class="line">            if (image) &#123;</span><br><span class="line">                </span><br><span class="line">                // A &gt; 从 memery 取的</span><br><span class="line"></span><br><span class="line">                diskImage = image;</span><br><span class="line">                cacheType = SDImageCacheTypeMemory;</span><br><span class="line">                </span><br><span class="line">            &#125; else if (diskData) &#123;</span><br><span class="line">                </span><br><span class="line">                // B &gt; 如果内存没有，但是从 disc 取到了，需要解压</span><br><span class="line">                </span><br><span class="line">                diskImage = [self diskImageForKey:key data:diskData options:options];</span><br><span class="line">                </span><br><span class="line">                if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; // 缓存到内存</span><br><span class="line">                    NSUInteger cost = SDCacheCostForImage(diskImage); // 计算大小</span><br><span class="line">                    [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (doneBlock) &#123;</span><br><span class="line">                if (options &amp; SDImageCacheQueryDiskSync) &#123;  // 同步执行完成回调</span><br><span class="line">                    doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                &#125; else &#123;                                    // 异步执行完成回调</span><br><span class="line">                    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        doneBlock(diskImage, diskData, cacheType);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 4.执行查询磁盘缓存的 block</span><br><span class="line">    if (options &amp; SDImageCacheQueryDiskSync) &#123;</span><br><span class="line">        queryDiskBlock();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_async(self.ioQueue, queryDiskBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上边的代码所示，主要分了这么 4 步：</p>
<p>① 校验参数 — 如果 key 不存在，直接 doneBlock，返回 nil。</p>
<p>② 查询内存缓存 NSCache — 如果内存中有，并且没有强制要求必须查询磁盘，则 执行 doneBlock，将 image 返回。</p>
<p>③ 将获取缓存及解压的 ‘耗时’ 操作封装成一个 block — 这是为了最后执行异步操作的方便。</p>
<p>④ 执行查询磁盘缓存的 block — 如果设置了 <code>SDImageCacheQueryDiskSync </code>，则同步执行；否则，默认是异步执行。</p>
<p>第 ③ 步中查询磁盘缓存的 <code>queryDiskBlock</code> 里边有两个比较重要的方法：<code>- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:</code> 和 <code>- (nullable UIImage *)diskImageForKey: data: options:</code>，下边分别了解一下这两个方法：</p>
<ul>
<li>diskImageDataBySearchingAllPathsForKey:  这个方法用于查询磁盘缓存，实现及代码注释如下，拼接缓存路径的方法就不展开了，其中文件名的生成是对传入的 key 执行了一次 MD5。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSData *)diskImageDataBySearchingAllPathsForKey:(nullable NSString *)key &#123;</span><br><span class="line">    // 1.尝试 通过默认路径查询磁盘缓存</span><br><span class="line">    NSString *defaultPath = [self defaultCachePathForKey:key];</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfFile:defaultPath options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2.异常情况的处理：更换了路径再取一次，新路径是将默认路径的后缀去掉 (如果有的话)</span><br><span class="line">    data = [NSData dataWithContentsOfFile:defaultPath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3.遍历所有用户自定义的路径，执行类似 1、2 的操作，查询磁盘缓存</span><br><span class="line">    NSArray&lt;NSString *&gt; *customPaths = [self.customPaths copy];</span><br><span class="line">    for (NSString *path in customPaths) &#123;</span><br><span class="line">        NSString *filePath = [self cachePathForKey:key inPath:path];</span><br><span class="line">        NSData *imageData = [NSData dataWithContentsOfFile:filePath options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        imageData = [NSData dataWithContentsOfFile:filePath.stringByDeletingPathExtension options:self.config.diskCacheReadingOptions error:nil];</span><br><span class="line">        if (imageData) &#123;</span><br><span class="line">            return imageData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 没查到的话，返回 nil</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>diskImageForKey: data: options: 此方法的作用是对从 Disc 直接取的 data，进行 解码、解压操作，实现代码如下。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key data:(nullable NSData *)data options:(SDImageCacheOptions)options &#123;</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        </span><br><span class="line">        // 1.解码</span><br><span class="line">        UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:data];</span><br><span class="line">        image = [self scaledImageForKey:key image:image];</span><br><span class="line">        </span><br><span class="line">        // 2.解压</span><br><span class="line">        if (self.config.shouldDecompressImages) &#123;</span><br><span class="line">            BOOL shouldScaleDown = options &amp; SDImageCacheScaleDownLargeImages;</span><br><span class="line">            </span><br><span class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;data options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return image;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法分别使用了 SDWebImageCodersManager 的 2 个重要方法：</p>
<ul>
<li>解码方法 <code>- (UIImage *)decodedImageWithData:data</code>，其中 coder 可以理解为一个解码器，<code>SDWebImage</code> 提供了多种 coder，如 <code>SDWebImageIOCoder</code>、<code>SDWebImageGIFCoder</code> 分别用于解码某一种类型的图片，如果新增一种图片，可以将对应的 coder（需遵守协议：SDWebImageCoder） 添加到 coders 里即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCodersManager.m</span><br><span class="line"></span><br><span class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</span><br><span class="line">    </span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">    </span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        if ([coder canDecodeFromData:data]) &#123;</span><br><span class="line">            return [coder decodedImageWithData:data];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解压方法 <code>- (UIImage *)decompressedImageWithImage:image data:data options:optionsDict</code>，这个方法和上边的解码方法都属于   <code>SDWebImageCoder</code> 这个协议，与解码方法类似，也是针对不同类型的 image 有不同的 coder。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCodersManager.m</span><br><span class="line"></span><br><span class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</span><br><span class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</span><br><span class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        if ([coder canDecodeFromData:*data]) &#123;</span><br><span class="line">            UIImage *decompressedImage = [coder decompressedImageWithImage:image data:data options:optionsDict];</span><br><span class="line">            decompressedImage.sd_imageFormat = image.sd_imageFormat;</span><br><span class="line">            return decompressedImage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，这些 coder 是什么时候加进去的，又是怎么添加的呢？其实，这些逻辑都在 SDWebImageCodersManager 的实现代码里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCodersManager.m</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        // 初始化 coders</span><br><span class="line">        NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [@[[SDWebImageImageIOCoder sharedCoder]] mutableCopy];</span><br><span class="line">#ifdef SD_WEBP</span><br><span class="line">        [mutableCoders addObject:[SDWebImageWebPCoder sharedCoder]];</span><br><span class="line">#endif</span><br><span class="line">        _coders = [mutableCoders copy];</span><br><span class="line">        _codersLock = dispatch_semaphore_create(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从初始化方法可以看出来，此时只给 coders 添加了一种 coder，即 SDWebImageImageIOCoder，它是用来对普通的 JPG、PNG 等图片解码的。</p>
<p>为了支持对其他类型图片（如 GIF）的解码，manager 给我们提供了下边这个添加 coder 的方法，代码逻辑很简单，就不多做解释了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCodersManager.m</span><br><span class="line"></span><br><span class="line">- (void)addCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder &#123;</span><br><span class="line">    if (![coder conformsToProtocol:@protocol(SDWebImageCoder)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [self.coders mutableCopy];</span><br><span class="line">    if (!mutableCoders) &#123;</span><br><span class="line">        mutableCoders = [NSMutableArray array];</span><br><span class="line">    &#125;</span><br><span class="line">    [mutableCoders addObject:coder];</span><br><span class="line">    self.coders = [mutableCoders copy];</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于缓存相关的类暂时就先介绍到这里，当然还有很多细节没来得及讨论，不过可以查看 demo 中的注释。</p>
<p>到此，关于 SDWebImage 的源码学习就告一段落了，目前的理解可能有点肤浅，以后随着理解的深入，会不定时的更新。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/02/03/SDWebImage-Source-Learning-05/" data-id="cl7c27fh00004jlfy87pn52xv" data-title="SDWebImage 源码学习笔记 ☞ SDImageCache" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SDWebImage-Source-Learning-04" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/26/SDWebImage-Source-Learning-04/" class="article-date">
  <time class="dt-published" datetime="2019-01-26T12:01:44.000Z" itemprop="datePublished">2019-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/26/SDWebImage-Source-Learning-04/">SDWebImage 源码学习笔记 ☞ SDWebImageDownloader</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-29157f1c1fb6719f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage-源码学习笔记.png"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是本系列的第 4 篇，本篇将主要介绍 <code>SDWebImageDownloader</code> 这个负责下载的类，当然还有一些相关类及协议，如： <code>SDWebImageDownloadToken</code>、<code>SDWebImageDownloaderOperation</code> 和 <code>SDWebImageDownloaderOperationInterface</code> 等。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>开启正文描述之前，依旧先看 2 个重要的枚举：<code>SDWebImageDownloaderOptions</code> 和 <code>SDWebImageDownloaderExecutionOrder</code>，具体含义见下方代码注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 控制下载过程的选项</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) &#123;</span><br><span class="line">    // 降低下载任务在队列中的优先级</span><br><span class="line">    SDWebImageDownloaderLowPriority = 1 &lt;&lt; 0,</span><br><span class="line">    // 图片将在下载过程中逐步展示，而不是等下载完成后才一次性展示</span><br><span class="line">    SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1,</span><br><span class="line">    // 使用 NSURLCache，默认是不使用的</span><br><span class="line">    SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2,</span><br><span class="line">    // 如果图片是从 NSURLCache 读取的，那么执行 completionHandler 的时候，回传 nil</span><br><span class="line">    SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3,</span><br><span class="line">    // 后台继续执行任务</span><br><span class="line">    SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4,</span><br><span class="line">    // 允许处理存储在 NSHTTPCookieStore 中的 Cookie</span><br><span class="line">    SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5,</span><br><span class="line">    // 允许不受信任的 SSL 证书，生产环境慎用</span><br><span class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6,</span><br><span class="line">    // 提高下载任务在队列中的优先级</span><br><span class="line">    SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7,</span><br><span class="line">    // 缩放大图</span><br><span class="line">    SDWebImageDownloaderScaleDownLargeImages = 1 &lt;&lt; 8,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 任务的执行顺序</span><br><span class="line">typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) &#123;</span><br><span class="line">    // 先进先出，也是队列的默认执行顺序</span><br><span class="line">    SDWebImageDownloaderFIFOExecutionOrder,</span><br><span class="line">    // 后进先出，栈的执行顺序</span><br><span class="line">    SDWebImageDownloaderLIFOExecutionOrder</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来就到了 SDWebImageDownloader 这个类，我不准备一个属性一个方法地按顺序讨论，而是先说创建方法，然后通过一个主要方法将主体串起来。先看创建方法吧！</p>
<p>对外其实只公开了一个创建单例的方法 <code>sharedDownloader </code>，仔细查看代码会发现，最终调用的是 <code>- (nonnull instancetype)initWithSessionConfiguration:</code> 这个初始化方法，主要做一些初始化工作，并创建一个新 session。如果使用单例方法创建 downloader，则只会有一个 session，而如果通过其他方法创建，则可能创建 session 之前已经有一个了，这时候就需要先将之前的 cancel 之后再创建新的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">+ (nonnull instancetype)sharedDownloader &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    return [self initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)sessionConfiguration &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        // 执行下载任务的 operation</span><br><span class="line">        _operationClass = [SDWebImageDownloaderOperation class];</span><br><span class="line">        // 要求解压图片</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        // 执行顺序，先进先出</span><br><span class="line">        _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;</span><br><span class="line">        </span><br><span class="line">        // 设置下载操作的队列，由于最大并发数是 6，所以此 queue 是 并发队列，如果是 1，则为串行队列。</span><br><span class="line">        _downloadQueue = [NSOperationQueue new];</span><br><span class="line">        _downloadQueue.maxConcurrentOperationCount = 6;</span><br><span class="line">        _downloadQueue.name = @&quot;com.hackemist.SDWebImageDownloader&quot;;</span><br><span class="line">        </span><br><span class="line">        _URLOperations = [NSMutableDictionary new];</span><br><span class="line">        </span><br><span class="line">        // 请求头的字段，可接受的文件类型</span><br><span class="line">#ifdef SD_WEBP</span><br><span class="line">        _HTTPHeaders = [@&#123;@&quot;Accept&quot;: @&quot;image/webp,image/*;q=0.8&quot;&#125; mutableCopy];</span><br><span class="line">#else</span><br><span class="line">        _HTTPHeaders = [@&#123;@&quot;Accept&quot;: @&quot;image/*;q=0.8&quot;&#125; mutableCopy];</span><br><span class="line">#endif</span><br><span class="line">        </span><br><span class="line">        // 锁，这里使用了信号量</span><br><span class="line">        _operationsLock = dispatch_semaphore_create(1);</span><br><span class="line">        _headersLock = dispatch_semaphore_create(1);</span><br><span class="line">        // 超时时间</span><br><span class="line">        _downloadTimeout = 15.0;</span><br><span class="line"></span><br><span class="line">        [self createNewSessionWithConfiguration:sessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建新的 session</span><br><span class="line">- (void)createNewSessionWithConfiguration:(NSURLSessionConfiguration *)sessionConfiguration &#123;</span><br><span class="line">    // 为避免影响，先取消可能存在的下载任务</span><br><span class="line">    [self cancelAllDownloads];</span><br><span class="line"></span><br><span class="line">    // cancel 之前的 session，然后创建一个新的</span><br><span class="line">    if (self.session) &#123;</span><br><span class="line">        [self.session invalidateAndCancel];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sessionConfiguration.timeoutIntervalForRequest = self.downloadTimeout;</span><br><span class="line"></span><br><span class="line">    self.session = [NSURLSession sessionWithConfiguration:sessionConfiguration</span><br><span class="line">                                                 delegate:self</span><br><span class="line">                                            delegateQueue:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们看一下主要方法 <code>- (nullable SDWebImageDownloadToken *)downloadImageWithURL:url options:options progress:progressBlock completed:completedBlock</code>。直接调用了添加进度与完成回调的方法，并将返回值作为结果返回。</p>
<p>添加进度与完成回调的方法我们稍后再议，先看一下调用时传入的 <code>createCallback </code>。就做了两件事：先创建一个 request，用于准备一些基础参数，然后，依据 request 创建 operation，详见代码注释 ☟。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    __weak SDWebImageDownloader *wself = self;</span><br><span class="line"></span><br><span class="line">    return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</span><br><span class="line">        </span><br><span class="line">        __strong __typeof (wself) sself = wself;</span><br><span class="line">        NSTimeInterval timeoutInterval = sself.downloadTimeout;</span><br><span class="line">        if (timeoutInterval == 0.0) &#123;</span><br><span class="line">            timeoutInterval = 15.0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">// *** 1.创建 request</span><br><span class="line">        </span><br><span class="line">        // 为避免重复缓存 (NSURLCache + SDImageCache) ，如果没有明确要求使用 NSURLCache，我们默认忽略本地缓存</span><br><span class="line">        NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;</span><br><span class="line">        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url</span><br><span class="line">                                                                    cachePolicy:cachePolicy</span><br><span class="line">                                                                timeoutInterval:timeoutInterval];</span><br><span class="line">        // The default is YES - in other words, cookies are sent from and stored to the cookie manager by default.</span><br><span class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        request.HTTPShouldUsePipelining = YES;</span><br><span class="line">        </span><br><span class="line">        // 设置 header，headersFilter 是过滤头部参数的block</span><br><span class="line">        if (sself.headersFilter) &#123;</span><br><span class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            request.allHTTPHeaderFields = [sself allHTTPHeaderFields];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">// *** 2.创建下载的 operation (这个 operationClass ，给他赋什么值，他就是什么，如果不设置，就是默认值：[SDWebImageDownloaderOperation class])</span><br><span class="line">        </span><br><span class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request</span><br><span class="line">                                                                                       inSession:sself.session</span><br><span class="line">                                                                                         options:options];</span><br><span class="line">        </span><br><span class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</span><br><span class="line">        </span><br><span class="line">        // NSURLCredential 身份认证</span><br><span class="line">        if (sself.urlCredential) &#123;</span><br><span class="line">            operation.credential = sself.urlCredential;</span><br><span class="line">        &#125; else if (sself.username &amp;&amp; sself.password) &#123;</span><br><span class="line">            // NSURLCredentialPersistenceForSession: Credential should be stored only for this session.</span><br><span class="line">            operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 设置优先级</span><br><span class="line">        if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">        &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 更改执行顺序：先进后出(可在此设置) or 先进先出(默认)</span><br><span class="line">        if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">            // 通过反向设置依赖，指定了队列中任务的执行顺序先加进去的依赖于后加进去的，那就成了后进先出了😎</span><br><span class="line">            [sself.lastAddedOperation addDependency:operation];</span><br><span class="line">            sself.lastAddedOperation = operation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return operation;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们来看看添加进度与完成回调的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">                                                   forURL:(nullable NSURL *)url</span><br><span class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback &#123;</span><br><span class="line">    // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span><br><span class="line">    if (url == nil) &#123;</span><br><span class="line">        if (completedBlock != nil) &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LOCK(self.operationsLock);</span><br><span class="line">    </span><br><span class="line">    SDWebImageDownloaderOperation *operation = [self.URLOperations objectForKey:url];</span><br><span class="line">    </span><br><span class="line">    // 如果是第 1 次进来，通过 url 是取不出 URLOperation 的，但是第 2 次就有可能找到，也就是想要重复发第 2 次请求的话，就可以取到。</span><br><span class="line">    // 第 2 次可以取到(并且已经完成的情况下)，则不会走括号里边，也就不会执行关键步骤：[self.downloadQueue addOperation:operation]; ，所以就不会发起请求了，因为将 operation 添加到队列的时候，系统会自动触发请求。</span><br><span class="line">    if (!operation || operation.isFinished) &#123;</span><br><span class="line">        // 创建 operation</span><br><span class="line">        operation = createCallback();</span><br><span class="line">        __weak typeof(self) wself = self;</span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line">            __strong typeof(wself) sself = wself;</span><br><span class="line">            if (!sself) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            LOCK(sself.operationsLock);</span><br><span class="line">            [sself.URLOperations removeObjectForKey:url];</span><br><span class="line">            UNLOCK(sself.operationsLock);</span><br><span class="line">        &#125;;</span><br><span class="line">        [self.URLOperations setObject:operation forKey:url];</span><br><span class="line">        </span><br><span class="line">        // 添加到队列，即开始执行！</span><br><span class="line">        // Add operation to operation queue only after all configuration done according to Apple&#x27;s doc.</span><br><span class="line">        // `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.</span><br><span class="line">        [self.downloadQueue addOperation:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UNLOCK(self.operationsLock);</span><br><span class="line"></span><br><span class="line">    // 存放进度和完成回调的 数组 array</span><br><span class="line">    id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">    </span><br><span class="line">    // 与下载任务关联的一个对象，用于取消操作的时候</span><br><span class="line">    SDWebImageDownloadToken *token = [SDWebImageDownloadToken new];</span><br><span class="line">    token.downloadOperation = operation;</span><br><span class="line">    token.url = url;</span><br><span class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</span><br><span class="line"></span><br><span class="line">    return token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要做了这么几件事：</p>
<ul>
<li><p>开始依然是参数校验</p>
</li>
<li><p>然后从 self.URLOperation 里边取 operation</p>
</li>
<li><p>第一次进来当然取不到 operation，于是就会进入 <code> if (!operation || operation.isFinished) &#123; ... &#125;</code> 的代码块。先执行我们传入的 <code>createCallback()</code> 创建 operation，然后将 operation 加入到 self.URLOperations 里边，同时设置好 operation 的 completionBlock，到时将 operation 移除，最后将 operation 加入到操作队列里，就会自动开始执行了。</p>
</li>
<li><p>创建一个 token，他是 <code>SDWebImageDownloadToken</code> 的实例，将它与 operation、url、progressBlock  及 completedBlock 关联起来，用于后边之后的取消操作。其中 progressBlock  及 completedBlock 是通过 downloadOperationCancelToken 与 token 关联起来的，这里用到了 operation 中的一个方法：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageDownloaderOperation</span><br><span class="line"></span><br><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    </span><br><span class="line">    SDCallbacksDictionary *callbacks = [NSMutableDictionary new];</span><br><span class="line">    </span><br><span class="line">    if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</span><br><span class="line">    </span><br><span class="line">    if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</span><br><span class="line">    </span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    </span><br><span class="line">    [self.callbackBlocks addObject:callbacks];</span><br><span class="line">    </span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    </span><br><span class="line">    return callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可知，这个 <code>id downloadOperationCancelToken</code> 是一个存放 progressBlock 和 completedBlock 的 dictionary。</p>
<p>这里 if 语句起到了一个非常重要的作用，即 避免重复下载相同数据，具体原因就不解释了，上边的代码注释里已经写了。</p>
<p>到这里是不是觉得少了点什么，是的，<code>SDWebImageDownloaderOperation</code> 和 <code>SDWebImageDownloadToken</code> 的具体实现还不知道呢，接下来我们就分别查看这 2 个类，先从简单的开始吧！</p>
<h5 id="SDWebImageDownloadToken"><a href="#SDWebImageDownloadToken" class="headerlink" title="SDWebImageDownloadToken"></a>SDWebImageDownloadToken</h5><p>这个类只有 3 个属性，前边都用到了，属性声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 下载任务对应的 url</span><br><span class="line">@property (nonatomic, strong, nullable) NSURL *url;</span><br><span class="line">// 实际是包含 progressBlock 和 completionBlock 的字典，是通过 `addHandlersForProgress:completed:` 返回的，用于取消操作</span><br><span class="line">@property (nonatomic, strong, nullable) id downloadOperationCancelToken;</span><br><span class="line">// 操作的 operation，继承自 NSOperation，不过又遵守了 `SDWebImageDownloaderOperationInterface` 这个协议，扩展了一些方法。</span><br><span class="line">@property (nonatomic, weak, nullable) NSOperation&lt;SDWebImageDownloaderOperationInterface&gt; *downloadOperation;</span><br></pre></td></tr></table></figure>

<p>它只实现了一个协议方法 <code>cancel</code>（Protocol: SDWebImageOperation），其中 <code>self.downloadOperationCancelToken</code>就是存放 progressBlock 和 completionBlock 的字典，然后将这个 token 创递给了 operation 的 <code>cancel:</code> 方法（也是一个协议方法），这个方法的具体实现下边就会说到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancel &#123;</span><br><span class="line">    if (self.downloadOperation) &#123;</span><br><span class="line">        SDWebImageDownloadToken *cancelToken = self.downloadOperationCancelToken;</span><br><span class="line">        if (cancelToken) &#123;</span><br><span class="line">            [self.downloadOperation cancel:cancelToken];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SDWebImageDownloaderOperationInterface"><a href="#SDWebImageDownloaderOperationInterface" class="headerlink" title="SDWebImageDownloaderOperationInterface"></a>SDWebImageDownloaderOperationInterface</h5><p>在开始介绍 operation 之前，先看看他遵守的协议 <code>SDWebImageDownloaderOperationInterface</code>，声明了以下协议方法。如果想要使用自定义的 operation，则它必须继承自 NSOperation 并且遵守这个协议。这些方法的实现可以参考 <code>SDWebImageDownloaderOperation </code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageDownloaderOperationInterface</span><br><span class="line">// 初始化方法</span><br><span class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</span><br><span class="line">                              inSession:(nullable NSURLSession *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options;</span><br><span class="line">// 保存进度和完成的回调</span><br><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line">// 是否需要解压图片</span><br><span class="line">- (BOOL)shouldDecompressImages;</span><br><span class="line">- (void)setShouldDecompressImages:(BOOL)value;</span><br><span class="line">// 凭证或称证书信息</span><br><span class="line">- (nullable NSURLCredential *)credential;</span><br><span class="line">- (void)setCredential:(nullable NSURLCredential *)value;</span><br><span class="line">// 取消</span><br><span class="line">- (BOOL)cancel:(nullable id)token;</span><br></pre></td></tr></table></figure>

<h5 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h5><p>现在开始讨论 <code>SDWebImageDownloaderOperation</code> 这个类，下边是初始化方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    return [self initWithRequest:nil inSession:nil options:0];</span><br><span class="line">&#125;</span><br><span class="line">// 也是协议方法</span><br><span class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</span><br><span class="line">                              inSession:(nullable NSURLSession *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _request = [request copy];</span><br><span class="line">        _shouldDecompressImages = YES;</span><br><span class="line">        _options = options;</span><br><span class="line">        _callbackBlocks = [NSMutableArray new];</span><br><span class="line">        _executing = NO;</span><br><span class="line">        _finished = NO;</span><br><span class="line">        _expectedSize = 0;</span><br><span class="line">        _unownedSession = session;</span><br><span class="line">        _callbacksLock = dispatch_semaphore_create(1);</span><br><span class="line">        _coderQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageDownloaderOperationCoderQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面介绍 2 个比较重要的方法：</p>
<ul>
<li>核心方法 start</li>
</ul>
<p>这是重写父类 NSOperation 的 start 方法，添加了自定义的操作。这个方法不需要手动调用，在将 operation 添加到 operationQueue 中的时候，系统会自动调用其 start 方法。重写后的操作包括以下几点：</p>
<p>①检测操作是否已取消，如果取消了，重置数据后直接返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (self.isCancelled) &#123;</span><br><span class="line">    self.finished = YES;</span><br><span class="line">    [self reset];</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②如果需要 App 进入后台时，继续执行下载操作，需要开启后台任务。并设置 ExpirationHandler，取消下载任务，并结束后台操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 如果需要App进入后台时，继续执行此操作，需要开启后台任务。</span><br><span class="line">Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</span><br><span class="line">if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">    __weak __typeof__ (self) wself = self;</span><br><span class="line">    UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</span><br><span class="line">    self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        __strong __typeof (wself) sself = wself;</span><br><span class="line"></span><br><span class="line">        if (sself) &#123;</span><br><span class="line">            [sself cancel];</span><br><span class="line"></span><br><span class="line">            [app endBackgroundTask:sself.backgroundTaskId];</span><br><span class="line">            sself.backgroundTaskId = UIBackgroundTaskInvalid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③获取或创建 session，然后创建 dataTask，</p>
<p>④若 dataTask 创建成功，启动下载任务 <code> [self.dataTask resume];</code>，然后执行一次 progressBlock，并发送开始下载的通知。</p>
<p>④若 dataTask 创建失败，直接调用完成回调，构建 error 信息并返回，然后重置数据。</p>
<p>⑤关闭可能存在的后台下载任务。</p>
<p>具体下载过程中的操作，都在 session 相关的那些协议方法里边，详见代码注释，这里就不啰嗦了。</p>
<ul>
<li>取消操作</li>
</ul>
<p>最后看一下取消操作，即协议方法 <code>- (BOOL)cancel:(nullable id)token;</code> 的实现，将取消过程中用到的所有方法都展开就是下边这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)cancel:(nullable id)token &#123;</span><br><span class="line">    BOOL shouldCancel = NO;</span><br><span class="line">    </span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    </span><br><span class="line">    // 移除 token，即移除一个存储着 completionBlock 和 progressBlock 的字典</span><br><span class="line">    [self.callbackBlocks removeObjectIdenticalTo:token];</span><br><span class="line">    </span><br><span class="line">    // 如果已经没有回调，就去执行整体的 cancel 操作</span><br><span class="line">    if (self.callbackBlocks.count == 0) &#123;</span><br><span class="line">        shouldCancel = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    </span><br><span class="line">    if (shouldCancel) &#123;</span><br><span class="line">        // *** 点开 ☟</span><br><span class="line">        [self cancel];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return shouldCancel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        // *** 点开 ☟</span><br><span class="line">        [self cancelInternal];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cancelInternal &#123;</span><br><span class="line">    if (self.isFinished) return;</span><br><span class="line">    [super cancel];</span><br><span class="line"></span><br><span class="line">    if (self.dataTask) &#123;</span><br><span class="line">        // 取消下载任务，并发出停止的通知</span><br><span class="line">        [self.dataTask cancel];</span><br><span class="line">        __weak typeof(self) weakSelf = self;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // As we cancelled the task, its callback won&#x27;t be called and thus won&#x27;t</span><br><span class="line">        // maintain the isFinished and isExecuting flags.</span><br><span class="line">        if (self.isExecuting) self.executing = NO;</span><br><span class="line">        if (!self.isFinished) self.finished = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    // *** 点开 ☟</span><br><span class="line">    [self reset];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 重置变量</span><br><span class="line">- (void)reset &#123;</span><br><span class="line">    LOCK(self.callbacksLock);</span><br><span class="line">    [self.callbackBlocks removeAllObjects];</span><br><span class="line">    UNLOCK(self.callbacksLock);</span><br><span class="line">    self.dataTask = nil;</span><br><span class="line">    </span><br><span class="line">    if (self.ownedSession) &#123;</span><br><span class="line">        [self.ownedSession invalidateAndCancel];</span><br><span class="line">        self.ownedSession = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>SDWebImageDownloader 的内容就先介绍到这类，其他细节见 <a target="_blank" rel="noopener" href="https://github.com/riversea2015/CodeForBlogs/tree/master/HHSDWebImageStudy">HHSDWebImageStudy</a> 中的源码注释。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/01/26/SDWebImage-Source-Learning-04/" data-id="cl7c27fgx0002jlfy9ochh1nh" data-title="SDWebImage 源码学习笔记 ☞ SDWebImageDownloader" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SDWebImage-Source-Learning-03" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/20/SDWebImage-Source-Learning-03/" class="article-date">
  <time class="dt-published" datetime="2019-01-20T10:19:06.000Z" itemprop="datePublished">2019-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/20/SDWebImage-Source-Learning-03/">SDWebImage 源码学习笔记 ☞ SDWebImageManager</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://upload-images.jianshu.io/upload_images/2208988-29157f1c1fb6719f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage-源码学习笔记.png"></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是本系列的第 3 篇，在前一篇中，我们了解了 SDWebImage 执行的基本流程，本篇就来介绍第一个核心类 <code>SDWebImageMananger</code>。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>SDWebImageMananger.h 文件基本可以分为 3 各部分：</p>
<p>①定义了一个枚举 <code>SDWebImageOptions </code>，列举了可能会用到的一些场景。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</span><br><span class="line">    // 重试已经失败的 url</span><br><span class="line">    SDWebImageRetryFailed = 1 &lt;&lt; 0,</span><br><span class="line">    // 低优先级，比如，在有 UI 交互的情况下，会延迟下载操作</span><br><span class="line">    SDWebImageLowPriority = 1 &lt;&lt; 1,</span><br><span class="line">    // 下载完成后，仅做内存缓存，不做磁盘缓存</span><br><span class="line">    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</span><br><span class="line">    // 下载过程中逐步加载图片，而不是完全下载完之后才展示</span><br><span class="line">    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</span><br><span class="line">    // 刷新缓存</span><br><span class="line">    SDWebImageRefreshCached = 1 &lt;&lt; 4,</span><br><span class="line">    // 当 App 进入后台时，继续下载任务，如果后台任务超时，操作将被自动取消</span><br><span class="line">    SDWebImageContinueInBackground = 1 &lt;&lt; 5,</span><br><span class="line">    // 允许处理 Cookie</span><br><span class="line">    SDWebImageHandleCookies = 1 &lt;&lt; 6,</span><br><span class="line">    // 允许不受信任的 SSL 证书，生产环境慎用</span><br><span class="line">    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</span><br><span class="line">    // 高优先级，即会把相应的图片放到最前边加载，而不是按照加入队列时的顺序执行</span><br><span class="line">    SDWebImageHighPriority = 1 &lt;&lt; 8,</span><br><span class="line">    // 延迟 placeholder 的加载，即在下载完成时才加载</span><br><span class="line">    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</span><br><span class="line">    // 对动图也执行 transform 操作</span><br><span class="line">    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</span><br><span class="line">    // 图片下载完成后，不直接自动给 imageView 赋值，给用户调整图片的机会</span><br><span class="line">    SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</span><br><span class="line">    // 依据设备内存缩放图片，如果设置了 `SDWebImageProgressiveDownload` ，此设置无效</span><br><span class="line">    SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12,</span><br><span class="line">    // 在有内存缓存的情况下，依然需要查询磁盘缓存，建议与 SDWebImageQueryDiskSync 配合使用</span><br><span class="line">    SDWebImageQueryDataWhenInMemory = 1 &lt;&lt; 13,</span><br><span class="line">    // 同步查询磁盘缓存</span><br><span class="line">    SDWebImageQueryDiskSync = 1 &lt;&lt; 14,</span><br><span class="line">    // 仅加载缓存图片</span><br><span class="line">    SDWebImageFromCacheOnly = 1 &lt;&lt; 15,</span><br><span class="line">    // 对内存和磁盘中的 image 也执行 transition 的操作</span><br><span class="line">    SDWebImageForceTransition = 1 &lt;&lt; 16</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>②定义了一个协议 <code>SDWebImageManagerDelegate</code>，这里提供了以下 3 个协议方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 缓存中没有指定图片时，是否需要下载</span><br><span class="line">- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldDownloadImageForURL:(nullable NSURL *)imageURL;</span><br><span class="line"></span><br><span class="line">// 是否需要将制定 URL 标记为失败的 URL</span><br><span class="line">- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldBlockFailedURL:(nonnull NSURL *)imageURL withError:(nonnull NSError *)error;</span><br><span class="line"></span><br><span class="line">// 允许在刚刚下载到 image 并且未做缓存之前，对图片执行 transform，返回处理后的 image</span><br><span class="line">- (nullable UIImage *)imageManager:(nonnull SDWebImageManager *)imageManager transformDownloadedImage:(nullable UIImage *)image withURL:(nullable NSURL *)imageURL;</span><br></pre></td></tr></table></figure>

<p>③SDWebImageManager 的头文件，有几个重要属性，他们的作用见下边的注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 代理对象</span><br><span class="line">@property (weak, nonatomic, nullable) id &lt;SDWebImageManagerDelegate&gt; delegate;</span><br><span class="line">// 处理缓存的对象</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) SDImageCache *imageCache;</span><br><span class="line">// 处理下载工作的对象</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) SDWebImageDownloader *imageDownloader;</span><br><span class="line">// 一个用户定义的 block，用于生成 cacheKey</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</span><br><span class="line">// 一个用户定义的 block，用于序列化下载到的数据</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageCacheSerializerBlock cacheSerializer;</span><br></pre></td></tr></table></figure>

<p>下面是 2 个常用的创建方法：<code>+ (nonnull instancetype)sharedManager;</code> 和 <code>- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader;</code>，其实最终都是调用了后者 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 单例</span><br><span class="line">+ (nonnull instancetype)sharedManager &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 初始化，创建处理缓存和下载任务的对象 cache 和 downloader</span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    SDImageCache *cache = [SDImageCache sharedImageCache];</span><br><span class="line">    SDWebImageDownloader *downloader = [SDWebImageDownloader sharedDownloader];</span><br><span class="line">    return [self initWithCache:cache downloader:downloader];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 核心的初始化方法，为各属性赋初值</span><br><span class="line">- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        // 处理缓存和下载任务的对象</span><br><span class="line">        _imageCache = cache;</span><br><span class="line">        _imageDownloader = downloader;</span><br><span class="line">        // 用于存储请求失败的 URL 的集合及操作时用的锁 (信号量)</span><br><span class="line">        _failedURLs = [NSMutableSet new];</span><br><span class="line">        _failedURLsLock = dispatch_semaphore_create(1);</span><br><span class="line">        // 存储运行中 operation 的集合，通过判断他的 count 是否为 0，判断操作是否在进行中：BOOL isRunning = (self.runningOperations.count &gt; 0);</span><br><span class="line">        _runningOperations = [NSMutableSet new];</span><br><span class="line">        // 操作时用的锁 (信号量)</span><br><span class="line">        _runningOperationsLock = dispatch_semaphore_create(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外几个方法，就不单独介绍了，用到的时候再继续讨论。此处，我们只看一个核心方法 <code>- (nullable id &lt;SDWebImageOperation&gt;)loadImageWithURL:url options:options progress:progressBlock completed:completedBlock;</code>，下面我们来一步步讨论这个方法的具体实现。</p>
<h5 id="1-校验参数"><a href="#1-校验参数" class="headerlink" title="1.校验参数"></a>1.校验参数</h5><p>依次做如下处理：如果传入的 completedBlock 为空，就直接报错；如果传入的参数是 NSString * 类型的，需要将其转换成 NSURL；最后，如果 url 还不是 NSURL 类型，那就只能将其置为 nil，以免造成后边 Crash。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line"></span><br><span class="line">if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">    url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">    url = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-生成总的-operation"><a href="#2-生成总的-operation" class="headerlink" title="2.生成总的 operation"></a>2.生成总的 operation</h5><p>他是 <code>SDWebImageCombinedOperation</code> 实例对象，也是当前方法要返回的结果，并将当前类赋值给 operation 的一个 weak 属性(避免循环引用)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">operation.manager = self; // 肯定是 weak 属性</span><br></pre></td></tr></table></figure>

<p><code>SDWebImageCombinedOperation</code> 的声明与实现文件均在当前类 <code>SDWebImageManager</code> 的实现文件里边，简单看一下他的 .h&#x2F;.m 文件吧。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCombinedOperation.h</span><br><span class="line">@interface SDWebImageCombinedOperation : NSObject &lt;SDWebImageOperation&gt;</span><br><span class="line">// 标识是否已取消</span><br><span class="line">@property (assign, nonatomic, getter = isCanceled) BOOL cancelled;</span><br><span class="line">// downloadToken 这是一个继承自 NSObject 的类，他有一个继承自 NSOperation 的属性，也就是真正执行下载操作时的 operation，cancel 时会用到</span><br><span class="line">@property (strong, nonatomic, nullable) SDWebImageDownloadToken *downloadToken;</span><br><span class="line">// 查询缓存时的 operation，用于标识当前 operation 是否已经被取消。其实查询缓存时，首先查看 operation.isCanceled，如果没被取消了，就会再去查询了。cancel 时会将其 isCanceled 属性置为 YES。</span><br><span class="line">@property (strong, nonatomic, nullable) NSOperation *cacheOperation;</span><br><span class="line">// manager</span><br><span class="line">@property (weak, nonatomic, nullable) SDWebImageManager *manager;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// SDWebImageCombinedOperation.m</span><br><span class="line">#pragma mark - 代理方法实现</span><br><span class="line"></span><br><span class="line">@implementation SDWebImageCombinedOperation</span><br><span class="line"></span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        self.cancelled = YES;</span><br><span class="line">        // 取消查询缓存的 Operation，此时 isCanceled 会被置为 YES。</span><br><span class="line">        if (self.cacheOperation) &#123;</span><br><span class="line">            [self.cacheOperation cancel];</span><br><span class="line">            self.cacheOperation = nil;</span><br><span class="line">        &#125;</span><br><span class="line">        // 取消下载操作</span><br><span class="line">        if (self.downloadToken) &#123;</span><br><span class="line">            [self.manager.imageDownloader cancel:self.downloadToken];</span><br><span class="line">        &#125;</span><br><span class="line">        // 将当前 operation 从 manager 中运行着的 operation 数组中移除。</span><br><span class="line">        [self.manager safelyRemoveOperationFromRunning:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  SDWebImageOperation 协议的定义</span><br><span class="line">@protocol SDWebImageOperation &lt;NSObject&gt;</span><br><span class="line">- (void)cancel;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>SDWebImageCombinedOperation</code> 这个类的主要作用就是 cancel 操作，包括 cancel 查询缓存 和 cancel 下载数据。</p>
<h5 id="3-再次检测一下-url"><a href="#3-再次检测一下-url" class="headerlink" title="3.再次检测一下 url"></a>3.再次检测一下 url</h5><p>如果是曾经失败的 url，而且不允许重试，或者 url 为空时，执行 completionBlock，并返回当前 operation。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// self.failedURLs 是一个保存曾经失败过的 URL 的数组，用于检测当前 URL 是不是曾经请求失败过的URL.另外，搜索一个个元素的时候，NSSet 比 NSArray 查询更快。</span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        LOCK(self.failedURLsLock);</span><br><span class="line">        isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">        UNLOCK(self.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 若出现以下两种情况就不再往下走了，直接执行 CompletionBlock：① URL 是空的；② 此 URL 是曾经请求失败的 URL，并且规定不允许重新请求曾经失败的 URL。</span><br><span class="line">    if (url.absoluteString.length == 0</span><br><span class="line">        || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl))</span><br><span class="line">    &#123;</span><br><span class="line">        [self callCompletionBlockForOperation:operation</span><br><span class="line">                                   completion:completedBlock</span><br><span class="line">                                        error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil]</span><br><span class="line">                                          url:url];</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-保存-operation-至-self-runningOperations"><a href="#4-保存-operation-至-self-runningOperations" class="headerlink" title="4.保存 operation 至 self.runningOperations"></a>4.保存 <code>operation</code> 至 <code>self.runningOperations</code></h5><p>后者是一个数组，这里使用了信号量来确保线程安装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOCK(self.runningOperationsLock);</span><br><span class="line">[self.runningOperations addObject:operation];</span><br><span class="line">UNLOCK(self.runningOperationsLock);</span><br></pre></td></tr></table></figure>

<h5 id="5-查询缓存。"><a href="#5-查询缓存。" class="headerlink" title="5.查询缓存。"></a>5.查询缓存。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSString *key = [self cacheKeyForURL:url];</span><br><span class="line"></span><br><span class="line">SDImageCacheOptions cacheOptions = 0;</span><br><span class="line">if (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;</span><br><span class="line">if (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;</span><br><span class="line">if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;</span><br><span class="line"></span><br><span class="line">__weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line"></span><br><span class="line">operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key</span><br><span class="line">                                                              options:cacheOptions</span><br><span class="line">                                                                 done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType)</span><br><span class="line">&#123;</span><br><span class="line">    // 查询完成后的操作在这里，可能查到了，也可能没查到...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先准备了 2 个参数，查询的依据 key 和一些条件 cacheOptions。key 的获取是通过一个私有方法 (如下)，如果自定义了 <code>key</code> 的生成规则 self.cacheKeyFilter，就用自定义的，如果没有，就直接取 url.absoluteString。<code>cacheOptions</code> 是一个用 NS_OPTIONS 定义的枚举类型 (前边已介绍过)，可组合多种情况，在这里综合了 2 个查询的要求和 1 个缩放图片的要求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)cacheKeyForURL:(nullable NSURL *)url &#123;</span><br><span class="line">    if (!url) &#123;</span><br><span class="line">        return @&quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.cacheKeyFilter) &#123;</span><br><span class="line">        return self.cacheKeyFilter(url);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return url.absoluteString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-查询的具体过程"><a href="#6-查询的具体过程" class="headerlink" title="6.查询的具体过程"></a>6.查询的具体过程</h5><p>详情将会在 <a href="">SDImageCache</a> 中介绍，下面讨论一下查询缓存结束后的操作。</p>
<h5 id="7-移除当前-operation"><a href="#7-移除当前-operation" class="headerlink" title="7.移除当前 operation"></a>7.移除当前 operation</h5><p>从 self.runningOperations 这个数组中移除当前 operation。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">    [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="8-判断是否需要下载"><a href="#8-判断是否需要下载" class="headerlink" title="8.判断是否需要下载"></a>8.判断是否需要下载</h5><p>当同时满足 3 个要求时，就需要下载新数据了：<br>①没要求只能从缓存获取数据，即当缓存找不到时，可以去下载；<br>②找不到缓存 或 要求必须更新缓存；<br>③当 self.delegate 没有遵守协议， 或者 协议方法返回 YES。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BOOL shouldDownload = (!(options &amp; SDWebImageFromCacheOnly)) </span><br><span class="line">        &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached) </span><br><span class="line">        &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]);</span><br></pre></td></tr></table></figure>

<h5 id="9-若需要下载"><a href="#9-若需要下载" class="headerlink" title="9.若需要下载"></a>9.若需要下载</h5><ul>
<li>首先依然要做一个判断，即 如果有缓存数据并且要求刷新缓存数据时，需要先调用一次 CompletionBlock，将缓存数据返回去，然后再开始下载新数据，代码如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">    [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，准备下载数据时所需的一些基本选项，可以参考篇头介绍的枚举 <code>SDWebImageOptions</code>。</p>
<ul>
<li>开始下载，调用了 SDWebImageDownloader 的下载方法，留待 <a href="">SDWebImageDownloader</a> 介绍，这里只讨论下载完成之后的操作。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(strongOperation) weakSubOperation = strongOperation;</span><br><span class="line">            strongOperation.downloadToken = [self.imageDownloader downloadImageWithURL:url</span><br><span class="line">                                                                               options:downloaderOptions</span><br><span class="line">                                                                              progress:progressBlock</span><br><span class="line">                                                                             completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished)</span><br><span class="line">&#123;</span><br><span class="line">        // 下载完成后的操作...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下载完成后，可以分这么几种情况：<br>a.当前 operation 已经被取消，这种情况下不作任何操作，包括回调。</p>
<p>b.下载出错，先将失败的 error 信息返回，然后决定是否需要将当前 URL 存入失败的 URL 数组。</p>
<p>c.下载成功，此时要做的工作还有许多：</p>
<p> ①如果设置了失败重发，则将当前 URL 从失败的 URL 数组中移除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">    LOCK(self.failedURLsLock);</span><br><span class="line">    [self.failedURLs removeObject:url];</span><br><span class="line">    UNLOCK(self.failedURLsLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②对于自定义的 manager，需要执行另外一套缩放标准。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (self != [SDWebImageManager sharedManager]</span><br><span class="line">                        &amp;&amp; self.cacheKeyFilter</span><br><span class="line">                        &amp;&amp; downloadedImage)</span><br><span class="line">&#123;</span><br><span class="line">    downloadedImage = [self scaledImageForKey:key image:downloadedImage];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③若需要更新缓存，但是未下载到图片，且缓存中本来有值的情况下，什么也不做，因为下载之前早已经缓存数据返回了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">// 需要更新缓存，但是未下载到图片，且缓存中本来有值的情况下，什么也不做，因为下载之前早已经缓存数据返回了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④如果下载到了图片，并且要求 transform 图片的情况下，异步执行 transform 和缓存图片的工作，然后回到主线程执行 completionBlock。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        </span><br><span class="line">        UIImage *transformedImage = [self.delegate imageManager:self</span><br><span class="line">                                       transformDownloadedImage:downloadedImage</span><br><span class="line">                                                        withURL:url];</span><br><span class="line">        </span><br><span class="line">        if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">            </span><br><span class="line">            BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">            NSData *cacheData;</span><br><span class="line">            // pass nil if the image was transformed, so we can recalculate the data from the image</span><br><span class="line">            if (self.cacheSerializer) &#123;</span><br><span class="line">                cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cacheData = (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // *** 存盘：注意是存的 imageData</span><br><span class="line">            [self.imageCache storeImage:transformedImage</span><br><span class="line">                              imageData:cacheData</span><br><span class="line">                                 forKey:key</span><br><span class="line">                                 toDisk:cacheOnDisk</span><br><span class="line">                             completion:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [self callCompletionBlockForOperation:strongSubOperation</span><br><span class="line">                                   completion:completedBlock</span><br><span class="line">                                        image:transformedImage</span><br><span class="line">                                         data:downloadedData</span><br><span class="line">                                        error:nil</span><br><span class="line">                                    cacheType:SDImageCacheTypeNone</span><br><span class="line">                                     finished:finished</span><br><span class="line">                                          url:url];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>⑤如果下载到了图片，并且下载完成的话，则存盘并执行 completionBlock。存盘调用了 <code>SDImageCache</code> 的方法，随后介绍。</p>
<p>最后将当前 operation 移除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        </span><br><span class="line">        UIImage *transformedImage = [self.delegate imageManager:self</span><br><span class="line">                                       transformDownloadedImage:downloadedImage</span><br><span class="line">                                                        withURL:url];</span><br><span class="line">        </span><br><span class="line">        if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">            </span><br><span class="line">            BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">            NSData *cacheData;</span><br><span class="line">            // pass nil if the image was transformed, so we can recalculate the data from the image</span><br><span class="line">            if (self.cacheSerializer) &#123;</span><br><span class="line">                cacheData = self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cacheData = (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // *** 存盘：注意是存的 imageData</span><br><span class="line">            [self.imageCache storeImage:transformedImage</span><br><span class="line">                              imageData:cacheData</span><br><span class="line">                                 forKey:key</span><br><span class="line">                                 toDisk:cacheOnDisk</span><br><span class="line">                             completion:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [self callCompletionBlockForOperation:strongSubOperation</span><br><span class="line">                                   completion:completedBlock</span><br><span class="line">                                        image:transformedImage</span><br><span class="line">                                         data:downloadedData</span><br><span class="line">                                        error:nil</span><br><span class="line">                                    cacheType:SDImageCacheTypeNone</span><br><span class="line">                                     finished:finished</span><br><span class="line">                                          url:url];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">if (finished) &#123;</span><br><span class="line">    [self safelyRemoveOperationFromRunning:strongSubOperation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-若不需要下载，并且有缓存"><a href="#10-若不需要下载，并且有缓存" class="headerlink" title="10.若不需要下载，并且有缓存"></a>10.若不需要下载，并且有缓存</h5><p>此时，执行 completionBlock 将缓存数据返回，然后移除当前 operation。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[self callCompletionBlockForOperation:strongOperation</span><br><span class="line">                           completion:completedBlock</span><br><span class="line">                                image:cachedImage</span><br><span class="line">                                 data:cachedData</span><br><span class="line">                                error:nil</span><br><span class="line">                            cacheType:cacheType</span><br><span class="line">                             finished:YES</span><br><span class="line">                                  url:url];</span><br><span class="line">            </span><br><span class="line">[self safelyRemoveOperationFromRunning:strongOperation];</span><br></pre></td></tr></table></figure>

<h5 id="11-其它，即没有缓存，且不需要下载"><a href="#11-其它，即没有缓存，且不需要下载" class="headerlink" title="11.其它，即没有缓存，且不需要下载"></a>11.其它，即没有缓存，且不需要下载</h5><p>和上边的操作类似，只不过传回的 image 和 data 均为 nil。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[self callCompletionBlockForOperation:strongOperation</span><br><span class="line">                           completion:completedBlock</span><br><span class="line">                                image:nil</span><br><span class="line">                                 data:nil</span><br><span class="line">                                error:nil</span><br><span class="line">                            cacheType:SDImageCacheTypeNone</span><br><span class="line">                             finished:YES</span><br><span class="line">                                  url:url];</span><br><span class="line"></span><br><span class="line">[self safelyRemoveOperationFromRunning:strongOperation];</span><br></pre></td></tr></table></figure>

<p>最后将 operation 返回。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上就是 SDWebImageManager 这个类的主要功能，其中关于缓存和下载的内容，详见后边几篇的讨论。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2019/01/20/SDWebImage-Source-Learning-03/" data-id="cl7c27fgz0003jlfy0sq5corh" data-title="SDWebImage 源码学习笔记 ☞ SDWebImageManager" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/24/ijkplayer-Compilation-and-Packaging/">ijkplayer 编译-打包-Pod支持</a>
          </li>
        
          <li>
            <a href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/">iOS UITextView 实现类似微博的话题、提及功能</a>
          </li>
        
          <li>
            <a href="/2019/03/17/AFNetWorking-Source-Learning-05/">AFNetWorking 源码学习笔记 ☞ Reachability</a>
          </li>
        
          <li>
            <a href="/2019/03/10/AFNetWorking-Source-Learning-04/">AFNetWorking 源码学习笔记 ☞ Serialization</a>
          </li>
        
          <li>
            <a href="/2019/03/02/AFNetWorking-Source-Learning-03/">AFNetWorking 源码学习笔记 ☞ Security</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 He Hai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>