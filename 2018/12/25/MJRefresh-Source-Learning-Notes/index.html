<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>MJRefresh 源码学习笔记 | riversea2015</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1.前言MJRefresh 是日常 iOS 开发中使用频率比较高的一款下拉刷新&#x2F;上拉加载更多的第三方控件，平时似乎没有完整查看过源码，此处就记录一下探究源码的过程吧。">
<meta property="og:type" content="article">
<meta property="og:title" content="MJRefresh 源码学习笔记">
<meta property="og:url" content="https://devhe.com/2018/12/25/MJRefresh-Source-Learning-Notes/index.html">
<meta property="og:site_name" content="riversea2015">
<meta property="og:description" content="1.前言MJRefresh 是日常 iOS 开发中使用频率比较高的一款下拉刷新&#x2F;上拉加载更多的第三方控件，平时似乎没有完整查看过源码，此处就记录一下探究源码的过程吧。">
<meta property="og:locale">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37656ab6f0f94cdb95c9d3841c262659~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dae262dbc99a4e0783890f12f214523a~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa752c6e3e984482b55d6a9f5824dfad~tplv-k3u1fbpfcp-watermark.image">
<meta property="article:published_time" content="2018-12-25T06:23:22.000Z">
<meta property="article:modified_time" content="2022-08-24T09:15:36.069Z">
<meta property="article:author" content="He Hai">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37656ab6f0f94cdb95c9d3841c262659~tplv-k3u1fbpfcp-watermark.image">
  
    <link rel="alternate" href="/atom.xml" title="riversea2015" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">riversea2015</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Stay Hungry, Stay Young.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Buscar"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Buscar"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://devhe.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-MJRefresh-Source-Learning-Notes" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/12/25/MJRefresh-Source-Learning-Notes/" class="article-date">
  <time class="dt-published" datetime="2018-12-25T06:23:22.000Z" itemprop="datePublished">2018-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      MJRefresh 源码学习笔记
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p><a target="_blank" rel="noopener" href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a> 是日常 iOS 开发中使用频率比较高的一款<code>下拉刷新</code>&#x2F;<code>上拉加载更多</code>的第三方控件，平时似乎没有完整查看过源码，此处就记录一下探究源码的过程吧。</p>
<span id="more"></span>

<h2 id="2-使用示例"><a href="#2-使用示例" class="headerlink" title="2.使用示例"></a>2.使用示例</h2><p>官方给的 Example 里边提供了很多种刷新样式 ，本文仅以其中 2 种样式（<code>UITableView + 下拉刷新 动画图片</code> 和 <code>UITableView + 上拉刷新动画图片</code> ）为例展开讨论。</p>
<h3 id="示例1：UITableView-下拉刷新-动画图片"><a href="#示例1：UITableView-下拉刷新-动画图片" class="headerlink" title="示例1：UITableView + 下拉刷新 动画图片"></a>示例1：UITableView + 下拉刷新 动画图片</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)exampleA</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.设置 header</span></span><br><span class="line">    <span class="keyword">self</span>.tableView.mj_header = [MJChiBaoZiHeader headerWithRefreshingTarget:<span class="keyword">self</span> refreshingAction:<span class="keyword">@selector</span>(loadNewData)];</span><br><span class="line">    <span class="comment">// 2.马上进入刷新状态</span></span><br><span class="line">    [<span class="keyword">self</span>.tableView.mj_header beginRefreshing];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)loadNewData &#123;</span><br><span class="line">    <span class="comment">// 3.下载数据的操作</span></span><br><span class="line">   __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">   [<span class="keyword">self</span> requestNetDataWithCompletionBlock:^(<span class="built_in">NSArray</span> *result, <span class="type">BOOL</span> isSuccess) &#123;</span><br><span class="line">   </span><br><span class="line">      <span class="comment">// 4.处理返回的数据（略）</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5.刷新表格，并结束刷新状态</span></span><br><span class="line">      [weakSelf.tableView reloadData];</span><br><span class="line">      <span class="comment">// 6.拿到当前的下拉刷新控件，</span></span><br><span class="line">      [weakSelf.tableView.mj_header endRefreshing];</span><br><span class="line">   &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一种常见的使用场景，其中第 1、2、5、6 步都是 MJRefresh 的相关操作。</p>
<h3 id="示例2：UITableView-上拉刷新-动画图片"><a href="#示例2：UITableView-上拉刷新-动画图片" class="headerlink" title="示例2：UITableView + 上拉刷新 动画图片"></a>示例2：UITableView + 上拉刷新 动画图片</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)exampleB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1.设置 footer</span></span><br><span class="line">    <span class="keyword">self</span>.tableView.mj_footer = [MJChiBaoZiFooter footerWithRefreshingTarget:<span class="keyword">self</span> refreshingAction:<span class="keyword">@selector</span>(loadMoreData)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)loadNewData &#123;</span><br><span class="line">    <span class="comment">// 2.下载数据的操作</span></span><br><span class="line">   __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">   [<span class="keyword">self</span> requestNetDataWithCompletionBlock:^(<span class="built_in">NSArray</span> *result, <span class="type">BOOL</span> isSuccess) &#123;</span><br><span class="line">      <span class="comment">// 3.将返回数据追加到表格的数据源（略）</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4.刷新表格，并结束刷新状态</span></span><br><span class="line">      [weakSelf.tableView reloadData];</span><br><span class="line">      <span class="comment">// 5.拿到当前的上拉加载更多控件，</span></span><br><span class="line">      [weakSelf.tableView.mj_footer endRefreshing];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与下拉刷新类似，这里的第 1、4、5 步是 MJRefresh 的相关操作。</p>
<h2 id="3-整体思路"><a href="#3-整体思路" class="headerlink" title="3. 整体思路"></a>3. 整体思路</h2><p>在开始分析源码之前，我觉得应该先大概了解一下这个库的基本实现思路，这样看源码的时候才不至于晕头转向，不知所云。下面以<code>下拉刷新</code>为例，做一个简单介绍，先看下图。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37656ab6f0f94cdb95c9d3841c262659~tplv-k3u1fbpfcp-watermark.image" alt="mjrefresh-1.png"></p>
<p>首先，当我们给 tableView.mj_header 赋值时，实际在 tableView 上添加一个子视图即刷新控件，但是并不是添加到 tableView 的 header 里边，因此就不会占用 tableView 的 header。</p>
<p>然后，对 tableView 进行监听 (KVO)，当 tableView 的 contentOffset 发生变化时，刷新控件会截获到这个时机，根据 contentOffset 的 y 值更新刷新控件的显示及 tableView 的 contentInset.top，整个流程见上图。下面说说这张图吧 O(∩_∩)O：</p>
<p>① 刚把刷新控件加到 tableView 上的时候，设置刷新控件的 y 值为自身高度的负值，此时改控件会被导航挡住，当然也可以再设置其透明度为0。</p>
<p>② 下拉 tableView，当刷新控件完全显示出来（临界点）之前，是一种状态，此时松手的话，会直接弹回去。</p>
<p>③ 过了临界点，再往下拉的时候，更新控件的显示，此时松手的话就开始刷新。</p>
<p>④ 放手刷新的时候，控件会回弹，可以加动画，不至于那么生硬。同时执行调用方传入的 block，一般是请求网络数据的操作。</p>
<p>⑤ 刷新过程中，要显示该刷新控件，即不让其弹回到导航后边，就给 tableView.contentInset.top 增加一个控件的高度，当然是负值。</p>
<p>⑥ 当调用方请求完数据后，手动调用 刷新控件的 endRefreshing 方法，在这个方法类里边更新控件 UI 至初始状态，并将 tableView.contentInset.top 减少一个控件的高度，当然也是负值，至此，刷新结束。</p>
<p>以上就基本实现逻辑，下面开始看源码吧。</p>
<h2 id="4-源码分析"><a href="#4-源码分析" class="headerlink" title="4. 源码分析"></a>4. 源码分析</h2><p>下面分别探究一下下拉刷新和上拉加载更多的源码实现。</p>
<p>通过 <code>示例1</code> 和 <code>示例2</code> 可以推测，这个框架可以大概分 2 部分，一部分是刷新控件的载体 (UIScrollView及其子类，即 tableView 和 collectionView)，另一部分就是刷新控件本身，也就是所谓的 header 和 footer。</p>
<h3 id="4-1-刷新控件的载体"><a href="#4-1-刷新控件的载体" class="headerlink" title="4.1 刷新控件的载体"></a>4.1 刷新控件的载体</h3><p>载体主要集中在下边这几个分类里边</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIScrollView</span>+MJExtension</span><br><span class="line"><span class="built_in">UIScrollView</span>+MJRefresh</span><br><span class="line"><span class="built_in">UIView</span>+MJExtension</span><br></pre></td></tr></table></figure>

<h4 id="UIView-MJExtension"><a href="#UIView-MJExtension" class="headerlink" title="UIView+MJExtension"></a>UIView+MJExtension</h4><p>UIView+MJExtension 只是为公共基类 UIView 的 frame 提供了便捷的访问方式，包括刷新控件也会用到。</p>
<h4 id="UIScrollView-MJRefresh"><a href="#UIScrollView-MJRefresh" class="headerlink" title="UIScrollView+MJRefresh"></a>UIScrollView+MJRefresh</h4><p>UIScrollView+MJRefresh 是列表基类的分类，这个文件里边实际包含了 3 个分类，依次为 </p>
<p>① NSObject (MJRefresh)：分别提供了交换类方法和交换实例方法的工具方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 交换实例方法</span></span><br><span class="line">+ (<span class="type">void</span>)exchangeInstanceMethod1:(SEL)method1 method2:(SEL)method2</span><br><span class="line">&#123;</span><br><span class="line">    method_exchangeImplementations(class_getInstanceMethod(<span class="keyword">self</span>, method1), class_getInstanceMethod(<span class="keyword">self</span>, method2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 交换类方法</span></span><br><span class="line">+ (<span class="type">void</span>)exchangeClassMethod1:(SEL)method1 method2:(SEL)method2</span><br><span class="line">&#123;</span><br><span class="line">    method_exchangeImplementations(class_getClassMethod(<span class="keyword">self</span>, method1), class_getClassMethod(<span class="keyword">self</span>, method2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② UIScrollView (MJRefresh)：依次为基类 UIScrollView 添加了 header、footer 和 mj_reloadDataBlock 这三个属性，并利用关联对象添加了对应的 setter 和 getter 实现，关于在既有类中使用关联对象存放自定义数据的方法，可以查阅《Effective Objective-C 2.0》中第 10 条的介绍。</p>
<p>其中，在 <code>mj_reloadDataBlock</code> 的 <code>setter</code> 中设置关联对象前后分别添加了 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 这 2 个方法，意在可以添加 KVO 监听。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setMj_reloadDataBlock:(<span class="type">void</span> (^)(<span class="built_in">NSInteger</span>))mj_reloadDataBlock</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;mj_reloadDataBlock&quot;</span>]; <span class="comment">// KVO</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;MJRefreshReloadDataBlockKey, mj_reloadDataBlock, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;mj_reloadDataBlock&quot;</span>]; <span class="comment">// KVO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后提供了一个执行 <code>mj_reloadDataBlock</code> 的方法 <code>executeReloadDataBlock</code>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)executeReloadDataBlock</span><br><span class="line">&#123;</span><br><span class="line">    !<span class="keyword">self</span>.mj_reloadDataBlock ? : <span class="keyword">self</span>.mj_reloadDataBlock(<span class="keyword">self</span>.mj_totalDataCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即如果设置了 <code>mj_reloadDataBlock</code> ，就在此执行这个 block，我们注意到这个参数 <code>mj_totalDataCount</code>，点开后发现，原来它指的是 UITableView 或 UICollectionView 的总行数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)mj_totalDataCount</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> totalCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:[<span class="built_in">UITableView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">UITableView</span> *tableView = (<span class="built_in">UITableView</span> *)<span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> section = <span class="number">0</span>; section&lt;tableView.numberOfSections; section++) &#123;</span><br><span class="line">            totalCount += [tableView numberOfRowsInSection:section];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:[<span class="built_in">UICollectionView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">UICollectionView</span> *collectionView = (<span class="built_in">UICollectionView</span> *)<span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> section = <span class="number">0</span>; section&lt;collectionView.numberOfSections; section++) &#123;</span><br><span class="line">            totalCount += [collectionView numberOfItemsInSection:section];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> totalCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③④ UITableView (MJRefresh) 和 UICollectionView (MJRefresh)，他们都提供了下边两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> exchangeInstanceMethod1:<span class="keyword">@selector</span>(reloadData) method2:<span class="keyword">@selector</span>(mj_reloadData)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)mj_reloadData</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> mj_reloadData];</span><br><span class="line">    [<span class="keyword">self</span> executeReloadDataBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，在程序启动时执行 load 方法时将列表的 <code>reloadData</code> 方法与自定义的 <code>mj_reloadData</code> 方法交换，在新方法中增加了一步操作 <code>[self executeReloadDataBlock];</code>，即执行上文提到的 <code>mj_reloadDataBlock</code>，这样，当我们执行 tableView 的 reloadData 方法时，实际执行的就是 mj_reloadData 这个方法了。</p>
<p>那么这个  block 是什么时候设置的呢，全局搜索了一下，发现只有在 <code>MJRefreshFooter</code> 的 <code>willMoveToSuperview:</code> 方法中设置过，也就是将 footer 添加到 tableView 上的时候。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)willMoveToSuperview:(<span class="built_in">UIView</span> *)newSuperview</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> willMoveToSuperview:newSuperview];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前视图被添加到父视图上时，设置后边的 block，即当列表（UICollectionView 或 UITableView）行数为 0 时，隐藏当前视图。</span></span><br><span class="line">    <span class="keyword">if</span> (newSuperview) &#123;</span><br><span class="line">        <span class="comment">// 监听scrollView数据的变化</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.scrollView isKindOfClass:[<span class="built_in">UITableView</span> <span class="keyword">class</span>]] || [<span class="keyword">self</span>.scrollView isKindOfClass:[<span class="built_in">UICollectionView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.scrollView setMj_reloadDataBlock:^(<span class="built_in">NSInteger</span> totalDataCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.isAutomaticallyHidden) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.hidden = (totalDataCount == <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>willMoveToSuperview:</code> 是将视图添加到父视图或从父视图中移除时调用的，<code> if (newSuperview) &#123; ... &#125;</code> 说明是将 footer 添加到父视图上的时候设置这个 block 的，block 的具体实现是：如果需要自动隐藏，则当数据的总条数为 0 时，隐藏 footer，否则展示。</p>
<h4 id="UIScrollView-MJExtension"><a href="#UIScrollView-MJExtension" class="headerlink" title="UIScrollView+MJExtension"></a>UIScrollView+MJExtension</h4><p>UIScrollView+MJExtension 是关于下边几个属性的便捷访问方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contentInset / adjustedContentInset</span><br><span class="line">contentOffset</span><br><span class="line">contentSize</span><br></pre></td></tr></table></figure>

<p>其中，adjustedContentInset 是 iOS 11 新引入的一个 属性，在 iOS 11 中决定 tableView 的内容与边缘距离的是 adjustedContentInset 属性，而不是 contentInset。</p>
<h3 id="4-2下拉刷新控件（refreshHeader）"><a href="#4-2下拉刷新控件（refreshHeader）" class="headerlink" title="4.2下拉刷新控件（refreshHeader）"></a>4.2下拉刷新控件（refreshHeader）</h3><p>先来看一张图：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dae262dbc99a4e0783890f12f214523a~tplv-k3u1fbpfcp-watermark.image" alt="mjrefresh-2.png"></p>
<p>上图就是 header 的继承关系，示例中的 <code>MJChiBaoZiHeader</code> 就是继承自 <code>MJRefreshGifHeader</code>。为了描述更有条理，我们从基类开始讨论吧。</p>
<h4 id="MJRefreshComponent"><a href="#MJRefreshComponent" class="headerlink" title="MJRefreshComponent"></a>MJRefreshComponent</h4><p><code>MJRefreshComponent</code> 是所有 header 和 footer 的基类，这里定义了表示刷新状态的枚举 MJRefreshState 和 3 种不同的回调。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 刷新控件的状态 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, MJRefreshState) &#123;</span><br><span class="line">    <span class="comment">/** 普通闲置状态 */</span></span><br><span class="line">    MJRefreshStateIdle = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/** 松开就可以进行刷新的状态 */</span></span><br><span class="line">    MJRefreshStatePulling,</span><br><span class="line">    <span class="comment">/** 正在刷新中的状态 */</span></span><br><span class="line">    MJRefreshStateRefreshing,</span><br><span class="line">    <span class="comment">/** 即将刷新的状态 */</span></span><br><span class="line">    MJRefreshStateWillRefresh,</span><br><span class="line">    <span class="comment">/** 所有数据加载完毕，没有更多的数据了 */</span></span><br><span class="line">    MJRefreshStateNoMoreData</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入刷新状态的回调 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^MJRefreshComponentRefreshingBlock)(<span class="type">void</span>);</span><br><span class="line"><span class="comment">/** 开始刷新后的回调(进入刷新状态后的回调) */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^MJRefreshComponentbeginRefreshingCompletionBlock)(<span class="type">void</span>);</span><br><span class="line"><span class="comment">/** 结束刷新后的回调 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^MJRefreshComponentEndRefreshingCompletionBlock)(<span class="type">void</span>);</span><br></pre></td></tr></table></figure>

<p>实际上这个类的文件里有两个类，除了自己之外还有一个 UILabel 的分类，提供了一个创建定制好的 Label 的类方法 <code>mj_label</code> 和获取文本宽度的实例方法 <code>mj_textWith</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)mj_label</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UILabel</span> *label = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    label.font = MJRefreshLabelFont;</span><br><span class="line">    label.textColor = MJRefreshLabelTextColor;</span><br><span class="line">    label.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span>;</span><br><span class="line">    label.textAlignment = <span class="built_in">NSTextAlignmentCenter</span>;</span><br><span class="line">    label.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">    <span class="keyword">return</span> label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)mj_textWith &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> stringWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(MAXFLOAT, MAXFLOAT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.text.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000</span></span><br><span class="line">        stringWidth =[<span class="keyword">self</span>.text</span><br><span class="line">                      boundingRectWithSize:size</span><br><span class="line">                      options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span></span><br><span class="line">                      attributes:@&#123;<span class="built_in">NSFontAttributeName</span>:<span class="keyword">self</span>.font&#125;</span><br><span class="line">                      context:<span class="literal">nil</span>].size.width;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        </span><br><span class="line">        stringWidth = [<span class="keyword">self</span>.text sizeWithFont:<span class="keyword">self</span>.font</span><br><span class="line">                            constrainedToSize:size</span><br><span class="line">                                lineBreakMode:<span class="built_in">NSLineBreakByCharWrapping</span>].width;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看看 <code>MJRefreshComponent</code> 这个类吧，依照惯例，从初始化方法开始:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="variable language_">super</span> initWithFrame:frame]) &#123;</span><br><span class="line">        <span class="comment">// 准备工作</span></span><br><span class="line">        [<span class="keyword">self</span> prepare];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 默认是普通状态</span></span><br><span class="line">        <span class="keyword">self</span>.state = MJRefreshStateIdle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)prepare</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基本属性</span></span><br><span class="line">    <span class="keyword">self</span>.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span>;</span><br><span class="line">    <span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化了几个变量：</p>
<p>①初始状态设置为普通状态，既没有触发刷新的情况；</p>
<p>②<code>prepare</code>方法中设置了两个基本属性，<code>backgroundColor</code> 和 <code>autoresizingMask</code>，autoresizingMask 的初值 <code>UIViewAutoresizingFlexibleWidth</code> 指的是：当父视图的 bounds 改变时，子视图 (即当前视图) 自动调整宽度，以保证左、右边距不变。</p>
<p>关于布局，这里重写了 <code>layoutSubviews</code> 方法，在调用 super 的方法之前增加了一步操作 <code>placeSubviews</code>，这个方法需要子类来实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> placeSubviews];</span><br><span class="line">    </span><br><span class="line">    [<span class="variable language_">super</span> layoutSubviews];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)placeSubviews &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写了 <code>willMoveToSuperview:</code> 这个方法用于将当前视图添加到父视图或从父视图中移除时添加一些额外操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)willMoveToSuperview:(<span class="built_in">UIView</span> *)newSuperview</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> willMoveToSuperview:newSuperview];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不是UIScrollView，不做任何事情</span></span><br><span class="line">    <span class="keyword">if</span> (newSuperview &amp;&amp; ![newSuperview isKindOfClass:[<span class="built_in">UIScrollView</span> <span class="keyword">class</span>]]) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 旧的父控件移除监听</span></span><br><span class="line">    [<span class="keyword">self</span> removeObservers];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newSuperview) &#123; <span class="comment">// 新的父控件</span></span><br><span class="line">        <span class="comment">// 设置宽度</span></span><br><span class="line">        <span class="keyword">self</span>.mj_w = newSuperview.mj_w;</span><br><span class="line">        <span class="comment">// 设置位置</span></span><br><span class="line">        <span class="keyword">self</span>.mj_x = -_scrollView.mj_insetL;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录UIScrollView</span></span><br><span class="line">        _scrollView = (<span class="built_in">UIScrollView</span> *)newSuperview;</span><br><span class="line">        <span class="comment">// 设置永远支持垂直弹簧效果</span></span><br><span class="line">        _scrollView.alwaysBounceVertical = <span class="literal">YES</span>;</span><br><span class="line">        <span class="comment">// 记录UIScrollView最开始的contentInset</span></span><br><span class="line">        _scrollViewOriginalInset = _scrollView.mj_inset;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加监听</span></span><br><span class="line">        [<span class="keyword">self</span> addObservers];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先对 newSuperview 做了一层过滤，只有是 UIScrollView 及其子类才可以继续往下走。</p>
<p>然后，先将旧的监听移除。</p>
<p>如果是移除当前视图的操作，则会跳过下边的 if 代码，结束这个方法的执行。如果是将当前视图添加父视图上，即父视图 newSuperview 存在时，保存一些值，最后添加新的监听。</p>
<p>下面看看添加、移除监听的这波操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)addObservers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentOffset options:options context:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentSize options:options context:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">self</span>.pan = <span class="keyword">self</span>.scrollView.panGestureRecognizer;</span><br><span class="line">    [<span class="keyword">self</span>.pan addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathPanState options:options context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)removeObservers</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.superview removeObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentOffset];</span><br><span class="line">    [<span class="keyword">self</span>.superview removeObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentSize];</span><br><span class="line">    [<span class="keyword">self</span>.pan removeObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathPanState];</span><br><span class="line">    <span class="keyword">self</span>.pan = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听主要是针对 self.ScrollView 即父视图的 contentOffset、contentSize 和 父视图的 panGestureRecognizer 的 state。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="type">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="type">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 遇到这些情况就直接返回：不能交互</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.userInteractionEnabled) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个就算看不见也需要处理</span></span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> scrollViewContentSizeDidChange:change];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 看不见</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.hidden) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> scrollViewContentOffsetDidChange:change];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathPanState]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> scrollViewPanStateDidChange:change];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当监听到变换时，会分别触发对应的处理方法（下边 3 个），其中 <code>scrollViewContentOffsetDidChange:</code> 在下拉刷新和上拉加载更多时都会用到，后边两个方法只在上拉加载更多时会用到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change&#123;&#125;</span><br><span class="line">- (void)scrollViewContentSizeDidChange:(NSDictionary *)change&#123;&#125;</span><br><span class="line">- (void)scrollViewPanStateDidChange:(NSDictionary *)change&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是一批公共方法：</p>
<p>① 设置回调对象和回调方法，提供了一种内部的响应方式，即使用 target-Action 的方式，执行刷新回调 <code>executeRefreshingCallback</code> 时候用到，见下边的内部方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setRefreshingTarget:(<span class="type">id</span>)target refreshingAction:(SEL)action</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.refreshingTarget = target;</span><br><span class="line">    <span class="keyword">self</span>.refreshingAction = action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - 内部方法</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)executeRefreshingCallback</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshDispatchAsyncOnMainQueue(&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.refreshingBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.refreshingBlock();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// #define MJRefreshMsgSend(...) ((void (*)(void *, SEL, UIView *))objc_msgSend)(__VA_ARGS__)</span></span><br><span class="line">        <span class="comment">// #define MJRefreshMsgTarget(target) (__bridge void *)(target)</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.refreshingTarget respondsToSelector:<span class="keyword">self</span>.refreshingAction]) &#123;</span><br><span class="line">            MJRefreshMsgSend(MJRefreshMsgTarget(<span class="keyword">self</span>.refreshingTarget), <span class="keyword">self</span>.refreshingAction, <span class="keyword">self</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.beginRefreshingCompletionBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.beginRefreshingCompletionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是一个很重要的 setter，子类可以重写该方法，在状态方法改变的时候，及时更新刷新控件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setState:(MJRefreshState)state</span><br><span class="line">&#123;</span><br><span class="line">    _state = state;</span><br><span class="line">    </span><br><span class="line">    // 加入主队列的目的是等setState:方法调用完毕、设置完文字后再去布局子控件</span><br><span class="line">    MJRefreshDispatchAsyncOnMainQueue([self setNeedsLayout];)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② 进入刷新及结束刷新的方法，每种情况分别提供了一个带 block 和一个不带 block 的方法，后者保存了 block 之后，又调用了前者，这个 block 的作用是用来添加刷新结束后的附加操作的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark 进入刷新状态</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)beginRefreshing</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</span><br><span class="line">        <span class="keyword">self</span>.alpha = <span class="number">1.0</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">self</span>.pullingPercent = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 只要正在刷新，就完全显示</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.window) &#123;</span><br><span class="line">        <span class="keyword">self</span>.state = MJRefreshStateRefreshing;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 预防正在刷新中时，调用本方法使得header inset回置失败</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.state != MJRefreshStateRefreshing) &#123;</span><br><span class="line">            <span class="keyword">self</span>.state = MJRefreshStateWillRefresh;</span><br><span class="line">            <span class="comment">// 刷新(预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下)</span></span><br><span class="line">            [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)beginRefreshingWithCompletionBlock:(<span class="type">void</span> (^)(<span class="type">void</span>))completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.beginRefreshingCompletionBlock = completionBlock;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> beginRefreshing];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark 结束刷新状态</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)endRefreshing</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshDispatchAsyncOnMainQueue(<span class="keyword">self</span>.state = MJRefreshStateIdle;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)endRefreshingWithCompletionBlock:(<span class="type">void</span> (^)(<span class="type">void</span>))completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.endRefreshingCompletionBlock = completionBlock;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> endRefreshing];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③ 最后是根据拖拽进度自动改变透明度的相关方法，即如果需要自动改变透明度，则会在拖拽过程中，将拖拽进度时时赋值给 self.alpha。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark 自动切换透明度</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setAutoChangeAlpha:(<span class="type">BOOL</span>)autoChangeAlpha</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.automaticallyChangeAlpha = autoChangeAlpha;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)isAutoChangeAlpha</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.isAutomaticallyChangeAlpha;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setAutomaticallyChangeAlpha:(<span class="type">BOOL</span>)automaticallyChangeAlpha</span><br><span class="line">&#123;</span><br><span class="line">    _automaticallyChangeAlpha = automaticallyChangeAlpha;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isRefreshing) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (automaticallyChangeAlpha) &#123;</span><br><span class="line">        <span class="keyword">self</span>.alpha = <span class="keyword">self</span>.pullingPercent;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.alpha = <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark 根据拖拽进度设置透明度</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setPullingPercent:(<span class="built_in">CGFloat</span>)pullingPercent</span><br><span class="line">&#123;</span><br><span class="line">    _pullingPercent = pullingPercent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不是正在刷新的状态，而且要求自动改变透明度时，将 pullingPercent 的值给 alpha，否则不再往下执行。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isRefreshing) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isAutomaticallyChangeAlpha) &#123;</span><br><span class="line">        <span class="keyword">self</span>.alpha = pullingPercent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MJRefreshHeader"><a href="#MJRefreshHeader" class="headerlink" title="MJRefreshHeader"></a>MJRefreshHeader</h4><p><code>MJRefreshHeader</code> 是 <code>MJRefreshComponent </code> 的子类，但还不是最终可以使用的类，还在为其子类做准备。先来看看它提供的两个构造方法，在创建实例对象的同时，保存了响应的回调，一个采用 block，另一个采用 target-action 的方式。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - 构造方法</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)headerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshHeader *cmp = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    cmp.refreshingBlock = refreshingBlock;</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)headerWithRefreshingTarget:(<span class="type">id</span>)target refreshingAction:(SEL)action</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshHeader *cmp = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    [cmp setRefreshingTarget:target refreshingAction:action];</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下边是重写父类的方法，首先在 <code>prepare</code> 和 &#96;&#96; 方法中设置存取刷新时刻用的 key 、自身高度 mj_h 及 自身的 y 坐标 mj_y。这里出现了一个 <code>ignoredScrollViewContentInsetTop</code>，推测是一个预留的 refreshHeader 和 tableView 之间的间隙值，默认为 0，需要用户设置才会有值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)prepare</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> prepare];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置key</span></span><br><span class="line">    <span class="keyword">self</span>.lastUpdatedTimeKey = MJRefreshHeaderLastUpdatedTimeKey;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置高度</span></span><br><span class="line">    <span class="keyword">self</span>.mj_h = MJRefreshHeaderHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)placeSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> placeSubviews];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置y值(当自己的高度发生改变了，肯定要重新调整Y值，所以放到placeSubviews方法中设置y值)</span></span><br><span class="line">    <span class="keyword">self</span>.mj_y = - <span class="keyword">self</span>.mj_h - <span class="keyword">self</span>.ignoredScrollViewContentInsetTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是 2 个重要的方法，<code>scrollViewContentOffsetDidChange:</code> 和 <code>setState:</code>。</p>
<p><code>scrollViewContentOffsetDidChange:</code> 方法主要是根据当前状态 (self.state) 和 contentOffset 更新 self.state，之所以要考虑当前状态，是为了避免频繁的更新 state 的值，详见代码注释。</p>
<p> <code>setState:</code> 方法针对 <code>进入刷新状态</code> 和 <code>从刷新恢复正常状态</code> 分别进行处理，前者话，将 scrollView 的 contentInset.top 加上一个 refreshHeader 的高度，对于后者，又需要将之前加上的高度减掉，以此来控制刷新控件的悬浮状态。另外， <code>从刷新恢复正常状态</code> 时，保存了当前时刻，这个是为了显示上一次刷新时间用的。</p>
<p>最后是 2 个公共方法，一个用来获取保存在本地的上次刷新时间，另一个是 <code>ignoredScrollViewContentInsetTop</code> 的setter，同时更新了刷新控件的 y 值。</p>
<h4 id="MJRefreshStateHeader"><a href="#MJRefreshStateHeader" class="headerlink" title="MJRefreshStateHeader"></a>MJRefreshStateHeader</h4><p><code>MJRefreshStateHeader</code> 也属于这个继承体系中的一员，继承自 <code>MJRefreshHeader </code>，这里开始就到实用阶段了：</p>
<ul>
<li><p>在 prepare 方法中将三种状态对应的标签保存到一个可变字典（stateTitles）中，以备后边展示。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)prepare &#123;</span><br><span class="line">    [<span class="variable language_">super</span> prepare];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化间距</span></span><br><span class="line">    <span class="keyword">self</span>.labelLeftInset = MJRefreshLabelLeftInset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化文字</span></span><br><span class="line">    <span class="comment">// 初始未触发刷新的状态</span></span><br><span class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderIdleText] forState:MJRefreshStateIdle];</span><br><span class="line">    <span class="comment">// 拖拽状态</span></span><br><span class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderPullingText] forState:MJRefreshStatePulling];</span><br><span class="line">    <span class="comment">// 刷新状态</span></span><br><span class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderRefreshingText] forState:MJRefreshStateRefreshing];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setTitle:(<span class="built_in">NSString</span> *)title forState:(MJRefreshState)state &#123;</span><br><span class="line">    <span class="keyword">if</span> (title == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">self</span>.stateTitles[@(state)] = title;</span><br><span class="line">    <span class="keyword">self</span>.stateLabel.text = <span class="keyword">self</span>.stateTitles[@(<span class="keyword">self</span>.state)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用懒加载的方式为 header 添加了两个标签，分别用于展示状态提示文案和上次刷新的时间；</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 显示刷新状态的label */</span></span><br><span class="line">- (<span class="built_in">UILabel</span> *)stateLabel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_stateLabel) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addSubview:_stateLabel = [<span class="built_in">UILabel</span> mj_label]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _stateLabel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 显示上一次刷新时间的label */</span></span><br><span class="line">- (<span class="built_in">UILabel</span> *)lastUpdatedTimeLabel &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_lastUpdatedTimeLabel) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addSubview:_lastUpdatedTimeLabel = [<span class="built_in">UILabel</span> mj_label]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _lastUpdatedTimeLabel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>setState:</code> 方法中为 2 个标签分别赋值，stateLabel 根据 state 从之前保存的可变字典（stateTitles）中取值（这里作者做了本地化处理），lastUpdatedTimeLabel 的赋值有点特别，他是在 <code>setLastUpdatedTimeKey:</code> 方法中对时间进行格式化等相关处理后赋值给 lastUpdatedTimeLabel，所以每次更新 state 的时候要调用用一次 <code>self.lastUpdatedTimeKey = self.lastUpdatedTimeKey</code>。</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setState:(MJRefreshState)state</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshCheckState</span><br><span class="line">    <span class="comment">// 设置状态文字</span></span><br><span class="line">    <span class="keyword">self</span>.stateLabel.text = <span class="keyword">self</span>.stateTitles[@(state)];</span><br><span class="line">    <span class="comment">// 重新设置key（重新显示时间）</span></span><br><span class="line">    <span class="keyword">self</span>.lastUpdatedTimeKey = <span class="keyword">self</span>.lastUpdatedTimeKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MJRefreshGifHeader"><a href="#MJRefreshGifHeader" class="headerlink" title="MJRefreshGifHeader"></a>MJRefreshGifHeader</h4><p><code>MJRefreshGifHeader</code> 继承自上一个类，并增加了一个用于展示动画图片的 imageView 及用于保存各种状态对应的动画图片和动画时间字典。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="built_in">UIImageView</span> *_gifView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 所有状态对应的动画图片 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableDictionary</span> *stateImages;</span><br><span class="line"><span class="comment">/** 所有状态对应的动画时间 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableDictionary</span> *stateDurations;</span><br></pre></td></tr></table></figure>
<p>为了获取这些动画图片和时间，并与对应的状态关联起来，提供了 2 个供外界调用的方法，图片必须提供，时间可以不传(第二种方法)，会去默认值 <code>images.count * 0.1</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setImages:(<span class="built_in">NSArray</span> *)images duration:(<span class="built_in">NSTimeInterval</span>)duration forState:(MJRefreshState)state </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (images == <span class="literal">nil</span>) <span class="keyword">return</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.stateImages[@(state)] = images; </span><br><span class="line">    <span class="keyword">self</span>.stateDurations[@(state)] = @(duration); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 根据图片设置控件的高度 */</span> </span><br><span class="line">    <span class="built_in">UIImage</span> *image = [images firstObject]; </span><br><span class="line">    <span class="keyword">if</span> (image.size.height &gt; <span class="keyword">self</span>.mj_h) &#123; </span><br><span class="line">        <span class="keyword">self</span>.mj_h = image.size.height; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setImages:(<span class="built_in">NSArray</span> *)images forState:(MJRefreshState)state </span><br><span class="line">&#123; </span><br><span class="line">    [<span class="keyword">self</span> setImages:images duration:images.count * <span class="number">0.1</span> forState:state]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里重写了父类的 <code>setState:</code> 方法，当拖拽或刷新的时候才会去设置动画图片，首先停止之前的动画，然后再设置新值，如果是单张图片，直接展示，多张情况才需要展示动画; 如果 state 是正常状态，则停止动画。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setState:(MJRefreshState)state</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshCheckState</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据状态做事情</span></span><br><span class="line">    <span class="keyword">if</span> (state == MJRefreshStatePulling || state == MJRefreshStateRefreshing) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *images = <span class="keyword">self</span>.stateImages[@(state)];</span><br><span class="line">        <span class="keyword">if</span> (images.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.gifView stopAnimating];</span><br><span class="line">        <span class="keyword">if</span> (images.count == <span class="number">1</span>) &#123; <span class="comment">// 单张图片</span></span><br><span class="line">            <span class="keyword">self</span>.gifView.image = [images lastObject];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 多张图片</span></span><br><span class="line">            <span class="keyword">self</span>.gifView.animationImages = images;</span><br><span class="line">            <span class="keyword">self</span>.gifView.animationDuration = [<span class="keyword">self</span>.stateDurations[@(state)] doubleValue];</span><br><span class="line">            [<span class="keyword">self</span>.gifView startAnimating];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.gifView stopAnimating];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MJChiBaoZiHeader"><a href="#MJChiBaoZiHeader" class="headerlink" title="MJChiBaoZiHeader"></a>MJChiBaoZiHeader</h4><p>先来看看 <code>prepare</code> 的实现，只重写了父类的一个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)prepare</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 0.执行父类的 prepare 方法</span></span><br><span class="line">    [<span class="variable language_">super</span> prepare];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.设置普通状态的动画图片</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *idleImages = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">1</span>; i&lt;=<span class="number">60</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;dropdown_anim__000%zd&quot;</span>, i]];</span><br><span class="line">        [idleImages addObject:image];</span><br><span class="line">    &#125;</span><br><span class="line">     [<span class="keyword">self</span> setImages:idleImages forState:MJRefreshStateIdle];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.设置即将刷新状态的动画图片（一松开就会刷新的状态）</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *refreshingImages = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;dropdown_loading_0%zd&quot;</span>, i]];</span><br><span class="line">        [refreshingImages addObject:image];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> setImages:refreshingImages forState:MJRefreshStatePulling];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.设置正在刷新状态的动画图片</span></span><br><span class="line">    [<span class="keyword">self</span> setImages:refreshingImages forState:MJRefreshStateRefreshing];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实现见上边的代码注释，其中 <code>prepare</code> 和 <code>setImages: forState:</code> 两个方法均来自基类，上边已经介绍过了。</p>
<h3 id="4-3-上拉加载更多控件（refreshFooter）"><a href="#4-3-上拉加载更多控件（refreshFooter）" class="headerlink" title="4.3 上拉加载更多控件（refreshFooter）"></a>4.3 上拉加载更多控件（refreshFooter）</h3><p>与 header 类似，先看一下类的继承关系：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa752c6e3e984482b55d6a9f5824dfad~tplv-k3u1fbpfcp-watermark.image" alt="mjrefresh-3.png"></p>
<p>既然都是继承自 <code>MJRefreshComponent</code>，这里就直接从 <code>MJRefreshFooter</code> 开始讨论，然后准者继承体系一直讲到 <code>MJChiBaoZiFooter</code>，即示例 2 用到的 footer。</p>
<h4 id="MJRefreshFooter"><a href="#MJRefreshFooter" class="headerlink" title="MJRefreshFooter"></a>MJRefreshFooter</h4><p>观察这个类的源码就会发现，他和 <code>MJRefreshHeader</code> 有许多相似之处，比如都提供了两个构造方法，一个用 block ，一个用 target-Action。下面主要说下不一样的地方。</p>
<p>有一个自动根据有无数据来显示和隐藏 footer 的属性 <code>automaticallyHidden</code>，不过作者不建议使用，而且后期可能会移除。不过，还是假名单介绍一下吧。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isAutomaticallyHidden) <span class="type">BOOL</span> automaticallyHidden</span><br></pre></td></tr></table></figure>

<p>在 <code>viewWillMoveToSuperView:</code> 中设置 footer 隐藏与否的时候会用到这个属性，详见前边 <code>4.1刷新控件的载体  </code> 的介绍，这里不再复述。</p>
<p>最后看 2 个公共方法，废弃的那个就不列出来了O(∩_∩)O：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 提示没有更多的数据 */</span></span><br><span class="line">- (<span class="type">void</span>)endRefreshingWithNoMoreData &#123;</span><br><span class="line">    MJRefreshDispatchAsyncOnMainQueue(<span class="keyword">self</span>.state = MJRefreshStateNoMoreData;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 重置没有更多的数据（消除没有更多数据的状态） */</span></span><br><span class="line">- (<span class="type">void</span>)resetNoMoreData &#123;</span><br><span class="line">    MJRefreshDispatchAsyncOnMainQueue(<span class="keyword">self</span>.state = MJRefreshStateIdle;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MJRefreshAutoFooter"><a href="#MJRefreshAutoFooter" class="headerlink" title="MJRefreshAutoFooter"></a>MJRefreshAutoFooter</h4><p><code>MJRefreshAutoFooter</code> 是 <code>MJRefreshFooter</code> 的直接子类，并不是可以直接使用的类，还是在为子类提供方便，这里需要重点介绍一下。</p>
<ul>
<li>提供了几个公开的属性，其作用见下方注释。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - 公开的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 是否自动刷新(默认为YES，即达到一定的触发条件就会自动开始刷新) */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isAutomaticallyRefresh) <span class="type">BOOL</span> automaticallyRefresh;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当底部控件出现多少时就自动刷新(默认为1.0，也就是底部控件完全出现时，才会自动刷新) */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> triggerAutomaticallyRefreshPercent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 是否每一次拖拽只发一次请求，手没有离开屏幕的情况下反复拖拽的话，不会触发多次刷新 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isOnlyRefreshPerDrag) <span class="type">BOOL</span> onlyRefreshPerDrag;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - 私有的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 是否是一个新的拖拽 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isOneNewPan) <span class="type">BOOL</span> oneNewPan;</span><br></pre></td></tr></table></figure>

<ul>
<li>重写了 <code>willMoveToSuperView</code> 方法，当添加到父控件上时，给 scrollView.contentInset.bottom 添加一个 footer 本身的高度，反之，从父控件上移除时，又要将之前加上的再减掉。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)willMoveToSuperview:(<span class="built_in">UIView</span> *)newSuperview &#123;</span><br><span class="line">    [<span class="variable language_">super</span> willMoveToSuperview:newSuperview];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newSuperview) &#123; <span class="comment">// 添加到父控件上</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.hidden == <span class="literal">NO</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.scrollView.mj_insetB += <span class="keyword">self</span>.mj_h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.mj_y = _scrollView.mj_contentH; <span class="comment">// 设置位置</span></span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; 			<span class="comment">// 被移除了</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.hidden == <span class="literal">NO</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.scrollView.mj_insetB -= <span class="keyword">self</span>.mj_h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在准备数据阶段设置了这么几个初值：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)prepare &#123;</span><br><span class="line">    [<span class="variable language_">super</span> prepare];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认底部控件100%出现时才会自动刷新</span></span><br><span class="line">    <span class="keyword">self</span>.triggerAutomaticallyRefreshPercent = <span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置为默认状态</span></span><br><span class="line">    <span class="keyword">self</span>.automaticallyRefresh = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认是当offset达到条件就发送请求（可连续）</span></span><br><span class="line">    <span class="keyword">self</span>.onlyRefreshPerDrag = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>下面是对 scrollView 的监听触发的 3 个事件：</li>
</ul>
<p>当 scrollView 的 contentSize 发生变化的时候，计时更新 footer 的 y 值，保证它一直贴着 scrollView 的下边沿。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change &#123;</span><br><span class="line">    [<span class="variable language_">super</span> scrollViewContentSizeDidChange:change];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置位置</span></span><br><span class="line">    <span class="keyword">self</span>.mj_y = <span class="keyword">self</span>.scrollView.mj_contentH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当滑动 scrollView 产生 contentOffset 的时候，控制当底部刷新控件完全出现的时候，才能刷新。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> scrollViewContentOffsetDidChange:change];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state != MJRefreshStateIdle || !<span class="keyword">self</span>.automaticallyRefresh || <span class="keyword">self</span>.mj_y == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_scrollView.mj_insetT + _scrollView.mj_contentH &gt; _scrollView.mj_h) &#123; <span class="comment">// 内容超过一个屏幕</span></span><br><span class="line">        <span class="comment">// 这里的_scrollView.mj_contentH替换掉self.mj_y更为合理</span></span><br><span class="line">        <span class="keyword">if</span> (_scrollView.mj_offsetY &gt;= _scrollView.mj_contentH - _scrollView.mj_h + <span class="keyword">self</span>.mj_h * <span class="keyword">self</span>.triggerAutomaticallyRefreshPercent + _scrollView.mj_insetB - <span class="keyword">self</span>.mj_h) &#123;</span><br><span class="line">            <span class="comment">// 防止手松开时连续调用</span></span><br><span class="line">            <span class="built_in">CGPoint</span> old = [change[<span class="string">@&quot;old&quot;</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">            <span class="built_in">CGPoint</span> new = [change[<span class="string">@&quot;new&quot;</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">            <span class="keyword">if</span> (new.y &lt;= old.y) <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当底部刷新控件完全出现时，才刷新</span></span><br><span class="line">            [<span class="keyword">self</span> beginRefreshing];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当手势的状态发生变化的时候，针对 <code>UIGestureRecognizerStateEnded</code> 和 <code>UIGestureRecognizerStateBegan</code> 两种状态进行处理，对于前者，根据 contentOffset.y 决定开始刷新的时机，后者的话，就认为是一个新的手势开始了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> scrollViewPanStateDidChange:change];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state != MJRefreshStateIdle) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGestureRecognizerState</span> panState = _scrollView.panGestureRecognizer.state;</span><br><span class="line">    <span class="keyword">if</span> (panState == <span class="built_in">UIGestureRecognizerStateEnded</span>) &#123;<span class="comment">// 手松开</span></span><br><span class="line">        <span class="keyword">if</span> (_scrollView.mj_insetT + _scrollView.mj_contentH &lt;= _scrollView.mj_h) &#123;  <span class="comment">// 不够一个屏幕</span></span><br><span class="line">            <span class="keyword">if</span> (_scrollView.mj_offsetY &gt;= - _scrollView.mj_insetT) &#123; <span class="comment">// 向上拽</span></span><br><span class="line">                [<span class="keyword">self</span> beginRefreshing];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 超出一个屏幕</span></span><br><span class="line">            <span class="keyword">if</span> (_scrollView.mj_offsetY &gt;= _scrollView.mj_contentH + _scrollView.mj_insetB - _scrollView.mj_h) &#123;</span><br><span class="line">                [<span class="keyword">self</span> beginRefreshing];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (panState == <span class="built_in">UIGestureRecognizerStateBegan</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.oneNewPan = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当然也会重写 <code>setState</code> 方法，如果是刷新状态，就执行刷新的回调；如果是从刷新状态变成没有更多数据或停止刷新的状态，则执行停止刷新完成的 block。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setState:(MJRefreshState)state</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshCheckState</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (state == MJRefreshStateRefreshing) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 刷新状态，执行刷新的回调</span></span><br><span class="line">        [<span class="keyword">self</span> executeRefreshingCallback];</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateNoMoreData || state == MJRefreshStateIdle) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从 刷新状态 进入 没有更多数据或者正常状态 时，如果有完成后的回调，则执行之</span></span><br><span class="line">        <span class="keyword">if</span> (MJRefreshStateRefreshing == oldState) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.endRefreshingCompletionBlock) &#123;</span><br><span class="line">                <span class="keyword">self</span>.endRefreshingCompletionBlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后是 <code>setHidden:</code> 方法，根据显示隐藏的变化，调整 <code>contentInset</code> 、 <code>state</code> 和 <code>self.frame.origin.y</code>。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setHidden:(<span class="type">BOOL</span>)hidden</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">BOOL</span> lastHidden = <span class="keyword">self</span>.isHidden;</span><br><span class="line">    </span><br><span class="line">    [<span class="variable language_">super</span> setHidden:hidden];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从显示变成隐藏状态</span></span><br><span class="line">    <span class="keyword">if</span> (!lastHidden &amp;&amp; hidden) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.state = MJRefreshStateIdle;</span><br><span class="line">        <span class="keyword">self</span>.scrollView.mj_insetB -= <span class="keyword">self</span>.mj_h;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastHidden &amp;&amp; !hidden) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从隐藏变成显示状态</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.scrollView.mj_insetB += <span class="keyword">self</span>.mj_h;</span><br><span class="line">        <span class="comment">// 设置位置</span></span><br><span class="line">        <span class="keyword">self</span>.mj_y = _scrollView.mj_contentH;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MJRefreshAutoStateFooter"><a href="#MJRefreshAutoStateFooter" class="headerlink" title="MJRefreshAutoStateFooter"></a>MJRefreshAutoStateFooter</h4><p><code>MJRefreshAutoStateFooter</code> 继承自 <code>MJRefreshAutoFooter</code> 与 <code>MJRefreshStateHeader</code> 类似，从这里开始介入具体的 UI，既可以直接使用了，这里只介绍与 <code>MJRefreshStateHeader</code> 不同的地方。</p>
<ul>
<li>只有一个显示刷新状态的 <code>stateLabel</code> 和 保存不同状态下文案的可变字典 <code>stateTitles</code></li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 显示刷新状态的label */</span></span><br><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="built_in">UILabel</span> *_stateLabel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 所有状态对应的文字 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableDictionary</span> *stateTitles;</span><br></pre></td></tr></table></figure>

<ul>
<li>重写父类 <code>prepare</code> 方法时，除了保存各种状态的本地化文案外，还给 stateLabel 添加了点击手势。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)prepare</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> prepare];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化间距</span></span><br><span class="line">    <span class="keyword">self</span>.labelLeftInset = MJRefreshLabelLeftInset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化文字</span></span><br><span class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshAutoFooterIdleText] forState:MJRefreshStateIdle];</span><br><span class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshAutoFooterRefreshingText] forState:MJRefreshStateRefreshing];</span><br><span class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshAutoFooterNoMoreDataText] forState:MJRefreshStateNoMoreData];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 监听label</span></span><br><span class="line">    <span class="keyword">self</span>.stateLabel.userInteractionEnabled = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span>.stateLabel addGestureRecognizer:[[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(stateLabelClick)]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击 <code>stateLabel</code> 的时候，如果是正常未刷新的状态，则开始刷新。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)stateLabelClick &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStateIdle) &#123;</span><br><span class="line">        [<span class="keyword">self</span> beginRefreshing];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重写 <code>setState:</code> 方法的时候，增加刷新过程中对 <code>stateLabel</code> 显示与隐藏的控制。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setState:(MJRefreshState)state</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshCheckState</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isRefreshingTitleHidden &amp;&amp; state == MJRefreshStateRefreshing) &#123;</span><br><span class="line">        <span class="keyword">self</span>.stateLabel.text = <span class="literal">nil</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.stateLabel.text = <span class="keyword">self</span>.stateTitles[@(state)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MJRefreshAutoGifFooter"><a href="#MJRefreshAutoGifFooter" class="headerlink" title="MJRefreshAutoGifFooter"></a>MJRefreshAutoGifFooter</h4><p><code>MJRefreshAutoGifFooter</code> 继承自 <code>MJRefreshAutoStateFooter</code>，仔细查看其实现代码，就会发现与 <code>MJRefreshGifHeader</code> 非常类似，都是在父类基础上加了一个 gifView（UIImageView） 用于展示动画图片，其他操作也基本类似，只是增加了没有更多数据的状态 <code>MJRefreshStateNoMoreData</code> 以及 <code>gifView</code> 与 <code>stateLabel</code> 的显隐控制。</p>
<h4 id="MJChiBaoZiFooter"><a href="#MJChiBaoZiFooter" class="headerlink" title="MJChiBaoZiFooter"></a>MJChiBaoZiFooter</h4><p><code>MJChiBaoZiFooter</code> 里边也重写了父类的 <code>prepare</code> 方法，调用了父类的 <code>setImages: forState:</code> 方法用于设置创新状态时的动画图片，至于其方法实现，见父类。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)prepare</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="variable language_">super</span> prepare];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置正在刷新状态的动画图片</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *refreshingImages = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageNamed:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;dropdown_loading_0%zd&quot;</span>, i]];</span><br><span class="line">        [refreshingImages addObject:image];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> setImages:refreshingImages forState:MJRefreshStateRefreshing];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>本文只是对 MJRefresh 源码的一个简单讨论，很多细节还没有讲的很透，后期会及时更新这部分内容。</p>
<h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6.参考"></a>6.参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Effective%20Objective-C%202.0/22878393">《Effective Objective-C 2.0》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/efbc8619d56b">iOS 11 安全区域适配总结</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://devhe.com/2018/12/25/MJRefresh-Source-Learning-Notes/" data-id="cl778ex770000tvfycvek6x2j" data-title="MJRefresh 源码学习笔记" class="article-share-link">Compartir</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Nuevo</strong>
      <div class="article-nav-title">
        
          iOS UITextView 实现类似微博的话题、提及功能
        
      </div>
    </a>
  
  
    <a href="/2018/12/23/MBProgressHUD-Source-Learning-Notes/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Viejo</strong>
      <div class="article-nav-title">MBProgressHUD 源码学习笔记</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archivos</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Posts recientes</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/24/ijkplayer-Compilation-and-Packaging/">ijkplayer 编译-打包-Pod支持</a>
          </li>
        
          <li>
            <a href="/2022/08/23/Topics-and-mentions-similar-to-Weibo/">iOS UITextView 实现类似微博的话题、提及功能</a>
          </li>
        
          <li>
            <a href="/2018/12/25/MJRefresh-Source-Learning-Notes/">MJRefresh 源码学习笔记</a>
          </li>
        
          <li>
            <a href="/2018/12/23/MBProgressHUD-Source-Learning-Notes/">MBProgressHUD 源码学习笔记</a>
          </li>
        
          <li>
            <a href="/2018/12/15/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 He Hai<br>
      Construido por <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>